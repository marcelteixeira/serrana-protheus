#INCLUDE "FINA050.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "DBINFO.CH"
#INCLUDE "MSMGADD.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "FWADAPTEREAI.CH"
#INCLUDE "XMLXFUN.CH"

Static lFWCodFil	:= .T.
Static cArqTmp		:= "" //arquivo temporario utilizado para IR. Necessario para tirar da transação quando utilizada NFE (mata103) ;
						  // e não dar erro ao excluir as tabelas quando utilizado banco postgres
Static lNewIrBx		:= .T.
Static lPmsInt		:= IsIntegTop(,.T.)
Static nOldTxMoeda	:= 0
Static lAcumIr		:= ExistBlock( "F050CALIR" )
Static lIsIssBx		:= FindFunction("IsIssBx")
Static dLastPCC		:= CTOD("22/06/2015")
Static lF050INS		:= ExistBlock("F050INS")
Static lF50PERGUNT	:= ExistBlock("F50PERGUNT")
Static lRatDes		:= .F.
Static _oFINA0501	:= NIL
Static cChvTitDsd 	:= ""
Static lFA050UPD	:= ExistBlock("FA050UPD")
Static lF050PROV	:= ExistBlock("F050PROV")
Static lF050RAT 	:= ExistBlock("F050RAT")
Static lF050ATP		:= ExistBlock("F050ATP")
Static lF050CIRF 	:= ExistBlock("F050CIRF")
Static lFINCDRET 	:= ExistBlock("FINCDRET")
Static lF050TMP1 	:= ExistBlock("F050TMP1")
Static lF050HEAD	:= ExistBlock("F050HEAD")
Static lF50CIRFF	:= ExistBlock("F50CIRFF")
Static lF050NPROV	:= ExistBlock("F050NPROV")
Static lF050DELC	:= ExistBlock("F050DELC")
Static lFa050Par	:= ExistBlock("FA050PAR")
Static nTamFor		:= NIL
Static cForPar		:= NIL
Static nTamEHNum	:= NIL
Static lRatMulNat	:= .F.
Static lF050CMNT 	:= FindFunction("F050CMNT")

static lPLSFN050 	:= FindFunction("PLSFN050")

Static lIntPFS		:= SuperGetMv("MV_JURXFIN",.T.,.F.)//Integração do Financeiro com o Juridico(Habilitado = .T.)
Static lBtrISS		:= .F.

Static __lFAPodeTVA	:= ExistFunc("FAPodeTVA")
Static __lFINA050VA	:= FindFunction("FINA050VA")
Static __lExisFKD	:= .F.
Static __lFWHasEAI  := FWHasEAI("FINA050", .T.,, .T.)
Static aVAAuto      := NIL

// Motor de Retenções
Static lTemMR    := (FindFunction("FTemMotor") .and. FTemMotor())
Static aVetImp   := {}
Static lPccMR    := .F.
Static lIrfMR    := .F.
Static lInsMR    := .F.
Static lIssMR    := .F.
Static lCidMR    := .F.
Static lSestMR   := .F.
Static lOutImpMR := .F.
Static nVlrMR    := 0
Static lPccBxMR  := .F.
Static lIrfBxMR  := .F.
Static _lGrvMR   := .F.
Static _nImpMR   := 0

Static lRatDsd	 	:= NIL
Static __lInssPrev	:= NIL
Static __lPlOpeLt 	:= NIL

//-------------------------------------------------------------------
/*/{Protheus.doc}FINA050
Programa p/ manutenção Contas a Pagar

@author Wagner Xavier
@since  27/04/92
/*/
//-------------------------------------------------------------------
Function FINA050(aRotAuto, nOpcion, nOpcAuto, bExecuta, aDadosBco, lExibeLanc,;
					lOnline, aDadosCTB, aTitPrv, lMsBlQl, lPaMovBco, aVAAutP)

Local lPanelFin := IsPanelFin()
Local cKey1
Local cCondicao1
Local nIndex1
Local nPos
Local bBlock
Local nX
Local cParcela	:= Chr(Asc(GetMV("MV_1DUP"))-1)
Local nTamParc	:= TAMSX3("E2_PARCELA")[1]
Local aAreaAVG	:= {}
Local lDelPCC	:= .T.
Local lRAGPE	:= .F.
Local nPosEv		:=0 //posição do array do rateio multinaturezas
Local lContrRet := .T.
Local lFKG 		:= .F.
Local lFKF 		:= .F.
Local aFKFLoc	:= {}
Local aFKGLoc	:= {}
Local lRet		:= .T.
Local aTamSX3	:= {}

// Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
Local lF050BROW := ExistBlock("F050BROW")
Local lF050FILB := ExistBlock("F050FILB")
Local nPosMoed  := 0
Local lFnBtr    := FindFunction("ISSCPOM") .and. FindFunction("BtrISS") .and. FindFunction("BtrISSMun")

SaveInter() // Salva variaveis publicas

Private Valor5 := 0
Private Valor6 := 0
Private Valor7 := 0
PRIVATE cModRetPIS := GetNewPar( "MV_RT10925", "1" )
PRIVATE nIndexSE2 := ""
PRIVATE aDadosRef := Array(7)
PRIVATE aDadosRet := Array(7)
PRIVATE aDadosImp := Array(3)
PRIVATE cIndexSE2 := ""
Private cOldNaturez
PRIVATE lAlterNat := .F.
Private nRecnoNdf := 0
Private nDifPcc   := 0
Private nOldValorPg := 0
PRIVATE lAltValor := .F.
PRIVATE aAutoCab  := aRotAuto
PRIVATE aTrocaF3  := {}
Private aRatEvEz:= nil
Private cSE2TpDsd := ""  // variável utilizada pelo PMS
Private cTipoParaAbater := ""
PRIVATE cHistDsd	:= CRIAVAR("E2_HIST",.F.)  // Historico p/ Desdobramento
Private nValDig := 0 //armazena valor digitado na inclusão, para restaurar o E2_VALOR, caso ocorra mudança de moeda
PRIVATE lAltTxMoeda := .F.
PRIVATE nIrrfAnt	:= 0

__lExisFKD := TableInDic('FKD') .And. TableInDic('FKC')

If cPaisLoc $ "ARG|POR|EUA"
	Private cIndice
	Private cIndexArg
Endif

PRIVATE lIntegracao := IF(GetMV("MV_EASYFIN")=="S",.T.,.F.)
//Campo para alimentar o campo E2_EMIS1
PRIVATE dDataEmis1	:= dDataBase

// Restringe o uso do programa ao Financeiro,Sigaloja e Photo
If !(AmIIn(5,6,7,11,12,14,41,97,17,44,69,72))           // S¢ Fin,GPE, Vei, Loja , Ofi, Pecas e Esp, EIC, GCT
	Return
Endif

// Campos especificos e documentados para uso na MSMM disponivel no Quark e utilizados em clientes
// Nao retirar o FieldPos 
If SE2->(FieldPos("E2_CODOBS")) > 0
	Private aMemos := { { "E2_CODOBS" , "E2_OBS" } }
Endif

// Define Variaveis
PRIVATE nOldValor := 0
PRIVATE nOldSaldo := 0
PRIVATE nOldISS	:= 0
PRIVATE nOldBtrISS := 0
PRIVATE nOldIRR	:= 0
PRIVATE nOldInss  := 0
PRIVATE nOldSEST  := 0
PRIVATE nValorAnt := 0
PRIVATE nMaxParc  := 0
PRIVATE nOldPis	:= 0
PRIVATE nOldCofins:= 0
PRIVATE nOldCsll	:= 0
PRIVATE nOldCID   := 0
PRIVATE nVlRetPis	:= 0
PRIVATE nVlRetCof := 0
PRIVATE nVlRetCsl	:= 0

If Type("aColsSev") != "A" .Or. Type("aHeaderSev") != "A"
	PRIVATE aColsSev	:= {} // Utilizada em MultNat2 e GravaSev
	PRIVATE aHeaderSev	:= {} // Utilizada em MultNat2 e GravaSev
Endif

//Variavel para indicar se o fornecedor pessoa juridica deve utilizar a tabela progressiva de IRRF
PRIVATE lIRProg	:= "2"

PUBLIC N // para o mvc

lBtrISS := SE2->(ColumnPos("E2_BTRISS")) > 0 .and. SE2->(ColumnPos("E2_VRETBIS")) > 0 .and.;
						 SE2->(ColumnPos("E2_CODSERV")) > 0 .and. lFnBtr

// Trata o tamanho dos campos passados.
If ValType(aAutoCab) = "A"
	For nX := 1 to len(aAutoCab)
		If ValType(aAutoCab[nX]) = "A" .and. len(aAutoCab[nX]) > 1 .and. ValType(aAutoCab[nX, 1]) = "C"
			aTamSX3 := TamSX3(aAutoCab[nX, 1])
			If len(aTamSX3) > 2 .and. aTamSX3[3] = "C"
				aAutoCab[nX, 2] := PadR(aAutoCab[nX, 2], aTamSX3[1])
			Endif
		Endif
	Next nX
Endif

If FwIsInCallStack("FWMILEProA")
	//Verifica se veio como array os parametros vindos do mile, pois o mesmo envia somente array
	If ValType(nOpcion) == "A"
		If Len(nOpcion) > 0
			nOpcion := nOpcion[1]
		Else
			nOpcion := nil
		EndIf
	EndIf

	If ValType(nOpcAuto) == "A"
		If Len(nOpcAuto) > 0
			nOpcAuto := nOpcAuto[1]
		Else
			nOpcAuto := 3
		EndIf
	EndIf

	If ValType(bExecuta) == "A"
		If Len(bExecuta) > 0
			bExecuta := bExecuta[1]
		Else
			bExecuta := nil
		EndIf
	EndIf

	If ValType(lExibeLanc) == "A"
		If Len(lExibeLanc) > 0
			lExibeLanc := lExibeLanc[1]
		Else
			lExibeLanc := nil
		EndIf
	EndIf

	If ValType(lOnline) == "A"
		If Len(lOnline) > 0
			lOnline := lOnline[1]
		Else
			lOnline := nil
		EndIf
	EndIf

	If ValType(lMsBlQl) == "A"
		If Len(lMsBlQl) > 0
			lMsBlQl := lMsBlQl[1]
		Else
			lMsBlQl := nil
		EndIf
	EndIf

	If ValType(lPaMovBco) == "A"
		If Len(lPaMovBco) > 0
			lPaMovBco := lPaMovBco[1]
		Else
			lPaMovBco := nil
		EndIf
	EndIf
EndIf

aFill(aDadosRef,0)
aFill(aDadosRet,0)
aFill(aDadosImp,0)

If cPaisLoc == 'ARG'
	nMaxParc := SuperGetMV("MV_LIMCUOT",.T.,0)
Else
	If nTamParc == 1  // TAMANHO DA PARCELA
		For nX := 1 To 63
			cParcela:=Soma1( cParcela,, .F.,.T. )
			If cParcela == "000000" .or. cParcela == "*"
				Exit
			Endif
			nMaxParc++
		Next
	Else
		Do Case
			Case nTamParc == 2
				nMaxParc := 99
			Case nTamParc == 3
				nMaxParc := 999
			OtherWise
				nMaxParc := 9999
		EndCase
	Endif
EndIf

// Cria indice condicional para a Localizacao Argentina.
If cPaisLoc $ "ARG|POR|EUA" .And. nOpcion # Nil
	if nOpcion==1
		cCondicao1	:=	"Alltrim(E2_TIPO)=='CH' .OR. Alltrim(E2_TIPO)=='TF'"
	Else
		cCondicao1	:=	"!(Alltrim(E2_TIPO)=='CH' .OR. Alltrim(E2_TIPO)=='TF')"
	Endif

	cIndexArg 	:= CriaTrab(Nil,.F.)
	cKey1			:=	"E2_FILIAL+E2_FORNECE+E2_LOJA"
	IndRegua("SE2",cIndexArg,cKey1,,cCondicao1,OemToAnsi(STR0079))  //"Un Momento por favor..."
	cIndice:='Proveedor+Sucursal'
	nIndex1 	:= RetIndex("SE2")
	dbSelectArea("SE2")

	dbSetOrder(nIndex1+1)
	dbGoTop()
Endif

Private aRotina := MenuDef(nOpcion)
Private lF050Auto := ( aRotAuto <> NIL )

If lF050Auto
	nPosEv:=AScan(aAutocab,{|x|AllTrim(x[1])=="AUTRATEEV"})
	If nPosEv>0
		aRatEvEz:=aClone(aAutoCab[nPosEv][2])
	Endif
	nPosEv:=AScan(aAutocab,{|x|AllTrim(x[1])=="AUTCMTIT"})
	If nPosEv>0
		aFKFLoc:=aClone(aAutoCab[nPosEv][2])
		lFKF := .T.
	Endif
	nPosEv:=AScan(aAutocab,{|x|AllTrim(x[1])=="AUTCMIMP"})
	If nPosEv>0
		aFKGLoc:=aClone(aAutoCab[nPosEv][2])
		lFKG := .T.
	Endif

	// Valores acessórios - rotina automatica CP
	If (aVAAutP <> Nil )
		aVAAuto := aClone(aVAAutP)
	Endif
Endif

// Carrega funcao Pergunte
If !lF050Auto
	SetKey (VK_F12,{|a,b| AcessaPerg("FIN050",.T.)})
Endif

pergunte("FIN050",.F.)

IF lF050Auto .And. lF50PERGUNT
	ExecBlock("F50PERGUNT", .F., .F.)
EndIf

//Tratamento para evitar conflito do pergunte FIN050
//com o TMA250 ao gerar contrato de carreteiro - TMS
If lExibeLanc <> NIL .And. ValType(lExibeLanc) == "L"
	mv_par01 := Iif(lExibeLanc,1,2) //Exibe Lancamentos Contabeis
EndIf

//Tratamento para evitar conflito do pergunte FIN050
//com o TMA250 ao gerar contrato de carreteiro - TMS
If lOnline <> NIL .And. ValType(lOnline) == "L"
	mv_par04 := Iif(lOnline,1,2) //Contabiliza On-Line
EndIf

// Define o cabecalho da tela de atualizacoes
PRIVATE cCadastro 	:= OemToAnsi(STR0007) // "Contas a Pagar"
PRIVATE cBancoAdt	:= CriaVar("A6_COD")
PRIVATE cAgenciaAdt	:= CriaVar("A6_AGENCIA")
PRIVATE cNumCon	 	:= CriaVar("A6_NUMCON")
PRIVATE nMoedAdt	:= CriaVar("A6_MOEDA")
PRIVATE cChequeAdt	:= CriaVar("EF_NUM")
PRIVATE cHistor		:= CriaVar("EF_HIST")
PRIVATE cBenef		:= CriaVar("EF_BENEF")
PRIVATE lAltera		:= .F.
PRIVATE nMoeda 		:= Int(Val(GetMv("MV_MCUSTO")))
If Type("lWserver") == "U"
	PRIVATE cMarca 		:= GetMark( )
EndIf
PRIVATE aTELA[0][0]
PRIVATE aGETS[0], cPictHist
PRIVATE lVerifyBlq
PRIVATE cLote
PRIVATE nQtdTot		:= 0		//Utilizado no Rateio Externo do SIGACTB.
PRIVATE aItensCTB    := Iif(aDadosCTB <> Nil, aDadosCTB, {})
PRIVATE aItnTitPrv   := Iif(aTitPrv   <> Nil, aTitPrv  , {})
DEFAULT aDadosBco    	:= {}
DEFAULT lMsBlQl      	:= .T.
DEFAULT lPaMovBco		:= .T.

lVerifyBlq := lMsBlQl

If !lPaMovBco
	mv_par05 := 2 //-- Gera Chq. para Adiantamento == Nao
	mv_par09 := 2  //-- Somente gera movimento apos geracao do cheque

ElseIf nModulo == 43 .And. Len(aDadosBco) > 0

	cBancoAdt	:= aDadosBco[1]
	cAgenciaAdt	:= aDadosBco[2]
	cNumCon	 	:= aDadosBco[3]
	cChequeAdt	:= aDadosBco[4]

	mv_par05    := 1 //-- Gera Chq. para Adiantamento == Sim

	If Len(aDadosBco) > 6
		If aDadosBco[7]   //-- Mov. Bancario sem Cheque
			mv_par09 := 1  //-- Gera movimento sem cheque
			mv_par05 := 2 //-- Gera Chq. para Adiantamento == Nao
		Else
			mv_par05 := 2 //-- Gera Chq. para Adiantamento == Nao
			mv_par09 := 2  //-- Somente gera movimento apos geracao do cheque
		EndIf
	Else
		mv_par09 := 1
	EndIf

EndIf

If lF050Auto
	If (nPosMoed := AScan(aAutocab, {|x|AllTrim(x[1]) == "E2_MOEDA"})) > 0 .And. !Empty(aAutocab[nPosMoed, 2])
		nMoeda := If(ValType(aAutocab[nPosMoed, 2]) == "N", aAutocab[nPosMoed, 2], Val(aAutocab[nPosMoed, 2]))
	EndIf

	aValidGet := {}
	IF (nT := ascan(aRotAuto,{|x| x[1]='E2_TIPO'}) ) > 0
		IF aRotAuto[nT,2] $ MVPAGANT   // Se for PA
			IF (nT := ascan(aRotAuto,{|x| x[1]='AUTBANCO'})) > 0
				Aadd(aValidGet,{'cBancoAdt' ,PAD(aRotAuto[nT,2],TamSx3("E5_BANCO")[1]),"CarregaSa6(@cBancoAdt,,,.T.)",.t.})
			Endif
			IF (nT := ascan(aRotAuto,{|x| x[1]='AUTAGENCIA'}) ) > 0
				Aadd(aValidGet,{'cAgenciaAdt' ,PAD(aRotAuto[nT,2],TamSx3("E5_AGENCIA")[1]),"CarregaSa6(@cBancoAdt,@cAgenciaAdt,,.T.)",.t.})
			EndIf
			IF (nT := ascan(aRotAuto,{|x| x[1]='AUTCONTA'}) ) > 0
				Aadd(aValidGet,{'cNumCon' ,PAD(aRotAuto[nT,2],TamSx3("E5_CONTA")[1]),"CarregaSa6(@cBancoAdt,@cAgenciaAdt,@cNumCon,.F.,,.T.)",.t.})
			EndIf

			If FXMultSld()
				If ( nT := aScan( aRotAuto, { |x| x[1] = 'AUTMOED' } ) ) > 0
					aAdd( aValidGet, { 'nMoedAdt', Pad( aRotAuto[nT,2], TamSx3("A6_MOEDA")[1]),"CarregaSa6(@cBancoAdt,@cAgenciaAdt,@cNumCon,.F.,,.T.,, @nMoedAdt )",.t.})
				EndIf
			EndIf

			IF (nT := ascan(aRotAuto,{|x| x[1]='AUTCHEQUE'}) ) > 0
				If mv_par05 == 1 .And. substr(cBancoAdt,1,2)!="CX" .And. !(cBancoAdt$GEtMV("MV_CARTEIR"))
					Aadd(aValidGet,{'cChequeAdt' ,aRotAuto[nT,2],"fa050Cheque(cBancoAdt,cAgenciaAdt,cNumCon,cChequeAdt,Iif(cPaisLoc $ 'ARG|MEX',.F.,.T.))",.t.})
				Endif
			EndIf
			If ! SE2->(MsVldGAuto(aValidGet)) // consiste os gets
				lRet:= .F.
			EndIf
		Else
			If cPaisLoc=="BRA" .and. (lFKF .or. lFKG) .and. lRet
				nOpcAuto := If(nOpcAuto <> nil, nOpcAuto, 3)
				lRet:= F986ExAut("SE2", aFKFLoc, aFKGLoc, nOpcAuto)
			Endif
		Endif
	Endif

	//Alimentacao da variavel de data de contabilizacao (E2_EMIS1). O modulo de GPE pode gravar o campo E2_EMISSAO atraves
	//da rotina GPEM670 com data futura. Com isso o campo E2_EMIS1 fica inconsistente pois fica com a data base do
	//processamento, que eh inferior ao determinado no campo de emissao. Isso faz com que em rotinas como o FINR550 sejam
	//listados titulos em intervalos erroneos, por exemplo, um titulo com emissao no mes de dezembro saindo no intervalo
	//do mes de novembro.
	If lRet
		If (nT := aScan(aRotAuto,{|x| x[1] == "E2_ORIGEM"})) > 0
			If Substr(Upper(aRotAuto[nT][2]),1,3) $ "GPE/APT"
				lRAGPE := .T.
			Endif
		Endif
		If !lRAGPE
			lRAGPE := IIf(Upper(ProcName(1)) $ "GPE/APT",.T.,.F.)
		Endif
		If lRAGPE
			If (nT := aScan(aRotAuto,{|x| x[1] == "E2_EMISSAO"})) > 0
				If ValType(aRotAuto[nT][2]) == "D" .AND. !Empty(aRotAuto[nT][2])
					If aRotAuto[nT][2] > dDataBase
						dDataEmis1 := aRotAuto[nT][2]
					Endif
				Endif
			Endif
		Endif
	Endif
Endif
If lRet

	LoteCont( "FIN" )

	//Selecionar ordem 1 para Cadastro de Fornecedores
	SA2->(dbSetOrder(1))

	// Ponto de entrada para pre-validar os dados a serem  exibidos.
	IF lF050BROW
		ExecBlock("F050BROW",.f.,.f.)
	Endif

	// A funcao SomaAbat reabre o SE2 com outro nome pela ChkFile, pois o filtro do SE2, desconsidera os abatimentos							|
	SomaAbat("","","","P")

	//Inicializo variaveis para rateio
	Debito  	:= ""
	Credito 	:= ""
	CustoD		:= ""
	CustoC		:= ""
	ItemD 		:= ""
	ItemC 		:= ""
	CLVLD		:= ""
	CLVLC		:= ""
	Conta		:= ""
	Custo 		:= ""
	Historico 	:= ""
	ITEM		:= ""
	CLVL		:= ""

	Afill(aDadosRet,0)
Endif

If lF050Auto .and. lRet
	Default nOpcAuto := 3
	MBrowseAuto(nOpcAuto,aAutoCab,"SE2")
Else
	If nOpcAuto<>Nil
		Do Case
			Case nOpcAuto == 3
				INCLUI := .T.
				ALTERA := .F.
			Case nOpcAuto == 4
				INCLUI := .F.
				ALTERA := .T.
			OtherWise
				INCLUI := .F.
				ALTERA := .F.
		EndCase
		// Chamada direta da funcao de Inclusao/Alteracao/Visualizacao/Exclusao
		If lPanelFin  //Chamado pelo Painel Financeiro
			nPos := nOpcAuto
		Else
			nPos := Ascan(aRotina,{|x| x[4]== nOpcAuto})
		Endif

		// Nao encontrou a opcao, verifica se eh Visualizacao do rateio
		If nOpcAuto == 8 // Visualizacao do rateio
			nPos := Ascan(aRotina,{|x| x[2]== "FA050Rateio" })
		Endif
		If ( nPos # 0 )
			bBlock := &( "{ |x,y,z,k| " + aRotina[ nPos,2 ] + "(x,y,z,k) }" )
			dbSelectArea("SE2")
			Eval( bBlock,Alias(),SE2->(Recno()),nPos)
		EndIf
	Else
		// Endereca a funcao de BROWSE
		IF bExecuta = NIL// AWR - AVERAGE - 11/08/2003
			mBrowse( 6, 1,22,75,"SE2",,,,,, Fa040Legenda("SE2"),,,,,,,,IIF(lF050FILB,ExecBlock("F050FILB",.f.,.f.),NIL))
		ELSE
			aAreaAVG := GetArea()
			dbSelectArea("SE2")
			EVAL(bExecuta)// AWR - AVERAGE - 11/08/2003
			RestArea(aAreaAVG)
		ENDIF
	EndIf
EndIf
// Recupera a Integridade dos dados
Custo   := ""
Valor   := 0
Debito  := ""
Credito := ""
ItemD	:= ""
ItemC   := ""
aVAAuto := Nil

Set Key VK_F12 To
RestInter() // Restaura variaveis publicas

Return

//-------------------------------------------------------------------
/*/{Protheus.doc}FA050Inclu
Programa p/ ìnclusão de Contas a Pagar
para empresas publicas.
@author Wagner Xavier
/*/
//-------------------------------------------------------------------
Function FA050Inclu(cAlias,nReg,nOpc,cRec1,cRec2,lSubst)

Local lRet := .T.
Local lPanelFin := IsPanelFin()
LOCAL nOpca	:= 0
LOCAL lPodeInc:=.t.
Local cTudoOK
Local aBut050
Local cArq
Local lContrRet := .T.
Local nIndexAtu := SE2->(IndexOrd())
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
// Controla IRPF na Baixa
Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)

Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"

Local aAreaSubs := {}
// Utilizado na AxInclui (Deve ter 4 linhas)
// aParam[1] = Funcao executada antes da interface
// aParam[2] = Funcao executada ao confirmar (TudoOk)
// aParam[3] = Funcao executada dentro da transacao (AxInclui)
// aParam[4] = Funcao executada apos a transacao
Local aParam := {{|| .T. }, ;
				 {|| lF050Auto .Or. If(MV_MULNATP .And. M->E2_MULTNAT == "1", MultNat2("SE2",3,If(mv_par06==1,M->(If(lIRPFBaixa .And. M->E2_TIPO<>'PA ',0,E2_IRRF)+If(!lCalcIssBx,M->E2_ISS,0)+M->E2_RETENC+M->E2_SEST+IIF(lPccBaixa,0,M->E2_PIS+M->E2_COFINS+M->E2_CSLL))+;
								Iif(lInssBx,0,M->E2_INSS),0),(mv_par10==2 .And. mv_par06==2)),.T.) },;
				 {|| .T. },;
				 {|| .T. }} // Utilizado na AxInclui

Local aDim 		:= {}
Local aTituloCC := {}
Local lF050CAN	:= ExistBlock( "F050CAN" )
Local lF050INC  := ExistBlock("FA050INC")
Local lF050ADPC := ExistBlock( "F050ADPC" )
Local lRatPrj	:= .T. //indica se existe rateio de projetos
Local nPosAFR	:= 0 //indica se existe rateio de projetos na autocab de titulos
Local aEaiRet   := {}

DEFAULT lSubst	:= .F.

PRIVATE aHeader	:={}
PRIVATE nUsado 	:= 0
PRIVATE cCarteira := "P"
PRIVATE cHistDsd	:= CRIAVAR("E2_HIST",.F.)  // Historico p/ Desdobramento
PRIVATE aParcelas	:= {}  // Array para desdobramento
PRIVATE aParcacre  := {}
PRIVATE aParcDecre := {}
PRIVATE aRatAFR		:= {}
PRIVATE aAutoAfr		:={}//array automatico de rateio de projetos
PRIVATE bPMSDlgFI
PRIVATE cModRetPIS := GetNewPar( "MV_RT10925", "1" )
PRIVATE nIndexSE2 := ""
PRIVATE cIndexSE2 := ""
PRIVATE cTitPaiAB := RTrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
Private cOldNaturez
PRIVATE nVlRetIrf:= 0
Private nVCalIRF := 0
Private nBCalIRF := 0
Private nCslCalc		:= 0
Private nCslBaseC		:= 0
Private nPisCalc		:= 0
Private nPisBaseC		:= 0
Private nCofCalc		:= 0
Private nCofBaseC		:= 0
Private nVCalINS := 0
Private nBCalINS := 0
Private aDadosIr := {0,{},{}}
Private nSaveSx8Len := GetSx8Len()
Private cSeqCv4		:= ""
PRIVATE _Opc 		:= nOpc
Private aSE2FI2		:=	{} // Utilizada para gravacao das justificativas
Private aCposAlter  :=  {}
Private dVencReaAnt	:= cTod('')	// Utilizado para avaliar alteração no vencimento real
Private nBaseIns	:= 0 //Inss Baixa
Private nVretInss	:= 0
Private aRecnoINSS:= {}
Private aBordINSS	:=	{}
Private cPretIns	:= ""
Private nInss		:= 0

If nOpc == 3 // inclusao
	nSaveSx8 := GetSX8Len()
	cSeqCv4 := GetSxENum("CV4", "CV4_SEQUEN")
	WHILE .T.
		IF CV4->(!DbSeek(xFilial("CV4")+cSeqCv4))
			WHILE (GetSx8Len() > nSaveSx8)
				ConfirmSX8()
			END
			EXIT
		ENDIF
		cSeqCv4 := GetSXENum("CV4", "CV4_SEQUEN")
	ENDDO
EndIf

If (!Type("lF050Auto") == "L" .Or. !lF050Auto)
	lRatDes := .F.
EndIf

//Integracao com SIGAPMS
If IntePms()
	If lSubst
		aAreaSubs := GetArea()
		PmsDlgFS(4,"","","",,"","",.F.) // Carrega os valores no array sem chamar a GetDados
		bPMSDlgFI	:= {||PmsDlgFS(4,M->E2_PREFIXO,M->E2_NUM,M->E2_PARCELA,M->E2_TIPO,M->E2_FORNECE,M->E2_LOJA)}
		RestArea(aAreaSubs)
	Else
		bPMSDlgFI	:= {||PmsDlgFI(3,M->E2_PREFIXO,M->E2_NUM,M->E2_PARCELA,M->E2_TIPO,M->E2_FORNECE,M->E2_LOJA)}
	EndIf

	// integração com o PMS
	If IntePMS() .And. (!Type("lF050Auto") == "L" .Or. !lF050Auto)
		SetKey(VK_F10, {|| Eval(bPMSDlgFI)})
	EndIf
Endif

nOldValor 	:= 0
nOldSaldo 	:= 0
nOldISS		:= 0
nOldBtrISS	:= 0
nOldIRR		:= 0
nOldInss	:= 0
nOldSEST	:= 0
nOldAcre    := 0
nOldDecre   := 0
nOldPis		:= 0
nOldCofins	:= 0
nOldCsll	:= 0

If !lF050Auto
	nVlRetPis := 0
	nVlRetCof := 0
	nVlRetCsl := 0
	aDadosRet := Array(5)
	Afill(aDadosRet,0)
Endif

lIntegracao := IF(GetMV("MV_EASYFIN")=="S",.T.,.F.)

//Botoes adicionais na EnchoiceBar
aBut050 := fa050BAR("IntePms()")

If cPaisLoc=="BRA" .and. lContrRet .and. !lPccBaixa
	Aadd(aBut050,{"NOTE",{||F050CalcRt()},STR0125,STR0126})  //"Modalidade de Retenção Pis/Cofins/Csll"###"Impostos"
EndIf

//Motor de retenções
If lTemMR
	Aadd(aBut050,{"NOTE",{||F050MRET()},STR0301,STR0301})  //"'Retenção de Impostos'
EndIf

dbSelectArea( cAlias )
dbSetOrder(1)

lAltera:=.F.
IF lFA050UPD
	// Ponto de Entrada para Pre-Validacao de Inclusao
	lPodeInc := ExecBlock("FA050UPD",.f.,.f.)
Endif
cCadastro := OemToAnsi(STR0007) // "Contas a Pagar"
If !lF050Auto
	cTudoOk := 'Iif(M->E2_TIPO$MVPAGANT,DtMovFin(m->E2_EMISSAO).and.F050VldPa().and.fa050Num(),fa050Num() .And. (M->E2_RATEIO=="N" .Or. FA050TudCT('+Str(nOpc,2)+',"511","FINA050"'+'))).And.PcoVldLan("000002",IIF(M->E2_TIPO$MVPAGANT,"02","01"),"FINA050")'
	cTudoOk += ' .And. IIF(Len(aSE2FI2)==0,Fa050JUST(),.T.)'
	cTudoOk += ' .And. If(M->E2_TEMDOCS == "1",CN062NecDocs(),.T.) ' //Documentos
	cTudoOk += ' .And. F050VldApr()'
Else
	cTudoOk := 'Iif(M->E2_TIPO$MVPAGANT,DtMovFin(m->E2_EMISSAO),fa050Num()).and. Fa050Moed()'
	cTudoOk += '.and. IIF(M->E2_DESDOBR=="S",F050DSDOBR(),.T.)'
	cTudoOk += '.and. IIF(M->E2_RATEIO=="S",(F050EscRat("511","FINA050",cLote),.T.),.T.).And.PcoVldLan("000002",IIF(M->E2_TIPO$MVPAGANT,"02","01"),"FINA050")'
	If  IntePMS() .and. (nPosAFR:=AScan(aAutocab,{|x|AllTrim(x[1])=="AUTRATAFR"})) >0 //rateio automatico de projetos
		aAutoAFR:=aClone(aAutoCab[nPosAFR][2])
		cTudoOk+=' .and. F050AutAFR('+Str(nOpc,2)+') '
	Endif
Endif
IF lF050INC
	cTudoOK += ' .AND. ExecBlock("FA050INC",.f.,.f.)'
Endif

IF lF050ADPC .and. FunName() = "MATA121"
	cTudoOK += ' .AND. ExecBlock("F050ADPC",.f.,.f.,{aValores})'
Endif

If Type("cValidaOK") = "C" .AND. !EMPTY(cValidaOK)// Usado caso a bExecuta # NIL
	cTudoOK += cValidaOK		// AWR - AVERAGE - 11/08/2003
Endif

cTudoOK += '.And. FA050VLMV()'
cTudoOK += '.And. F050BtrISS()'

// Em caso de abatimento (AB-) precisamos validar se existe titulo no banco, para gerar o AB- correspondente
// FA050Tipo - Enviado .T. como padrão pois esse momento se trata da uma inclusão do Tipo AB- aonde o mesmo não deve herdar algumas informações do titulo Pai
cTudoOK += '.And. Iif(M->E2_TIPO $ MVABATIM, FA050Tipo(.T.) .And. fa050valor(), .T.)'

// se for adiantamento, valida se o fornecedor e loja escolhido estao conforme pedido/documento
If !lF050Auto
	If Type("aRecnoAdt") != "U" .and. (FunName() = "MATA121" .or. FunName() = "MATA103")
		cTudoOk += ' .And. F050VlAdFoLj()'
	Endif
Endif

cTudoOk += ' .AND. F50VldBCOF() '

//Validação de caracteres especiais
cTudoOk += ' .And. F050VlCpos()'
cTudoOK += ' .And. F050VldVlr() '

If FindFunction("JurValidCP") .And. lIntPFS
	cTudoOK += ' .And. JurValidCP(3) '
EndIf

//³ Verifica se data do movimento n„o ‚ menor que data limite de ³
//³ movimentacao no financeiro    								 ³
If !DtMovFin(,,"1")
	Return
Endif

Begin Transaction

	//³ Inicializa a gravacao dos lancamentos do SIGAPCO          ³
	PcoIniLan("000002")

	If ( lF050Auto )

		RegToMemory("SE2",.T.,.F.)
		If MV_MULNATP
			FINXTMP()
		EndIF

		If EnchAuto(cAlias,aAutoCab,cTudoOk,nOpc)
			If FwIsInCallStack("GeraParcSe2")	//Desdobramento
				FA050Nat2()
			Endif

			nOpca := AxIncluiAuto(cAlias,cTudoOk,"FA050AXINC('"+cAlias+"')" )
		Else
			lRet := .F.
		EndIf
	ElseIf lPodeInc
		nValDig := 0 //zera a variável para não trazer o vlr preenchido, após uma alteração.

		If lPanelFin  //Chamado pelo Painel Financeiro
			dbSelectArea("SE2")
			RegToMemory("SE2",.T.,,.F.,FunName())
			oPanelDados := FinWindow:GetVisPanel()
			oPanelDados:FreeChildren()
			aDim := DLGinPANEL(oPanelDados)
			nOpca := AxInclui(cAlias,nReg,nOpc,, "FA050INIS",,cTudoOk,,"FA050AXINC('"+cAlias+"')",aBut050,aParam,/*aAuto*/,/*lVirtual*/,/*lMaximized*/,/*cTela*/,.T.,oPanelDados,aDim,FinWindow)

			//Controle de Cartão de Credito para o Equador...
			If nOpca == 1 .and. cPaisLoc == "EQU" .and. SE2->E2_TIPO == "CC " .and. ProcName(1) <> "FA050TIT2CC"
				//Executar dialogo para obter os dados do Cartão de Crédito e gravar arquivo de controle FRC
				aTituloCC := Fa050GetCC(.T.)
				If Len(aTituloCC) > 0
					Fa050GrvFRC(aTituloCC)
				EndIf
			EndIf
		Else
			RegToMemory("SE2",.T.,,.F.,FunName())
			nOpca := AxInclui(cAlias,nReg,nOpc,, "FA050INIS", ,cTudoOk,,"FA050AXINC('"+cAlias+"')",aBut050,aParam,/*aAuto*/,/*lVirtual*/,/*lMaximized*/,/*cTela*/,/*lPanelFin*/,/*oFather*/,/*aDim*/,/*uArea*/,/*lFlat*/,lSubst)

			//Controle de Cartão de Credito para o Equador...
			If nOpca == 1 .and. cPaisLoc == "EQU" .and. SE2->E2_TIPO == "CC " .and. ProcName(1) <> "FA050TIT2CC"
				//Executar dialogo para obter os dados do Cartão de Crédito e gravar arquivo de controle FRC
				aTituloCC := Fa050GetCC(.T.)
				If Len(aTituloCC) > 0
					Fa050GrvFRC(aTituloCC)
				EndIf
			EndIf
			If nOpca <> 1
				Do While ( GetSx8Len() > nSaveSx8Len )
					RollBackSX8()
				EndDo
			EndIf

			//Limpas as varivaéis para ser carregada na próxima inclusão.
			If !Empty(cBancoAdt)
				cBancoAdt := space(len(cBancoAdt))
				cAgenciaAdt := space(len(cAgenciaAdt))
				cChequeAdt := space(len(cChequeAdt))
				cHistor := space(len(cHistor))
				cBenef := space(len(cBenef))
				cNumCon := space(len(cNumCon))
			EndIf
		EndIf

		// Motor de retenção
		// Restaura variáveis static
		lPccMR := .F.
		lIrfMR := .F.
		lInsMR := .F.
		lIssMR := .F.
		lCidMR := .F.
		lSestMR := .F.
		lOutImpMR := .F.
		aVetImp := {}
		nVlrMR := 0
		lPccBxMR := .F.
		lIrfBxMR := .F.
		_lGrvMR := .F.
		nValDig := 0 //zera a variável para não trazer o vlr preenchido na próxima inclusão.
	EndIf

	If nOpca <> 1
		lRet := .F.
	EndIf

	// Integração protheus X tin.
	If lRet .and. __lFWHasEAI
		lRatPrj := PmsRatPrj("SE2",,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
		If !( AllTrim(SE2->E2_TIPO) $ MVPAGANT .and. lRatPrj  .and. !(cPaisLoc $ "BRA|")) //nao integra PA  para Totvs Obras e Projetos Localizado
			aEaiRet := FWIntegDef('FINA050',,,, 'FINA050')
			If !aEaiRet[1]
				Help(" ", 1, "HELP", STR0315, STR0316 + CRLF + aEAIRET[2], 3, 1)  // "Erro EAI" / "Problemas na integração EAI. Transação não executada."
				lRet := .F.
				nOpcA := 2
			Endif
		Endif
	Endif

	// grava array para uso na rotina de adiantamento do pedido de compra/documento de entrada
	If nOpcA = 1 .and. Type("aRecnoAdt") != "U" .and. (FunName() = "MATA121" .or. FunName() = "MATA103")
		aAdd(aRecnoAdt,{SE2->(RECNO()),SE2->E2_VALOR})
	Endif

	// Finaliza a gravacao dos lancamentos do SIGAPCO
	If nOldValor != M->E2_VALOR .or. lF050Auto
		PcoFinLan("000002")
	Endif

	// Executa ponto de entrada para permitir customizar regra ao  cancelar a inclusao do titulo
	If lF050CAN .And. nOpca <> 1
		ExecBlock( "F050CAN", .F., .F. )
	EndIf

	// Verifica o arquivo de rateio, e apaga o arquivo temporario para que no proximo rateio seja criado novamente
	If cPaisLoc == 'BRA' .And. !lRatDes
		If Select("TMP") > 0
			DbSelectArea( "TMP" )
			DbCloseArea()
		Endif
		If(_oFINA0501 <> NIL)
			_oFINA0501:Delete()
			_oFINA0501 := NIL
		EndIf
	EndIf

	If (!lRet .and. lF050Auto .And. lMsErroAuto)  .or.; // se for rotina auto e esta retornou falso, faz o disarm 
		( !lF050Auto .and. !lRet .and. nOpcA = 1)   	// não é rotina automatica, deu falso qdo confirmou	
		DisarmTransaction()
	EndIf

End Transaction

nIndexSE2 := ""
aDadosRet := Array(5)
cIndexSE2 := ""

If IntePMS() .And. (!Type("lF050Auto") == "L" .Or. !lF050Auto)
	SetKey(VK_F10, Nil)
EndIf
If cPaisLoc=="BRA"
	F986LimpaVar() //Limpa as variaveis estaticas - Complemento de Titulo
EndIf

SE2->(dbSetOrder(nIndexAtu))

If MV_MULNATP .and. select("SEZTMP") >  0
	FINXDETMP()
EndIF

If lF050Auto .And. lMsErroAuto
	AutoGrLog(STR0312)
EndIf

Return nOpca

//-------------------------------------------------------------------
/*/{Protheus.doc}FA050Delet
Programa p/ exclusão Contas a Pagar
para empresas publicas.
@author Wagner Xavier
@since  27/04/92
/*/
//-------------------------------------------------------------------
Function FA050Delet(cAlias,nReg,nOpc)
Local lPanelFin := IsPanelFin()
LOCAL nOpcA		:= 0
LOCAL nSavRec
LOCAL lTemCheq 	:= .f.
LOCAL nRecSef	:= 0
LOCAL cPrefixo
LOCAL cNum
LOCAL cParcela
LOCAL cTipo
LOCAL cFornece
LOCAL cLoja
LOCAL cNatureza
LOCAL lPadrao := .F.
LOCAL cPadrao
LOCAL cArquivo
LOCAL nTotal	:= 0
LOCAL nHdlPrv	:= 0
LOCAL cParcIr
LOCAL cParcIss
LOCAL cArq
LOCAL nIndex 	:= IndexOrd()
Local lOk := .T.    // Retorno do ExecBlock( FA050Del )
LOCAL nOrdSE2
Local nMoedSE2 := SE2->E2_MOEDA
Local cTipoSE2 := SE2->E2_TIPO
Local lHead := .F.
Local lDesdobr := .F.
Local nValSaldo := 0
LOCAL oDlg
LOCAL i
LOCAL nOrd
Local lDistrato := .F. //Variavel usada pelo Template GEM
Local aBut050
Local cSEST  := GetMv("MV_SEST",,"")
Local cCIDE  := GetMv("MV_CIDE",,"")
Local nRegAtu:= 0
Local nProxReg := SE2->(Recno())
Local nPis		:= 0
Local nCofins	:= 0
Local nCsll		:= 0
Local cParcPis
Local cParcCof
Local cParcCsll
Local nVretPis := 0
Local nVretCof := 0
Local nVretCsl := 0
Local nRecnoFJA  := 0
Local nX := 0
Local aRecSE3  := {}
Local aTitImp  := {}
Local aArea:={}
Local aAreaSE5:={}
Local lGPEExcTit	:= GetMV( "MV_GPEEXTT", , .T. )	// Define se podera excluir titulo gerado pelo SIGAGPE no SIGAFIN

Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local lContrRet := .T.
Local lIRPFBaixa := .F.
Local cChaveCV4
Local lRateioPCO
Local cPadMon	 := "59B" //Contabilizacao do estorno da varia monetaria
Local lRetVM	 := .T.
Local aDiario	 := {}

Local lDelTit  := .T.
Local lSetAuto := .F.
Local lSetHelp := .F.
//Verifica se os campos utilizados para o imposto CIDE.
Local lCIDE  := cPaisLoc == "BRA"
Local lFina379 := FwIsInCallStack("FINA379")
Local nOrdem := RetOrdTab("SE3","E3_FILIAL+E3_PROCCOM")
Local cBusca := ""

Local lTitPai := .T.
Local cTitPai := Alltrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
Local aTpImp  := {}
Local lDelGPE := .F.

Local aFlagCTB := {}
Local lUsaFlag	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
Local lRastro	 := FVerRstFin()
Local lAchou:=.F.
Local lComisExc := ExistBlock("F050DSE3") // CRIADO PARA ATENDER A FNC: 00000023608/2009
Local aExcSE3 := {CtoD(""),""}               // CRIADO PARA ATENDER A FNC: 00000023608/2009

Local lNRastDSD := SuperGetMV("MV_NRASDSD",.T.,.F.)
Local lAtuSldNat := .T.

//Exclusao chamada a partir do cancelamento de desdobramento
Local lFina250		:= FwIsInCallStack("FACANDSD")
Local lFina590		:= FwIsInCallStack("FINA590")
Local cQryVend := ""
Local lViaAFR   := .T.
Local lViaINT   := .F.

Local lEstProv := .F.   //Variavel para estornar título provisório
Local lRatPrj	:=.T. //indica se existe rateio de projetos
Local lInssBX :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
Local nMinINS1 := SuperGetMv("MV_MININSS",.F.,0)
Local nLimInss 	:= GetMv("MV_LIMINSS",.F.,0)
Local nMinINS2 := SuperGetMv("MV_VLRETIN",.F.,0)
Local lInsPub :=	SuperGetMv("MV_INSPUB",,.F.) .And. nMinINS1 == 0 .And.;
nLimInss == 0 .And. nMinINS2 == 0 //Inss Baixa com empresa publica. Neste caso os valores do inss não tem valor minimo ou maximo de retencao.
Local aAreaSE2  := {}
//³ A fun‡„o SomaAbat reabre o SE2 com outro nome pela ChkFile, pois ³
//³ o filtro do SE2, desconsidera os abatimentos							|
Local cQryFor	:= ""
Local cAliasFor := ""
Local cUltima	:= ""
Local lTop	:= .t.
Local lFindTemp := FindFunction("T_AE_EXCSE2")
Local lPass		:= IsInCallStack("T_AE_ExcSe2")

Local lCpRet	:= .F.
Local lExistFJU := FJU->(ColumnPos("FJU_RECPAI")) >0 .and. FindFunction("FinGrvEx")
Local aAreaSA2  :={}
Local aChave	:= {}
Local aPenCont	:= {}
LOCAL lDigita	:= .F.
Local cParcINP		:= " "
Local nValINSSPatr	:= 0
Local lGetParcINP		:= FindFunction("GetParcINP")
Local nRecnoSE2 := 0
Local lF050DEL1 := ExistBlock("F050DEL1")
Local lFA050Del := ExistBlock("FA050Del")
Local lFA050B01 := ExistBlock("FA050B01")
Local lFA050RAT := ExistBlock("FA050RAT")
Local lRetQry := .T.
LOCAL lAtuForn   := SuperGetMv("MV_ATUFORN",.F.,.T.)
Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local aEaiRet    := {}
Local aAreaAnt
Local cChaveTit := ""
Local cChaveFK7 := ""
Local cLog := ""
Local oModel := NIL
Local oSubFKA := NIL
Local lRet := .F.
Local cNatImp := ""
Local cTipImp := ""
Local lImpOld := .F.
LOCAL lIntGTP	:= SuperGetMV("MV_INTGTP",.F.,"0") == "1"

SomaAbat("","","","P")

nSavRec	  := RecNo()
cPrefixo  := E2_PREFIXO
cNum	  := E2_NUM
cParcela  := E2_PARCELA
cTipo 	  := E2_TIPO
cFornece  := E2_FORNECE
cLoja	  := E2_LOJA
cNatureza := E2_NATUREZ
cParcIr	  := E2_PARCIR
cParcIss  := E2_PARCISS
cParcInss := E2_PARCINS
cParcSEST := E2_PARCSES
nIss	  := SE2->E2_ISS
nInss	  := SE2->E2_INSS
nSEST	  := E2_SEST
If lCIDE
	cParcCIDE := SE2->E2_PARCCID
	nCIDE	  := SE2->E2_CIDE
EndIf
lF050Auto := IF(Type("lF050Auto") == "U", .F., lF050Auto)

SA2->(dbSetOrder(1))
SA2->(MSSeek(xFilial("SA2")+SE2->(E2_FORNECE+E2_LOJA)))
lIRProg := IIf(cPaisLoc == "BRA",IIf(!Empty(SA2->A2_IRPROG),SA2->A2_IRPROG,"2"),"2")

lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)

nPis		 := SE2->E2_PIS
nCofins	     := SE2->E2_COFINS
nCsll		 := SE2->E2_CSLL
cParcPis	 := SE2->E2_PARCPIS
cParcCof	 := SE2->E2_PARCCOF
cParcCsll    := SE2->E2_PARCSLL
If lContrRet
	nVretPis := SE2->E2_VRETPIS
	nVretCof := SE2->E2_VRETCOF
	nVretCsl := SE2->E2_VRETCSL
Endif
PRIVATE aHeader:={}
PRIVATE nUsado := 0
PRIVATE aRatAFR		:= {}
PRIVATE bPMSDlgFI	:= {||PmsDlgFI(2,M->E2_PREFIXO,M->E2_NUM,M->E2_PARCELA,M->E2_TIPO,M->E2_FORNECE,M->E2_LOJA)}
PRIVATE _Opc := nOpc
PRIVATE lTitRetD 	:= .F. 		//	Indica se o titulo retentor poderá ser Deletado
PRIVATE nTitRetD 	:= RecNo() 	// 	Recno do titulo retentor que será Deletado

lIntegracao := IF(GetMV("MV_EASYFIN")=="S",.T.,.F.)
lVerifyBlq  := Iif(Type("lVerifyBlq") == "U",.T.,lVerifyBlq)

//Botoes adicionais na EnchoiceBar
aBut050 := fa050BAR('SE2->E2_PROJPMS == "1"')

//inclusao do botao Posicao
AADD(aBut050, {"HISTORIC", {|| Fc050Con() }, STR0204}) //"Posicao"

//inclusao do botao Rastreamento
AADD(aBut050, {"HISTORIC", {|| Fin250Pag(2) }, STR0205}) //"Rastreamento"

// integração com o PMS
If IntePMS() .And. SE2->E2_PROJPMS == "1"
	SetKey(VK_F10, {|| Eval(bPMSDlgFI)})
EndIf

// Não excluir um Titulo que veio da Integração com o TOP - Wilson em 15/08/2011
If lPmsInt .And. SE2->E2_ORIGEM # "WSFINA05"
	If !FwIsInCallStack("FINI050")//o adapter pode excluir o titulo
		aArea     := GetArea()
		aAreaAFR  := AFR->(GetArea())
		aAreaSCP  := SCP->(GetArea())
		dbSelectArea("AFR")
		dbSetOrder(2)
		If MsSeek(xFilial("AFR")+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA)
			If lViaAFR
				lViaINT := IIf(AFR->AFR_VIAINT == 'S',.T.,.F.)
				If lViaINT
					Help(,,"INTPMS",,STR0203,1,0) // "Titulo Integrado pelo TOP só pode ser excluido pelo TOP"
					MsUnLockAll()
					Return .F.
				End
			End
		End
		RestArea(aAreaSCP)
		RestArea(aAreaAFR)
		RestArea(aArea)
	Endif
End

// Validação do documento hábil - SIAFI
If FinTemDH()
	Return .T.
Endif

//³ AAF - Titulos originados no SIGAEFF não devem ser alterados   ³
If !lF050Auto .AND. "SIGAEFF" $ SE2->E2_ORIGEM
	Help(" ",1,"FAORIEFF")
	Return
EndIf

//DFS - 16/03/11 - Deve-se verificar se os títulos foram gerados por módulos Trade-Easy, antes de apresentar a mensagem.
// TDF - 26/12/11 - Acrescentado o módulo EFF para permitir liquidação
// NCF - 25/03/13 - Acrescentado o módulo SIGAESS (Siscoserv)

If lIntegracao .and. (UPPER(Alltrim(SE2->E2_ORIGEM)) $ "SIGAEEC/SIGAEDC/SIGAECO/SIGAESS" .OR.( SE2->E2_PREFIXO == 'EIC'.AND. UPPER(Alltrim(SE2->E2_ORIGEM))$'SIGAEIC' ) ) .AND. !(cModulo $ "EEC/EIC/EDC/ECO/EFF/ESS")
	HELP(" ",1,"FAORIEEC")
	Return
Endif

//³ Verifica se o titulo foi gerado pela rotina de distrato do Template GEM       ³
If HasTemplate("LOT") .AND. ExistTemplate("GEMSE2DIS")
	If lDistrato := ExecTemplate("GEMSE2DIS",.F.,.F.)
		MsgAlert("Este título foi gerado pela rotina de distrato do template GEM, portanto nao poderá ser excluído.")
		Return .F.
	EndIf
EndIf

If AllTrim(SE2->E2_ORIGEM) == "JURCTORC" // Integração Controle Orçamentário SIGAPFS x SIGAFIN
	MsgAlert("Este título foi gerado pela rotina de Controle Orçamentário - SIGAPFS, portanto não poderá ser excluído.")
	Return .F.
EndIf

//³Verificar se o documento foi ajustado por diferencia de cambio.                                           ³
If cPaisLoc $ "ARG|ANG|COL|MEX|URU"
	SIX->(DbSetOrder(1))
	If SIX->(MsSeek('SFR'))
		SFR->(DbSetOrder(1))
		If SFR->(MsSeek(xFilial()+"2"+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA))
			Help( " ", 1, "FA084010",,Left(SFR->FR_CHAVDE,Len(SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO)),5)
			Return .F.
		Endif
	Endif
Endif

If cPaisLoc == "RUS"
	If R604Is48(SE2->E2_FILIAL,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
		Help(" ",1,STR0303)
		Return
	EndiF
EndIf

//³ Caso tenha seja um INV, gerado pelo SigaEic e do Brasil nao podera se excluido      	³
If lIntegracao .and.  cPaisLoc <> "ARG"   .and. SE2->E2_Tipo = "INV" .and. !(cModulo $ UPPER(SE2->E2_Origem)) ;
.and. !lF050Auto   // EOS - 01/05/04
	HELP(" ",1,"FAORIEIC")
	Return .F.
Endif

//³ Caso tenha seja um PR, gerado pelo SigaEic  nao podera ser excluido     	³
If lIntegracao .and. SE2->E2_Tipo = "PR" .and. UPPER(SE2->E2_Origem) = "SIGAEIC"
	HELP(" ",1,"FAORIEIC")
	Return .F.
Endif

//verifica se e titulo originado do SIGAPLS e nao deixa excluir.
if lPLSFN050 .and. ! lF050Auto .and. PLSFN050(nOpc)
	Return(.f.)
EndIf

If  AllTrim(SubStr(SE2->E2_ORIGEM, 1, 8)) $ 'MATA460A' .And. !lF050Auto
	Help(" ",1,"NO_DELETE",,SE2->E2_ORIGEM,3,1) //Este titulo nao podera ser excluido pois foi gerado pelo modulo
	Return .F.
EndIf

// Não deixa fazer a exclusão dos títulos gerados pelas rotinas de
// Aglutinação de Impostos.
// Não deixa excluir titulos de origem FINA667 - Integração Reserve
// Não deixa excluir titulos de origem FINA686 - Conferencia de servicos II
If AllTrim(SE2->E2_ORIGEM) $ 'FINA376#FINA378#FINA374#FINA667#FINA677#FINA685#FINA686#FINA381' .And. !lF050Auto
	Help(" ",1,"NO_DELETE",,SE2->E2_ORIGEM,3,1) //Este titulo nao podera ser excluido pois foi gerado pelo modulo
	Return .F.
EndIf

//³ Integracao com o Modulo de Transporte (SIGATMS)                             ³
If  AllTrim(SE2->E2_ORIGEM) $ 'SIGATMS|TOTVSGFE' .And. !lF050Auto
	Help(" ",1,"FA050TMS",,SE2->E2_ORIGEM,4,1) //Este titulo nao podera ser excluido pois foi gerado pelo modulo
	Return .F.
EndIf

//³ Se for um PA ou um cheque gerado por um PA deverá cancelar a Ordem de Pago. ³
If cPaisLoc $ "ARG|ANG|MEX|COL"
	If (SE2->E2_TIPO=="PA " .And.!Empty(SE2->E2_ORDPAGO)).Or.(SE2->E2_TIPO == "CH ".And.!Empty(SE2->E2_ORDPAGO))
		Help(" ",1,"OrdPago")
		Return .F.
	Endif
Endif

// usa o Modulo 88 GTP
If lIntGTP .And. nModulo <> 88
	If  Upper(AllTrim(SE2->E2_ORIGEM)) $ "GTPA421|GTPA700|GTPA700A|GTPA700L|"
		Help(" ",1,"NODELGTP",,STR0321,1,0) //"Este título não pode ser excluido ou cancelada sua baixa ,pois foi gerado através do GTP."
		Return
	EndIf
EndIf

//³ Se for um PA e houver uma Solicitação de Fundos que gerou este PA           ³
If cPaisLoc == "BRA"
	aAreaSE2   := GetArea()
	If E2_TIPO=="PA "
		dbSelectArea("FJA")
		dbSetOrder(6)
		If dbSeek(xFilial("FJA")+cPrefixo+cNum+cParcela+cTipo+cFornece+cLoja )
			nRecnoFJA:=(FJA->(Recno()))
		Endif
	Endif
	RestArea(aAreaSE2)
Endif

//³ Verifica se o titulo esta bloqueado - Gestao de Contratos ³
If !Empty(SE2->(FieldPos("E2_MSBLQL"))) .And. SE2->E2_MSBLQL == "1" .And. lVerifyBlq
	Help(" ",1,"SE2BLOQ")
	Return .F.
EndIf

//³ Verifica se o titulo esta em DARF						 ³
If cPaisLoc == "BRA"
	If AllTrim(SE2->E2_IDDARF) <> ""
		Help(" ",1,"SE2DARF1") //Este titulo nao podera ser excluido pois faz parte de uma DARF.
		Return .F.
	ElseIf ExstDarfPg( SE2->E2_FILIAL , SE2->( E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA ) , .T. )
		Return .F.
	EndIf
EndIf

//³ Verifica se data do movimento n„o ‚ menor que data limite de ³
//³ movimentacao no financeiro    								 ³
If !DtMovFin(,,"1")
	Return
Endif

// Verifica se titulo foi conciliado por DDA
If !Empty(SE2->E2_CODBAR)
	If VldConcDda(SE2->E2_FILIAL, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_CODBAR, SE2->E2_FILIAL+ "|" + SE2->E2_PREFIXO+"|" + SE2->E2_NUM+"|" +;
	SE2->E2_PARCELA+"|" + SE2->E2_TIPO+"|" + SE2->E2_FORNECE+"|" + SE2->E2_LOJA + "|")
		Help('',1,'FIN050DDA',,STR0273,1,0)
		Return
	EndIf
EndIf

//³ Caso seja uma parcela gerada pela rotina de aplicação/emprestimo não podera ser excluida     	³
If Alltrim(SE2->E2_ORIGEM) == "FINA171"
	Help(" ",1,"NO_DELETE",,STR0280,3,1) //"Empr‚stimo com gera‡?o de parcelas (FINA171)"
	Return .F.
Endif

If F050VTitEmp()
	If !(MSGYESNO(STR0281+CHR(10)+CHR(13)+STR0282,STR0026))	//"Este t¡tulo possui caracter¡sticas semelhantes a um titulo gerado pelo processo de empr‚stimo."###"Deseja realmente excluir este t¡tulo?"
		Return .F.
	Endif
Endif

If FindFunction("JurValidCP") .And. lIntPFS
	If !JurValidCP(5)
		Return .F.
	EndIf
EndIf

// Verifica movimentacao de AVP
FAVPValTit( "SE2",, SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, " " )

//Permito deletar titulo de impostos gerado pelo modulo financeiro e que nao possuir titulo pai
If SE2->E2_TIPO == MVTAXA .And. "FINA" $ Upper(SE2->E2_ORIGEM) .And. !Fa050Pai()
	lDelTit := .F.
Else
	lDelTit := .T.
EndIf

//³ Verifica se os dados nao foram gravados por outro modulo			 ³
cE2Origem := Upper(Trim(SE2->E2_ORIGEM))

If !Empty(cE2Origem) .And. !cE2Origem $ "FINA050|SIGATMS|TOTVSGFE" .And. !"GPE" $ cE2Origem .And. !"APT" $ cE2Origem .And.;
	!lF050Auto .And. cModulo <> "EIC" .And. lDelTit .And. !(cE2Origem=="MATA460A" .And. SE2->E2_PREFIXO=="ICM") .And.;
	nModulo <> 17 .And. !Fa50Vendor()
	If cE2Origem == "WSFINA05"
		MsgAlert(STR0203) // "Titulo Integrado pelo TOP so pode ser excluido pelo TOP"
		Return .F.
	Else
		Help(" ",1,"NO_DELETE2")
		Return .F.
	EndIf

ElseIF  (Alltrim(SE2->E2_NATUREZ))=="VENDOR" .and. Empty(SE2->E2_TITORIG) .and. (Upper(Trim(SE2->E2_ORIGEM)) $ "FINA090")
	cTeste:=  SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE)
	cAliasVend	:=	GetNextAlias()
	cQryVend := "SELECT * "
	cQryVend += "FROM "+RetSqlName("SE2")+" WHERE "
	cQryVend += "E2_TITORIG='"+cTeste+"' AND "
	cQryVend += "E2_BAIXA IS NOT NULL AND "
	cQryVend += "D_E_L_E_T_=' ' "
	cQryVend := ChangeQuery(cQryVend)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQryVend),cAliasVend,.F.,.T.)
	If (cAliasVend)->(!Eof())
		Help(" ",1,"F050VEND")
		lRetQry := .F.
	ENDIF
	(cAliasVend)->(dbCloseArea())
	If !lRetQry
		Return .F.
	Endif
ELSE
	If Empty((SE2->E2_ORIGEM)) .and. SE2->E2_TIPO == "TX " .and. ;
	(Alltrim(SE2->E2_NATUREZ) == Alltrim(SuperGetMv("MV_ICMS",.F.,"ICMS")) .or. ;
	Alltrim(SE2->E2_NATUREZ) == Alltrim(SuperGetMv("MV_IPI",.F.,"IPI"))  .or. ;
	Alltrim(SE2->E2_NATUREZ) $ "ICMS#IPI" )
		Help(" ",1,"NO_DELETE2")
		Return
	Endif
EndIf

//Titulo de impostos(PCC) gerado pelo modulo financeiro e que possui um titulo pai
If !lFina590 .And. lDelTit
	cNatImp := AllTrim(GetMv("MV_PISNAT"))+"|"+AllTrim(GetMv("MV_COFINS"))+"|"+AllTrim(GetMv("MV_CSLL"))
	cTipImp := PADR(SE2->E2_FILIAL+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA, TamSx3("FK7_CHAVE")[1])
	lImpOld := SE2->E2_TIPO $ MVTAXA .And. Alltrim(SE2->E2_NATUREZ) $ cNatImp

	If (lTemMR .And. !FinTitImp("SE2", SE2->E2_TIPO, "P", cTipImp)) .Or. lImpOld
		If lImpOld
			Help(" ",1,"NODELETA",, STR0157 , 4,0) //"Titulo de Impostos Pis, Cofins ou Csll, Altere o Titulo Pai"
		Else
			Help(" ",1,"NODELETA",, STR0302 , 4,0)
		EndIf
		Return .F.
	EndIf
EndIf

//Permito exclusão de titulo gerado pela folha
If "GPE" $ SE2->E2_ORIGEM .And. !lF050Auto
	If lGPEExcTit	// Define se podera excluir titulo gerado pelo SIGAGPE no SIGAFIN
		If ! (MSGYESNO(STR0120+CHR(10)+CHR(13)+STR0121,STR0026))		//"Este titulo foi gerado pelo modulo SIGAGPE - Gestao de Pessoal."###"Deseja realmente deleta-lo ?"###"Atencao"
			Return
		Else
			// Controla exclusão do título na tabela RC1 (Gestão de Pessoal).
			lDelGPE := .T.
		EndIf
	Else
		MsgAlert( STR0120 + CHR(10) + CHR(13) + STR0206, STR0026 )		//STR0206 - "A exclusão somente pode ser realizada no módulo SIGAGPE."
		Return
	Endif
EndIf

//Permito exclusão de titulo gerado pelo Processo Trabalhista.
If "APT" $ SE2->E2_ORIGEM .And. !lF050Auto
	If !(MSGYESNO(STR0148+CHR(10)+CHR(13)+STR0149,STR0026))		//"Este titulo foi gerado pelo modulo SIGAAPT - Processo Trabalhista."###"Deseja realmente deleta-lo ?"###"Atencao"
		Return
	Endif
EndIf

//³ Verifica se o titulo nao esta em bordero                          ³
If !Empty(SE2->E2_NUMBOR)
	Help("",1,"FA050BORD")
	Return  .F.
Else
	// Caso seja o titulo principal, verifica se existe titulo de impostos
	// gerado, e confirma se estes estao ou nao em um outro bordero.
	aTitImp := ImpCtaPg()
	For nX := 1 To Len(aTitImp)

		If !Empty(aTitImp[nX][8]) .and. (aTitImp[nX][7] == aTitImp[nX][6])
			Help("",1,"FA050BORD")
			Return  .F.
		Endif
	Next
EndIf

If !Empty(E2_BAIXA) .and. !lFina250
	Help(" ",1,"FA050BAIXA")
	Return .F.
EndIf

If Len(aTitImp)> 0 .and. Empty(SE2->E2_BAIXA)
	For nX := 1 To Len(aTitImp)
		If aTitImp[nx][7] <> aTitImp[nx][6]
			Help(" ",1,"FA050BAIXA")
			Return .F.
		EndIf
	Next
EndIf

If E2_VALOR != E2_SALDO .and. !lFina250
	Help(" ",1,"BAIXAPARC")
	Return .F.
EndIf

If lFindTemp .And. aliasIndic("LHP") .And. cPaisLoc == "BRA" .And. Iif (!lPass, !T_AE_EXCSE2(.F.,SE2->(Recno())), .f.) 
	Help(,,"TEMPCDV",,STR0244,1,0) // "Título gerado pelo Template CDV só pode ser excluído pela rotina de origem."
	Return .F.
EndIf  
//O Titulo Principal deste Imposto foi baixado
If cPaisLoc == "BRA" .And. (SE2->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"SES"+"/"+"INA") .And. F050BxPai() .AND. !lFina590
	Help(" ",1,"FA050BAIXA")
	Return .F.
EndIf

//³ Verifica se nao ‚ um titulo de ISS ou IR ou INSS ou SEST ou CIDE³
IF cPaisLoc == "BRA" .And. E2_TIPO $ MVISS+"/"+MVTAXA+"/"+MVTXA+"/"+MVINSS+"/"+"SES"+"/"+"CID"+"/"+"INA" .And. !lFina379 // Recalculo do PCC (FINA379)
	If Fa050Pai()
		Help(" ",1,"NOVALORIR")
		Return .F.
	EndIf
EndIf

//Verifica a possibilidade de Alteração de um titulo que teve seus impostos(PCC)
//Retidos em outro Titulo(Retentor)
//Este procedimento NAO sera efetuado na seguinte situacao (exemplo)
//- Foi realizado um desdobramento com calculo de impostos na emissao (PCC)
//- Foram geradas 3 parcelas de 2.000 e a retencao do PCC foi na terceira parcela
//- Foi incluido um outro titulo (simples) de 2.000 com calculo de PCC
//- Ao se cancelar o desdobramento, sobraria apenas o titulo de 2.000 e nao deveria haver retencao do PCC
//- Por utilizar algo em torno de 4 rotinas atumaticas encadeadas, o sistema apresenta mensagens inconsistentes
//  e nao permite o cancelamento do desdobramento.
If (E2_PRETPIS	= '2' .Or. E2_PRETCOF	= '2' .Or. E2_PRETCSL	= '2') .and. !lFina250
	If	F050VerAlt()
		lTitRetD := .T.
	Else
		Return .F.
	EndIf
Endif
If !lPCCBaixa
	lCpRet:= SLDRMSG(SE2->E2_EMISSAO, SE2->E2_SALDO,SE2->E2_NATUREZ,"P",SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_TIPO)
	If lCpRet
		If !IsBlind() .AND. !MSGNoYes(STR0249) // "Essa baixa possui impostos retidos em outra baixa, deseja continuar ?"
			Return
		Endif
	Endif
Endif
// Se nao for titulo de imposto, verifica se um dos titulos de impostos já foi baixado e nao permite a exclusao
//Também verifica se tem titulo de imposto que esteja em DARF.
If ! E2_TIPO $ MVISS+"/"+MVTAXA+"/"+MVTXA+"/"+MVINSS+"/"+"SES"+"/"+"CID"+"/"+"INA"
	If !Fa050Filho(.T.)
		// Se o titulo filho sofreu baixa, verifica se o ponto de entrada permitira a exclusao
		// do titulo, senao, nao permite a exclusao.
		If !lF050DEL1 .Or. !ExecBlock("F050DEL1", .F., .F.)
			Help(" ",1,"NODELETA",,STR0131, 4, 0) // "Este titulo possui impostos e"+chr(13)+"um desses impostos sofreu baixa"
			Return .F.
		Endif
	ElseIf !Fa050FDarf()
		Help(" ",1,"SE2DARF2") // "Este titulo nao podera ser excluido""pois gerou títulos de impostos que""fazem parte de uma DARF."
		Return .F.
	Endif
Endif

//³ Verifica se foi emitido cheque para este titulo							 ³
IF SE2->E2_IMPCHEQ == "S"
	Help( " ", 1, "EXISTCHEQ" )
	Return( .F. )
END

//³ Verifica se foi emitido cheque para um dos titulos de impostos	 -  Verifica na delecao do titulo pai                             		 ³
If Fa050VerImp()
	Help( " ", 1, "EXISTCHEQ" )
	Return( .F. )
EndIf

//Verifica se existe tratamento de rastreamento
//Verifica se o titulo foi gerador ou gerado por desdobramento
dbSelectArea("FI8")
dbSetOrder(2)	// FI8_FILIAL+FI8_PRFDES+FI8_NUMDES+FI8_PARDES+FI8_TIPDES+FI8_FORDES+FI8_LOJDES
lAchou:= MsSeek(xFilial("FI8")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO))

If lRastro .AND. SE2->E2_DESDOBR $ "1#S" .AND. lAchou .AND. !lNRastDSD .and. !lFina250
	Help( " ", 1, "DESDOBRAD",,STR0152+Chr(13)+;  //"Não é possivel a exclusão de titutos geradores ou gerados por desdobramento. "
	STR0153,1)	//"Favor utilizar a rotina de Cancelamento de Desdobramento."
	Return .F.
Endif

//³ Verifica se adiantamento tem relacionamento com pedido de   ³
//³ compra.                                                     ³
If cPaisLoc $ "BRA|MEX" .and. SE2->E2_TIPO $ MVPAGANT
	FIE->(dbSetOrder(3))
	If FIE->(MsSeek(xFilial("FIE")+"P"+SE2->(E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO)))
		Aviso(STR0115,STR0167,{ "Ok" }) // "Atenção"#"Adiantamento relacionado a um pedido de compra. Primeiro é necessário excluir este relacionamento."
		Return()
	Endif
Endif
If SE2->E2_TIPO $ MVPAGANT .and. SE2->E2_EMISSAO > dDataBase
	dbSelectArea("SE5")
	dbSetOrder(7)
	If MsSeek(xFilial("SE5")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
		Help( " ", 1, "NODELPA" )
		Return .F.
	EndIf
EndIf

IF lFA050UPD
	//³ Ponto de Entrada para Pre-Validacao de Exclusao     ³
	IF !ExecBlock("FA050UPD",.f.,.f.)
		Return .F.
	Endif
Endif

//³ Integracao com o Controle de Exportacao (SIGAEEC)                           ³
dbselectarea("FII")
dbsetorder(2)
If dbseek(xFilial("FII")+"SE2"+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA)

	If (!Type("lF050Auto") == "L" .or. !lF050Auto)
		If MsgYesNo(STR0208,STR0115) //"Titulo Efetivo originado de Título(s) Provisório(s), deseja excluir o Efetivo e retornar o(s) Provisório(s) para o Status 'Em aberto'?")
			lEstProv := .T.
		else
			Return .F.
		endif

	Else
		lEstProv := .T.
	EndIf

EndIf

PRIVATE aTELA[0][0],aGETS[0]

nOpcA := 2
dbSelectArea("SA2")
dbSeek(cFilial+SE2->E2_FORNECE+SE2->E2_LOJA)
dbSelectArea("SED")
dbSeek(cFilial+SE2->E2_NATUREZ)
If !SoftLock( "SE2" )
	Return  .F.
EndIf
dbSelectArea(cAlias)
dbSetOrder(1)

bCampo := {|nCPO| Field(nCPO) }
FOR i := 1 TO FCount()
	M->&(EVAL(bCampo,i)) := FieldGet(i)
NEXT i
If !Type("lF050Auto") == "L" .or. !lF050Auto
	If lPanelFin  //Chamado pelo Painel Financeiro
		dbSelectArea("SE2")
		RegToMemory("SE2",.F.,.F.,,FunName())
		oPanelDados := FinWindow:GetVisPanel()
		oPanelDados:FreeChildren()
		aDim := DLGinPANEL(oPanelDados)

		DEFINE MSDIALOG oDlg OF oPanelDados:oWnd FROM 0, 0 TO 0, 0 PIXEL STYLE nOR( WS_VISIBLE, WS_POPUP )

		aPosEnch := {,,,}
		oEnc01:= MsMGet():New( cAlias, nReg, nOpc,,"AC",STR0008,,aPosEnch,,,,,,oDlg,,,.F.) // "Quanto … exclus„o?"
		oEnc01:oBox:Align := CONTROL_ALIGN_ALLCLIENT

		// define dimenção da dialog
		oDlg:nWidth := aDim[4]-aDim[2]

		ACTIVATE MSDIALOG oDlg  ON INIT (FaMyBar(oDlg,{|| nOpca := 1,oDlg:End()},{|| nOpca := 2,oDlg:End()},aBut050,),	oDlg:Move(aDim[1],aDim[2],aDim[4]-aDim[2], aDim[3]-aDim[1]))

		FinVisual(cAlias,FinWindow,(cAlias)->(Recno()))

	Else
		nOpca := AxVisual(cAlias,nReg,2,,,,,aBut050)
	Endif
Else
	nOpcA := 1
EndIf

If nOpcA == 1
	// Integração com o SigaPfs
	If lIntPFS
		If !F050AtuPFS(5, nSavRec)
			Return .F.
		EndIf
	EndIf

	If (Type("lF050Auto") == "L" .and. lF050Auto)
		lRetVM		:= .T.
	Endif

	Begin Transaction
		SE5->(DbSelectarea("SE5"))
		SE5->(DbSetorder(7))
		If SE5->( DbSeek( xFilial("SE5")+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO) )
			cChave := xFilial("SE5")+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO
			While cChave == SE5->(E5_FILIAL + E5_PREFIXO + E5_NUMERO + E5_PARCELA + E5_TIPO )
				If SE5->E5_TIPODOC $ "VM"
					If lRetVM
						// Gera o lancamento contabil para delecao da varicao monetaria
						If SE5->E5_TIPODOC $ "VM"
							cPadMon :=	cPadrao
							cPadrao := "59B"
						EndIf

						IF SE5->E5_TIPODOC $ "VM"
							If !lHead
								nHdlPrv:=HeadProva(cLote,"FINA050",Substr(cUsuario,7,6),@cArquivo)
								lHead := .T.
							Endif
							nTotal+=DetProva(nHdlPrv,cPadrao,"FINA050",cLote)
						Endif

						RodaProva(nHdlPrv,nTotal)
						// Indica se a tela sera aberta para digitação
						lDigita := IIF(mv_par01==1 .And. (!lF050Auto .or. (lF050Auto .and. UPPER(Alltrim(SE2->E2_ORIGEM)) $ "SIGAEEC/SIGAEIC/SIGAEDC/SIGAECO/SIGAESS")),.T.,.F.)
						cA100Incl(cArquivo,nHdlPrv,3,cLote,lDigita,.F.,,,,,,aDiario)
						RecLock("SE5")
						dbDelete() // Deve-se deletar, como é feito quando se tem histórico de baixas de um titulo a ser excluído.
						MsUnLock()
						cPadrao:= cPadMon
					Else
						DisarmTransaction()
						Return(.F.)
					EndIf
				EndIf
				SE5->(DbSkip())
			EndDo
		Endif
		//³ Inicializa a gravacao dos lancamentos do SIGAPCO          ³
		PcoIniLan("000002")

		//³ Execblock para verificacao se o titulo pode ser excluido ou nao.   ³
		//³ Se retornar .T. continua o processo de exclusao, se .F. retorna    ³
		//³ sem excluir o titulo.                                              ³
		If lFA050Del
			lOk := ExecBlock("FA050Del",.F.,.F.)
		Endif

		aChave := {SE2->E2_FILIAL,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA}

		aPenCont := FA050PenC(aChave)

		If Len(aPenCont) > 0
			lOk := FA050MonP(aPenCont)
		EndIf
		If !lOk
			MsUnLock()
			DisarmTransaction()
			Return .F.
		Endif

		//³ Verifica se o titulo foi gerado por desdobramento.  ³
		If SE2->E2_DESDOBR == "S"
			lDesdobr := .T.
		Endif
		// Verifica se o titulo foi distribuido por multiplas naturezas para contabilizar o
		// cancelamento via SE2 ou SEV
		If SE2->E2_MULTNAT == "1"
			DbSelectArea("SEV")
			If MsSeek(RetChaveSev("SE2"))
				// Vai para o final para nao contabilizar duas vezes o LP 515
				DbGoBottom()
				DbSkip()
			Endif
			DbSelectArea("SE2")
		Endif

		//³ Verifica se o titulo PA pode ser baixado 			  ³
		If SE2->E2_TIPO $ MVPAGANT
			If !Fa050DelPa(.T., @lTemCheq, @nRecSef)
				DisarmTransaction()
				Return  .F.
			Endif
		EndIf

		//Inicia processo do lancamento no Pco quando possui rateio
		lRateioPCO := .F.
		If SE2->E2_RATEIO=="S" .And. !Empty(SE2->E2_ARQRAT)
			PcoIniLan("000021")
			lRateioPCO := .T.
		EndIf

		// Integração protheus X tin.
		If __lFWHasEAI
			lRatPRj:=PMSRatPrj("SE2",,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
			If !( AllTrim(SE2->E2_TIPO) $ MVPAGANT .and. lRatPrj  .and. !(cPaisLoc $ "BRA|")) //nao integra PA  para Totvs Obras e Projetos Localizado
				aEaiRet := FWIntegDef('FINA050',,,, 'FINA050')
				If !aEaiRet[1]
					Help(" ", 1, "HELP", STR0315, STR0316 + CRLF + aEAIRET[2], 3, 1)  // "Erro EAI" / "Problemas na integração EAI. Transação não executada."
					DisarmTransaction()
					nOpcA := 2
				Endif
			Endif
		Endif

		If SE2->E2_RATEIO=="S"
			F050ExcTmp(cPadrao,lDesdobr) //Força criação da FwTemporaryTable para armazenar dados do rateio. O Begin Tran abaixo impossibilita inserir-la através do CTBRATFIN;
		Endif

		If lFA050B01
			ExecBlock("FA050B01",.F.,.F.)
		EndIf
		dbSelectArea("SE2")

		//³Variavel utilizada na Integração com RM Solum, vai permitir passar ³
		//³na Exclusão de itens do RM Solum apenas uma vez.                   ³
		lPrimeiro:=.T.  //Wilson em 06/06/2011
		//³ Atualizacao dos dados do Modulo SIGAPMS    ³
		If IntePMS()
			PmsWriteFI(2,"SE2")	//Estorno
			PmsWriteFI(3,"SE2")	//Exclusao
		Endif
		//³ Apaga os lancamentos nas contas orcamentarias SIGAPCO    ³
		If SE2->E2_TIPO $ MVPAGANT
			PcoDetLan("000002","02","FINA050",.T.)
		Else
			PcoDetLan("000002","01","FINA050",.T.)
		EndIf

		If SE2->E2_TEMDOCS == "1"
			CN062ApagDocs()
		EndIf

		IF !E2_TIPO $ MVPROVIS .or. mv_par02 == 1
			//³ Posiciona no registro referente ao Fornecedor		  ³
			dbSelectArea("SA2")
			dbSeek(cFilial+SE2->E2_FORNECE+SE2->E2_LOJA)
			dbSelectArea("SE2")
			If !CtbInUse()
				cPadrao:=Iif(SE2->E2_RATEIO=="S","511","515")
			Else
				cPadrao:=Iif(SE2->E2_RATEIO=="S","512","515")
			EndIf
			IF SE2->E2_TIPO $ MVPAGANT
				cPadrao:="514"
			Endif
			aAreaSA2 := SA2->(GetArea())
			/*
			* Exclui TXs de IR
			*/
			If lIRPFBaixa
				/*
				* Exclui os Tx's de IRPJ
				*/
				F241DelTxIR("FINA050",SE2->( Recno() ), SE2->E2_IRRF)
			EndIf
			RestArea(aAreaSA2)

			//³ Verifica se titulos foram gerados via desdobramento ³
			//³ e altera o lancamento padrao para 578.              ³
			If lDesdobr
				cPadrao:="578"
			Endif
			lPadrao:=VerPadrao(cPadrao)
			//³ Deleta os titulos de Desdobramento em aberto        ³
			If lDesdobr
				//³ Apaga os lancamentos de desdobramento - SIGAPCO  ³
				PcoDetLan("000002","03","FINA050",.T.)

				nValSaldo := 0
				VALOR := 0
				lHead := .F.
				dDtEmiss := SE2->E2_EMISSAO
				nMoedSE2 := SE2->E2_MOEDA
				nOrdSE2 := IndexOrd()
				//³ Gera o lancamento contabil para delecao de titulos  ³
				//³ gerados via desdobramento.                          ³
				IF lPadrao .and. SubStr(SE2->E2_LA,1,1) == "S"  .and. lNRastDSD
					If !lHead
						//³ Inicializa Lancamento Contabil                                   ³
						nHdlPrv := HeadProva( cLote,;
						"FINA050" /*cPrograma*/,;
						Substr(cUsuario,7,6),;
						@cArquivo )
						lHead := .T.
					Endif
					//³ Prepara Lancamento Contabil                                      ³
					//Contabiliza pela variavel VALOR. Nao necessita de controle de flag.
					nTotal += DetProva( nHdlPrv,;
					cPadrao,;
					"FINA050" /*cPrograma*/,;
					cLote,;
					/*nLinha*/,;
					/*lExecuta*/,;
					/*cCriterio*/,;
					/*lRateio*/,;
					/*cChaveBusca*/,;
					/*aCT5*/,;
					/*lPosiciona*/,;
					/*@aFlagCTB*/,;
					/*aTabRecOri*/,;
					/*aDadosProva*/ )
					nValSaldo += SE2->E2_VALOR
				Endif

				nRegAtu := nRecnoSE2 := SE2->(Recno())
				dbSkip()
				nProxReg := SE2->(Recno())
				dbGoto(nRegAtu)

				If UsaSeqCor()
					aDiario := {}
					aDiario := {{"SE2",SE2->(recno()),SE2->E2_DIACTB,"E2_NODIA","E2_DIACTB"}}
				Else
					aDiario := {}
				EndIf

				If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
					lAchou := .F.
					FI8->(DbSetOrder(1))
					// Se nao for o titulo gerador do desdobramento, atualiza o saldo, pois o titulo gerador nao atualiza o saldo
					// na inclusao
					lAchou := FI8->(MsSeek(xFilial("FI8")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
					If !lAchou
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, If(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"3","2"), "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM, "+", "-"),,FunName(),"SE2",SE2->(Recno()),nOpc)
					Endif
				Endif

				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				RecLock("SE2",.F.,.T.)
				dbDelete()
				MsUnLock()

				If nTotal > 0
					dbSelectArea ("SE2")
					dbGoBottom( )
					dbSkip( )
					VALOR := nValSaldo
					//³ Prepara Lancamento Contabil                                      ³
					//Contabiliza pela variavel VALOR. Nao necessita de controle de flag.
					nTotal += DetProva( nHdlPrv,;
					cPadrao,;
					"FINA050" /*cPrograma*/,;
					cLote,;
					/*nLinha*/,;
					/*lExecuta*/,;
					/*cCriterio*/,;
					/*lRateio*/,;
					/*cChaveBusca*/,;
					/*aCT5*/,;
					/*lPosiciona*/,;
					/*@aFlagCTB*/,;
					/*aTabRecOri*/,;
					/*aDadosProva*/ )
				Endif

				IF lPadrao .and. nTotal > 0
					//-- Se for rotina automatica força exibir mensagens na tela, pois mesmo quando não exibe os lançametnos, a tela
					//-- sera exibida caso ocorram erros nos lançamentos padronizados
					If lF050Auto
						lSetAuto := _SetAutoMode(.F.)
						lSetHelp := HelpInDark(.F.)
						If Type('lMSHelpAuto') == 'L'
							lMSHelpAuto := !lMSHelpAuto
						EndIf
					EndIf
					//³ Envia para Lan‡amento Cont bil - desdobramentos   ³
					RodaProva( nHdlPrv,;
					nTotal )
					cA100Incl( cArquivo,;
					nHdlPrv,;
					3 /*nOpcx*/,;
					cLote,;
					( mv_par01 == 1 ) /*lDigita*/,;
					( mv_par07 == 1 ) /*lAglut*/,;
					/*cOnLine*/,;
					/*dData*/,;
					/*dReproc*/,;
					/*@aFlagCTB*/,;
					/*aDadosProva*/,;
					aDiario )
					aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento

					SE2->(dbSetOrder(nOrdSE2))
					If lF050Auto
						HelpInDark(lSetHelp)
						_SetAutoMode(lSetAuto)
						If Type('lMSHelpAuto') == 'L'
							lMSHelpAuto := !lMSHelpAuto
						EndIf
					EndIf
				EndIf
			Else
				dDtEmiss := SE2->E2_EMISSAO
				nValSaldo := SE2->E2_VALOR
				nMoedSE2 := SE2->E2_MOEDA
			EndIf

			//³ Monta contabiliza‡„o - exceto desdobramentos 	   ³
			IF lPadrao .and. SubStr(SE2->E2_LA,1,1) == "S" .and. !lDesdobr
				IF cPadrao == "511"
					If CtbInUse()
						cArq := fa050rate( cPadrao , "FINA050" ,"E",@nHdlPrv,@cArquivo)
						If !Empty( cArquivo )
							cA100Incl( cArquivo,;
							nHdlPrv,;
							3 /*nOpcx*/,;
							cLote,;
							( mv_par01 == 1 ) /*lDigita*/,;
							( mv_par07 == 1 ) /*lAglut*/,;
							/*cOnLine*/,;
							/*dData*/,;
							/*dReproc*/,;
							/*@aFlagCTB*/,;
							/*aDadosProva*/,;
							aDiario )
							aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento
						EndIf
					EndIf
				ElseIf cPadrao == "512"
					If CtbInUse()
						CtbRatFin(cPadrao,"FINA050",cLote,3," ",nOpc)
					EndIf
				Else
					//³ Inicializa Lancamento Contabil                                   ³
					nHdlPrv := HeadProva( cLote,;
					"FINA050" /*cPrograma*/,;
					Substr(cUsuario,7,6),;
					@cArquivo )
					//³ Prepara Lancamento Contabil                                      ³
					If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
						aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
					Endif
					nTotal += DetProva( nHdlPrv,;
					cPadrao,;
					"FINA050" /*cPrograma*/,;
					cLote,;
					/*nLinha*/,;
					/*lExecuta*/,;
					/*cCriterio*/,;
					/*lRateio*/,;
					/*cChaveBusca*/,;
					/*aCT5*/,;
					/*lPosiciona*/,;
					@aFlagCTB,;
					/*aTabRecOri*/,;
					/*aDadosProva*/ )
				EndIf

				If cPadrao $ "512|511"
					If lFA050RAT
						ExecBlock ("FA050RAT",.f.,.f.)
					EndIf
				EndIf
			EndIf

			//³ Busca moeda na qual se faz o controle de saldos em  ³
			//³ moeda forte. A contabilizacao altera o valor da va- ³
			//³ riavel NMOEDA para 5, independente da moeda na qual ³
			//³ se faz esse controle.                               ³
			nMoeda 	 := Int(Val(GetMv("MV_MCUSTO")))
			If lDesdobr
				SE2->(dbGoTo(nRegAtu))
			Else
				SE2->(dbGoTo(nSavRec))
			Endif
			If !cNatureza$&(GetMv("MV_IRF")) .And. lAtuForn
				//³ Atualiza saldo do fornecedor                        ³
				DbSelectArea("SA2")
				SA2->(DbSeek(XFILIAL("SA2")+SE2->E2_FORNECE+SE2->E2_LOJA))
				SA2->(RecLock("SA2"))
				If !(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG+"/"+MVABATIM)
					SA2->A2_SALDUP -= Round(NoRound(xMoeda(nValSaldo,nMoedSE2,1,dDtEmiss,3),3),2)
					SA2->A2_SALDUPM-= Round(NoRound(xMoeda(nValSaldo,nMoedSE2,nMoeda,dDtEmiss,3),3),2)
				Else
					SA2->A2_SALDUP += Round(NoRound(xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,3),3),2)
					SA2->A2_SALDUPM+= Round(NoRound(xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,nMoeda,SE2->E2_EMISSAO,3),3),2)
				EndIf
				MsUnlock()
			EndIf
		EndIf

		//³ Busca se tem comissao pagas para esse titulo, e tendo volta status para nao pago ³
		If nOrdem > 0
			dbSelectarea("SE3")
			If cPaisLoc == "BRA"
				dbSetOrder(nOrdem)
				cBusca := Left(xFilial("SE3") + SE2->( E2_PREFIXO + E2_NUM + E2_PARCELA ) + Space(Len(SE3->E3_PROCCOM)),Len(SE3->E3_PROCCOM))
				dbSeek(xFilial("SE3")+cBusca,.T.)
				aRecSE3 := {}
				Do While ! Eof() .And. cBusca == SE3->E3_PROCCOM
					AAdd( aRecSE3, SE3->(Recno()) )
					SE3->(dbSkip())
				Enddo
				For nX := 1 To Len(aRecSE3)
					SE3->(dbGoTo(aRecSE3[nX]))
					RecLock("SE3",.F.)
					If lComisExc
						aExcSE3 := ExecBlock("F050DSE3",.F.,.F.,{aRecSE3[nX]})
						If Len(aExcSE3) >= 2
							If ValType(aExcSE3[1]) # "D"
								aExcSE3[1] := Ctod("")
							Endif
							If ValType(aExcSE3[2]) # "C"
								aExcSE3[1] := ""
							Endif
						Else
							aExcSE3 := {Ctod(""),""}
						Endif
					Endif
					SE3->E3_DATA    := aExcSE3[1]
					SE3->E3_PROCCOM := aExcSE3[2]
					SE3->(MsUnlock())
				Next nX
			Endif
			dbSelectArea("SA2")
		Endif

		// Faz tratamento do titulos de pagamento antecipado.
		If !(SE2->E2_TIPO $ MVPAGANT)
			dbSelectArea("SEF")
			dbSetOrder(7)
			If dbSeek(xFilial("SEF")+"P"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO))
				While !Eof() .and. xFilial("SEF") == SEF->EF_FILIAL .and. ;
				SEF->(EF_PREFIXO+EF_TITULO+EF_PARCELA+EF_TIPO) == ;
				SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO)

					nAtuRec := SE5->(RECNO())
					dbSkip()
					nProxRec := SE5->(Recno())
					dbGoto(nAtuRec)

					If SEF->(EF_FORNECE+EF_LOJA) == SE2->(E2_FORNECE+E2_LOJA)
						RecLock("SEF")
						Replace EF_KEY with EF_PREFIXO+EF_TITULO+EF_PARCELA+EF_TIPO+EF_FORNECE+EF_LOJA
						Replace EF_PREFIXO With ""
						Replace EF_TITULO With ""
						Replace EF_PARCELA With ""
						Replace EF_TIPO With ""
						MsUnlock()
						FKCOMMIT()
					Endif
					dbGoto(nProxRec)
				Enddo
			Endif
		Else
			If !Fa050DelPa(.F., lTemCheq , nRecSef)
				DisarmTransaction()
				Return .F.
			EndIf
		Endif

		//³ Exclui os registros do FRC - Tabela de Controle de Cartão de Credito.   ³
		If cPaisLoc == "EQU" .and. AllTrim(SE2->E2_TIPO) == "CC" .and. Subs(ProcName(1),1,8) <> "FA099GRV"
			Fa050DelFRC()
		EndIf

		If lInssBx  .And. cPaisLoc == "BRA" .And. SE2->E2_TIPO $ MVPAGANT .And. !lInsPub//Excluir titulo do imposto INSS na SE2.
			FDelTxInss(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_SEQBX,.F.)
		Endif
		F050GrvSE5(2,.F.)

		//realiza a exclus?o da tabela complementar
		If cPaisLoc=="BRA"
			Fa986excl("SE2")
		EndIf

		//realiza a exclus?o no TAF
		//habilitar somente quando tiver a integra??o TAF
		//FExpT999(SE2->(Recno()), 1, 'T154')

		If lExistFJU
			FinGrvEx("P")
		Endif

		// Motor de Retenção
		// Ajusto as tabelas FK3/FK4/FK0 caso o titulo tenha retenção
		If lTemMR
			aAreaAnt := GetArea()
			//Dados da tabela auxiliar com o código do título a pagar
			cChaveTit := xFilial("SE2") + "|" + SE2->E2_PREFIXO + "|" + SE2->E2_NUM     + "|" + SE2->E2_PARCELA + "|" + ;
												SE2->E2_TIPO    + "|" + SE2->E2_FORNECE + "|" + SE2->E2_LOJA
			cChaveFK7 := FINGRVFK7("SE2", cChaveTit)

			FMRDelImp( "SE2", cChaveFK7, 2 )
		Endif

		//³ Apaga  o registro (exceto desdobramento)	  ³
		If !lDesdobr .or. (SE2->E2_TIPO $ MVPROVIS .and. lDesdobr)
			// Se estiver utilizando multiplas naturezas por titulo
			If SE2->E2_MULTNAT == "1"
				// Apaga as naturezas geradas para o titulo
				DelMultNat( "SE2", @nHdlPrv, @nTotal, @cArquivo, /*lSoContabiliza*/, /*aCols*/, lUsaFlag, @aFlagCTB )
			Else
				If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
					AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, If(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"3","2"), "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM, "+", "-"),,FunName(),"SE2",SE2->(Recno()),nOpc)
				Endif
			Endif

			dbSelectArea(cAlias)
			nRegAtu := SE2->(Recno())
			//Limpo referencias de apuracao de impostos.
			If lContrRet
				aRecSE2 := FImpExcTit("SE2",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,@aTpImp)
				For nX := 1 to Len(aRecSE2)
					SE2->(MSGoto(aRecSE2[nX]))
					FaAvalSE2(4,,,,,,,,,,aTpImp[nX])
				Next
				//³ Exclui os registros de relacionamentos do SFQ                                ³
				SE2->(dbGoto(nRegAtu))
				If lPCCBaixa .And. SE2->E2_TIPO $ MVPAGANT //Se for PA (geracao de tx's pela emissao), exclui o SFQ pelo SE5.
					FImpExcSFQ("SE5",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
				Else
					FImpExcSFQ("SE2",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
				Endif

			Endif
			// Apaga os registros referentes ao rateio do titulo
			If !Empty(SE2->E2_ARQRAT) .And. CtbInUse()
				cChaveCV4 := RTrim(SE2->E2_ARQRAT)
				RecLock(cAlias ,.F.,.T.)
				SE2->E2_ARQRAT := "" // Limpa Relacionamento com CV4
				MsUnlock()
				FKCOMMIT()
				CV4->(dbSetOrder(1))
				If CV4->(MsSeek(cChaveCV4))   // Chave jah contem filial
					While CV4->(!Eof()) .And.;
					CV4->CV4_FILIAL+DTOS(CV4->CV4_DTSEQ)+CV4->CV4_SEQUEN == cChaveCV4
						//Exclui lancamento para o modulo PCO
						PcoDetLan("000021","01","FINA050",.T.)
						RecLock("CV4",.F.,.T.)
						CV4->(dbDelete())
						MsUnlock()
						CV4->(DbSkip())
					End
				Endif
			Endif

			If  UsaSeqCor()
				aDiario := {}
				aDiario := {{"SE2",SE2->(recno()),SE2->E2_DIACTB,"E2_NODIA","E2_DIACTB"}}
			Else
				aDiario := {}
			EndIf

			nRecnoSE2 := (SE2->(Recno()))

			If cAlias=="SE2"
				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
			Endif
			RecLock(cAlias ,.F.,.T.)
			dbDelete()
			MsUnLock()

			// Com o registro ainda em lock exclui o registro da tabela RC1, pois utiliza a transação ativa.
			If lDelGPE
				FinDelGPE( SE2->( xFilial("RC1") + E2_FILIAL + E2_PREFIXO + E2_NUM + E2_TIPO + E2_FORNECE) )
			EndIf

			// Atualiza dados do fornecedor
			If lAtuForn
				cAliasFor	:=	GetNextAlias()
				cQryFor := "SELECT MAX(E2_EMISSAO) ULTCOM "
				cQryFor += "FROM "+RetSqlName("SE2")+" WHERE "
				cQryFor += "E2_FORNECE='"+SA2->A2_COD+"' AND "
				cQryFor += "E2_LOJA='"+SA2->A2_LOJA+"' AND "
				cQryFor += "D_E_L_E_T_=' ' "
				cQryFor += "GROUP BY E2_FORNECE, E2_LOJA "
				cQryFor := ChangeQuery(cQryFor)
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQryFor),cAliasFor,.F.,.T.)
				If (cAliasFor)->(Eof())
					cUltima := ""
				ELSE
					cUltima := (cAliasFor)->ULTCOM
				ENDIF
				(cAliasFor)->(DBCloseArea())

				Reclock("SA2")
				SA2->A2_ULTCOM := STOD(cUltima)
				MsUnlock()
			Endif
		Endif

		IF nISS != 0 .and. !lCalcIssBx
			//³ Apaga tambem os registro de impostos-ISS   ³
			dbSelectArea("SE2")
			dbSetOrder(1)
			If dbSeek(cFilial+cPrefixo+cNum+cParcIss+MVISS)
				While !Eof() .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
					cFilial+cPrefixo+cNum+cParcIss+"ISS"
					//Se nao existir E2_TITPAI, valida da forma antiga
					//Se E2_TITPAI vazio (titulos antigos), valida da forma antiga
					//Se E2_TITPAI preenchido, pre-valida com a chave do titulo principal
					If !lTitPai .OR. (lTitPai .AND. If(!Empty(SE2->(E2_TITPAI)),Alltrim(SE2->(E2_TITPAI)) == cTitPai,.T.))
						IF AllTrim(E2_NATUREZ) = AllTrim(&(GetMv("MV_ISS"))) .And. SE2->E2_SALDO != 0
							// Apaga o lancamento do ISS gerado no PCO
							PCODetLan("000002","09","FINA050",.T.)
							If lAtuSldNat
								AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
							Endif

							FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
							If lExistFJU
								FinGrvEx("P")
							Endif
							RecLock("SE2",.F.,.T.)
							dbDelete()
							MsUnLock()
						EndIf
					Endif
					dbSkip()
				Enddo
			Endif
		EndIf

		IF nINSS != 0 .And. !lInssBx
			//³ Apaga tambem os registro de impostos-INSS  ³
			dbSelectArea("SE2")
			dbSetOrder(1)
			dbSeek(xFilial("SE2")+cPrefixo+cNum+cParcInss+IF(cTipo$MVPAGANT,"INA",MVINSS))
			While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
				cFilial+cPrefixo+cNum+cParcInss+IF(cTipo$MVPAGANT,"INA",MVINSS)
				IF AllTrim(E2_NATUREZ) = AllTrim(&(GetMv("MV_INSS")))  .And. SE2->E2_SALDO != 0
					// Apaga o lancamento do INSS gerado no PCO
					PCODetLan("000002","07","FINA050",.T.)
					If lAtuSldNat
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
					Endif

					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					If lExistFJU
						FinGrvEx("P")
					Endif
					RecLock("SE2",.F.,.T.)
					dbDelete()
					MsUnLock()
				ElseIf lF050INS .And. lTop .And. FInsDif(cTitPai)
					// Apaga o lancamento do INSS gerado no PCO
					PCODetLan("000002","07","FINA050",.T.)
					If lAtuSldNat
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
					Endif
					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					If lExistFJU
						FinGrvEx("P")
					Endif
					RecLock("SE2" ,.F.,.T.)
					dbDelete()
					MsUnLock()
				EndIf
				dbSkip()
			Enddo
		EndIf

		If lGetParcINP
			GetParcINP(@cParcINP,@nValINSSPatr)
		EndIf

		IF nValINSSPatr != 0
			//³ Apaga tambem os registro de impostos-INSS  ³
			dbSelectArea("SE2")
			dbSetOrder(1)
			dbSeek(xFilial("SE2")+cPrefixo+cNum+cParcINP+"INP")
			While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
				cFilial+cPrefixo+cNum+cParcINP+"INP"
				IF AllTrim(SE2->E2_NATUREZ) = AllTrim(&(GetMv("MV_INSS")))  .And. SE2->E2_SALDO != 0
					If lAtuSldNat
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
					Endif
					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					If lExistFJU
						FinGrvEx("P")
					Endif
					RecLock("SE2",.F.,.T.)
					dbDelete()
					msUnLock()
				ElseIf lF050INS .And. FInsDif(cTitPai)
					// Apaga o lancamento do INSS gerado no PCO
					PCODetLan("000002","07","FINA050",.T.)
					If lAtuSldNat
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
					Endif
					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					If lExistFJU
						FinGrvEx("P")
					Endif
					RecLock("SE2",.F.,.T.)
					dbDelete()
					msUnLock()
				EndIf
				dbSkip()
			Enddo
		EndIf

		IF nSEST != 0
			//³ Apaga tambem os registro de impostos-SEST  ³
			dbSelectArea("SE2")
			dbSetOrder(1)
			dbSeek(cFilial+cPrefixo+cNum+cParcSEST+"SES")
			While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
				cFilial+cPrefixo+cNum+cParcSEST+"SES"
				IF AllTrim(E2_NATUREZ) = AllTrim(cSEST)  .And. SE2->E2_SALDO != 0
					// Apaga o lancamento do SEST/SENAT gerado no PCO
					PCODetLan("000002","08","FINA050",.T.)
					If lAtuSldNat
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
					Endif

					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					If lExistFJU
						FinGrvEx("P")
					Endif
					RecLock("SE2",.F.,.T.)
					dbDelete()
					msUnLock()
				EndIf
				dbSkip()
			Enddo
		EndIf

		If lCIDE
			IF nCIDE != 0
				//³ Apaga tambem os registro de impostos-CIDE  ³
				dbSelectArea("SE2")
				dbSetOrder(1)
				dbSeek(cFilial+cPrefixo+cNum+cParcCIDE+"CID")
				While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
					cFilial+cPrefixo+cNum+cParcCIDE+"CID"
					IF AllTrim(E2_NATUREZ) = AllTrim(cCIDE)  .And. SE2->E2_SALDO != 0
						If lAtuSldNat
							AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
						Endif

						FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
						If lExistFJU
							FinGrvEx("P")
						Endif
						RecLock("SE2",.F.,.T.)
						dbDelete()
						msUnLock()
					EndIf
					dbSkip()
				Enddo
			EndIf
		EndIf

		IF nPis != 0 .or. (nPis == 0 .and. nVretPis > 0)
			//³ Apaga tambem os registro de impostos-PIS	  ³
			dbSelectArea("SE2")
			dbSetOrder(1)
			dbSeek(cFilial+cPrefixo+cNum+cParcPis+Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG .And. !lPCCBaixa,MVTXA,MVTAXA))
			While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
				cFilial+cPrefixo+cNum+cParcPis+Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG .And. !lPCCBaixa,MVTXA,MVTAXA)
				IF AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_PISNAT"))  .And. SE2->E2_SALDO != 0
					// Apaga o lancamento do PIS gerado no PCO
					PCODetLan("000002","10","FINA050",.T.)
					If lAtuSldNat
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
					Endif

					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					If lExistFJU
						FinGrvEx("P")
					Endif
					RecLock("SE2",.F.,.T.)
					dbDelete()
					msUnLock()
				EndIf
				dbSkip()
			Enddo
		EndIf
		IF nCofins != 0 .or. (nCofins == 0 .and. nVretCof > 0)
			//³ Apaga tambem os registro de impostos-COFINS³
			dbSelectArea("SE2")
			dbSetOrder(1)
			dbSeek(cFilial+cPrefixo+cNum+cParcCof+Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG .And. !lPCCBaixa,MVTXA,MVTAXA))
			While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
				cFilial+cPRefixo+cNum+cParcCof+Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG .And. !lPCCBaixa,MVTXA,MVTAXA)
				IF AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_COFINS"))  .And. SE2->E2_SALDO != 0
					// Apaga o lancamento do COFINS gerado no PCO
					PCODetLan("000002","11","FINA050",.T.)
					If lAtuSldNat
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
					Endif

					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					If lExistFJU
						FinGrvEx("P")
					Endif
					RecLock("SE2",.F.,.T.)
					dbDelete()
					msUnLock()
				EndIf
				dbSkip()
			Enddo
		EndIf
		IF nCsll != 0  .or. (nCsll == 0 .and. nVretCsl > 0)
			//³ Apaga tambem os registro de impostos-CSLL  ³
			dbSelectArea("SE2")
			dbSetOrder(1)
			dbSeek(cFilial+cPrefixo+cNum+cParcCsll+Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG .And. !lPCCBaixa,MVTXA,MVTAXA))
			While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
				cFilial+cPrefixo+cNum+cParcCsll+Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG .And. !lPCCBaixa,MVTXA,MVTAXA)
				IF AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_CSLL"))  .And. SE2->E2_SALDO != 0
					// Apaga o lancamento do CSLL gerado no PCO
					PCODetLan("000002","12","FINA050",.T.)
					If lAtuSldNat
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
					Endif

					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					If lExistFJU
						FinGrvEx("P")
					Endif
					RecLock("SE2",.F.,.T.)
					dbDelete()
					msUnLock()
				EndIf
				dbSkip()
			Enddo
		EndIf
		IF cPaisLoc $ "DOM|COS"
			//³ Apaga os registro de impostos-IRF          |
			dbSelectArea("SE2")
			SE2->(dbSeek(cFilial+cPrefixo+cNum+cParcela))
			While !SE2->(Eof( )) .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA == ;
				cFilial+cPRefixo+cNum+cParcela
				IF AllTrim(E2_TIPO) $ "IR-|IRF|ISR|IS-|IT |IT-"  .And. SE2->E2_SALDO != 0
					If lAtuSldNat
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-")
					Endif

					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					RecLock("SE2",.F.,.T.)
					SE2->(dbDelete( ))
					msUnLock()
				EndIf
				SE2->(dbSkip())
			Enddo
		EndIf

		// Apaga tambem os registros agregados-SE2
		If !( cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG+"/"+MVABATIM)
			dbSelectArea("SE2")
			dbSetOrder(1)
			dbSeek(cFilial+cPrefixo+cNum+cParcela)
			While !EOF() .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA == ;
				cFilial+cPrefixo+cNum+cParcela
				IF SE2->E2_TIPO $ MVABATIM .and. E2_FORNECE == cFornece
					If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "+",,FunName(),"SE2",SE2->(Recno()),nOpc)
					Endif
					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					RecLock("SE2",.F.,.T.)
					If lPadrao .and. !lDesdobr .And. SubStr(SE2->E2_LA,1,1) == "S"
						//³ Prepara Lancamento Contabil                                      ³
						If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
							aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
						Endif
						nTotal += DetProva( nHdlPrv,;
						cPadrao,;
						"FINA050" /*cPrograma*/,;
						cLote,;
						/*nLinha*/,;
						/*lExecuta*/,;
						/*cCriterio*/,;
						/*lRateio*/,;
						/*cChaveBusca*/,;
						/*aCT5*/,;
						/*lPosiciona*/,;
						@aFlagCTB,;
						/*aTabRecOri*/,;
						/*aDadosProva*/ )
					Endif
					dbDelete()
					msUnLock()
					If lAtuForn
						Reclock("SA2")
						SA2->A2_SALDUP  += Round(NoRound(xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,3),3),2)
						SA2->A2_SALDUPM += Round(NoRound(xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,nMoeda,SE2->E2_EMISSAO,3),3),2)
						MsUnlock()
					EndIf
					dbSelectArea( "SE2" )
				EndIf
				dbSkip()
			Enddo
		Endif
		
		// Não devera excluir titulos TX amarrados manualmente com PR.
		If (!cNatureza $ &(GetMv("MV_IRF"))) .AND. (!cTipoSE2 $ MVPROVIS)
			//³ Apaga tambem os registro de impostos		  ³
			dbSelectArea("SE2")
			nOrd		:= IndexOrd()
			dbSetOrder(1)
			dbSeek(cFilial+cPrefixo+cNum+cParcIr+IIF(cTipo $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA))
			While !EOF() .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
				cFilial+cPrefixo+cNum+cParcIr+IIF(cTipo $ MVPAGANT+"/"+MV_CPNEG .And. ! lIRPFBaixa,MVTXA,MVTAXA)
				IF E2_NATUREZ = &(GetMv("MV_IRF")) .And. SE2->E2_SALDO != 0
					// Apaga o lancamento do IRRF gerado no PCO
					PCODetLan( "000002", "06", "FINA050", .T. )
					If lAtuSldNat
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
					Endif

					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					If lExistFJU
						FinGrvEx("P")
					Endif
					RecLock("SE2",.F.,.T.)
					dbDelete()
					msUnLock()
				EndIF
				dbSkip()
			EndDo
			dbSetOrder(nOrd)
		EndIf
		//³ Finaliza a gravacao dos lancamentos do SIGAPCO            ³
		PcoFinLan("000002")
		If nTotal > 0
			If lF050Auto
				lSetAuto := _SetAutoMode(.F.)
				lSetHelp := HelpInDark(.F.)
				If Type('lMSHelpAuto') == 'L'
					lMSHelpAuto := !lMSHelpAuto
				EndIf
			EndIf

			//³ Envia para Lan‡amento Cont bil -                  ³
			RodaProva( nHdlPrv,;
			nTotal )
			cA100Incl( cArquivo,;
			nHdlPrv,;
			3 /*nOpcx*/,;
			cLote,;
			( mv_par01 == 1 ) /*lDigita*/,;
			( mv_par07 == 1 ) /*lAglut*/,;
			/*cOnLine*/,;
			/*dData*/,;
			/*dReproc*/,;
			@aFlagCTB,;
			/*aDadosProva*/,;
			aDiario )
			aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento

			If lFA050RAT
				ExecBlock ("FA050RAT",.f.,.f.)
			EndIf

			If lF050Auto
				HelpInDark(lSetHelp)
				_SetAutoMode(lSetAuto)
				If Type('lMSHelpAuto') == 'L'
					lMSHelpAuto := !lMSHelpAuto
				EndIf
			EndIf
		Endif

		//Executa rotina para estorno de título provisório
		If lEstProv .and. nRecnoSE2 > 0
			F050RetPR(nRecnoSE2)
		EndIF
		If SE2->(Recno()) <> nSavRec
			If (E2_PRETPIS	= '2' .Or. E2_PRETCOF	= '2' .Or. E2_PRETCSL	= '2') .and. !lFina250
				If	F050VerAlt()
					lTitRetD := .T.
				Else
					lTitRetD := .F.
				EndIf
			Else
				lTitRetD := .F.
			EndIf
		EndIf

		If !lPCCBaixa .And. lTitRetD
			SE2->(dbGoto(nSavRec))
			F050DelRtd()
		EndIf
		//³ Colocar o Status na Solicitação se for PA gerardo na Solicitação de fundos ³
		If nRecnoFJA <> 0
			aArea   := GetArea()
			dbSelectArea("FJA")
			FJA->(DbGoto(nRecnoFJA))
			RecLock("FJA" ,.F.)
			FJA->FJA_ESTADO := "2"
			FJA->FJA_PREFIX := ""
			FJA->FJA_NUMTIT := ""
			FJA->FJA_PARCEL := ""
			FJA->FJA_TIPO 	:= ""
			FJA->(MsUnlock())
			RestArea(aArea)
		Endif

	// Final do bloco protegido via TTS.
	End Transaction

	//Finaliza o processo do lancamento no Pco quando E2_RATEIO == "S"
	If lRateioPCO
		PcoFinLan("000021")
	EndIf
Else
	MsUnlock()
	dbSelectArea(cAlias)
	dbGoto(nProxReg)
	dbSetOrder(nIndex)
	Return .F.
Endif

// Verifica o arquivo de rateio, e apaga o arquivo temporario
// para que no proximo rateio seja criado novamente
If Select("TMP") > 0
	DbSelectArea( "TMP" )
	DbCloseArea()
Endif

//Deleta tabela temporária no banco de dados
If (_oFINA0501 <> NIL)
	_oFINA0501:Delete()
	_oFINA0501 := NIL
EndIf
If cPaisLoc=="BRA"
	F986LimpaVar() //Limpa as variaveis estaticas - Complemento de Titulo
EndIf

If IntePMS() .And. SE2->E2_PROJPMS == "1"
	SetKey(VK_F10, Nil)
EndIf

dbSelectArea(cAlias)
dbGoto(nProxReg)
dbSetOrder(nIndex)
Return .T.


/*/
±±³Fun‡…o	 ³FA050Tipo ³ Autor ³ Wagner Xavier 		  ³ Data ³ 30/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Checa o Tipo do titulo informado 								  ³±±
/*/
Function FA050Tipo(lTdOk)

LOCAL lRetorna  := .T.
LOCAL cChaveSe2 := ""
Local cChaveAba := ""
LOCAL cSEST     := GetMv("MV_SEST",,"")
LOCAL cCIDE     := GetMv("MV_CIDE",,"")

Default	lTdOk := .F.

If cPaisLoc $ "BRA|MEX"
	If Type("aRecnoAdt") != "U" .and. (FunName() = "MATA121" .or. FunName() = "MATA103")
		If !M->E2_TIPO $ MVPAGANT
			Aviso(STR0026,STR0168,{ "Ok" }) // "ATENCAO"#"Por tratar-se de título para processo de adiantamento, é obrigatório que o tipo do título seja 'PA', ou a correspondente a adiantamento."
			Return(.F.)
		Endif
	Endif
Endif

dbSelectArea("SE2")
nRegistro:=Recno()
dbSetOrder(1)
cTipoParaAbater := SE2->E2_TIPO

cChaveSe2 := "'" + cFilial + "' + m->e2_prefixo + m->e2_num + " +;
"m->e2_parcela + m->e2_tipo + m->e2_fornece + m->e2_loja"

dbSelectArea("SX5")
If !(dbSeek(cFilial+"05"+m->e2_tipo))
	Help(" ",1,"E2_TIPO")
	lRetorna := .F.
Elseif !NewTipCart(m->e2_tipo,"2")
	Help(" ",1,"TIPOCART")
	lRetorna := .F.
Else
	dbSelectArea("SE2")
	//³ Se for abatimento, herda os dados do titulo³
	If (cPaisLoc <> "PER" .And. M->E2_TIPO $ MVABATIM) .Or. (cPaisLoc == "PER" .AND. M->E2_TIPO $ StrTran( MVABATIM , "IR-|" , "" ))
		If ! Empty(m->e2_num) // Caso o numero seja digitado busco baseado na chave
			// em memoria, caso contrario utilizo o registro posicionado
			// no browse
			If Empty(m->e2_fornece) .Or. Empty(m->e2_loja)
				DbSetOrder(1) // Altero a ordem para busca sem cliente/loja
				// e Removo da chave o tipo, Fornecedor e Loja
				// Caso o fornecedor/loja nao tenham sido digitados
				cChaveAba := StrTran(cChaveSe2, " + m->e2_tipo + m->e2_fornece + m->e2_loja", "")
			Else
				DbSetOrder(6)
				cChaveAba :=  "'" + cFilial + "'+ m->e2_fornece + m->e2_loja + m->e2_prefixo + m->e2_num + m->e2_parcela"
			Endif

			If !(dbSeek(&cChaveAba))
				Help(" ",1,"FA040TIT")
				lRetorna:=.F.
			Endif
		Endif

		//³ Caso seja titulo de adiantamento, nao posso gerar tit.abatimento ³

		If lRetorna .And. SE2->E2_TIPO $ MVPAGANT+"/"+MVPROVIS+"/"+MV_CPNEG  .And. !(cPaisLoc $ "DOM|COS")
			Help(" ",1,"FA040TITAB")
			dbGoTo(nRegistro)
			lRetorna:=.F.
		Endif

		If ! SE2->E2_TIPO $ MVABATIM .and. m->e2_tipo $ MVABATIM .and. SE2->E2_SALDO > 0 .And. lRetorna
			FA050Herda(lTdOk)
			dbSelectArea("SE2")
			If dbSeek(&cChaveSe2)
				Help(" ",1,"FA040NUM")
				m->e2_num := CRIAVAR("E2_NUM")
				lRetorna := .F.
			Endif
		Endif
	EndIf

	If dbSeek(&cChaveSe2)
		Help(" ",1,"FA040NUM")
		dbGoTo(nRegistro)
		lRetorna:=.F.
	Else
		dbGoTo(nRegistro)
	Endif

	If lRetorna .And. m->e2_naturez$&(GetMv("MV_IRF")) .And. !m->e2_tipo $ MVTAXA
		Help(" ",1,"E2_TIPO")
		lRetorna := .F.
	EndIf

	If lRetorna .And. m->e2_naturez$&(GetMv("MV_INSS")) .And. !m->e2_tipo $ MVINSS
		Help(" ",1,"E2_TIPO")
		lRetorna := .F.
	EndIf

	If lRetorna .And. m->e2_naturez$AllTrim(cSEST) .And. !m->e2_tipo $ "SES"
		Help(" ",1,"E2_TIPO")
		lRetorna := .F.
	EndIf

	If lRetorna .And. m->e2_tipo $ MVRECANT+"/"+MV_CRNEG
		Help(" ",1,"E2_TIPO")
		lRetorna := .F.
	EndIf
EndIf

If lRetorna .And. M->E2_TIPO $ MVPAGANT .AND. ! lF050Auto
	Fa050DigPa(,@M->E2_MOEDA,Iif(Type("lSubst")=="L",lSubst,.F.))
Endif

Return lRetorna

/*/
±±³Fun‡…o	 ³FA050Venc ³ Autor ³ Wagner	Xavier		³ Data ³ 29/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica a data de vencimento informada					  ³±±
/*/
Function FA050Venc(nTpVenc)
LOCAL lRetorna := .T.
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

DEFAULT nTpVenc := 1 //1= Validando E2_VENCTO, 2 = Validando E2_VENCREA

If Type("lAltera")=="U"
	lAltera := .T.
	dVencReaAnt := CtoD('')
EndIf

If cPaisLoc == "BRA" .And. SA2->A2_RECPIS=="1" .AND. SA2->A2_RECCOFI=="1" .AND. SA2->A2_RECCSLL=="1"
	aFill(aDadosImp,0)
Endif

//Validando data de vencto
If M->E2_VENCTO < M->E2_EMISSAO
	Help(" ",1,"FANODATA")
	lRetorna := .F.

	//Validando data de vencimento Real
ElseIf nTpVenc == 2 .and. M->E2_VENCREA < M->E2_VENCTO
	lRetorna := .F.
	MsgAlert(STR0230)

	//Caso o titulo tenha sido contabilizado, nao podera ser alterado em nada
	//que influencie no calculo dos impostos
ElseIf cPaisLoc == "BRA" .and. lAltera .and. !lPccBaixa

	//Apenas para E2_VENCTO
	//Atualizacao do E2_VENCREA
	If nTpVenc == 1
		M->E2_VENCREA := DataValida(M->E2_VENCTO,.T.)
	Endif

	//Verifico se houve mudança de mes para o PCC
	If	(Month(M->E2_VENCREA) <> Month(dVencReaAnt))

		nRecAtu := SE2->(RECNO())
		//Busco a informacao de qual o titulo retentor do PCC do titulo em alteracao
		SFQ->(DbSetOrder(2)) //-- FQ_FILIAL+FQ_ENTDES+FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES
		If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))

			//Posiciono no cadastro de C.Pagar para verificar se o titulo retentor
			//foi contabilizado ou veio de outro modulo
			SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
			If SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI)))

				//Titulos contabilizados
				//os titulos vindos de outros modulos sempre tem E2_LA = 'S' ja que a contabilizacao ocorre na origem
				If SE2->E2_LA == "S"
					/*
					Conforme chamado TRGZT8, passou-se a permitir a alteracao da data de vencimento, porem, os impostos nao sao recalculados. */
					lRetorna := .T.
					Help(,,"ALTERVENCTO",,STR0245,1,0)		//"O título retentor de impostos está contabilizado ou foi gerado em outro módulo. Será permitida a alteração da data de vencimento, porém, os impostos não serão recalculados."
				Endif
			Endif
		Else
			//Verifico se o titulo eh retentor do PCC de outros titulos
			SFQ->(DbSetOrder(1)) //-- FQ_FILIAL+FQ_ENTORI+FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI
			If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
				//Titulos contabilizados
				//os titulos vindos de outros modulos sempre tem E2_LA = 'S' ja que a contabilizacao ocorre na origem
				If SE2->E2_LA == "S"
					//Help(" ",1,"F050ALPCC")
					/*
					Conforme chamado TRGZT8, passou-se a permitir a alteracao da data de vencimento, porem, os impostos nao sao recalculados. */
					lRetorna := .T.
					Help(,,"ALTERVENCTO",,STR0245,1,0)		//"O título retentor de impostos está contabilizado ou foi gerado em outro módulo. Será permitida a alteração da data de vencimento, porém, os impostos não serão recalculados."
				Endif
			Endif
		Endif
		dbSelectArea("SE2")
		SE2->(DbGoto(nRecAtu))
		// Quando alterou o mes e PCC na emissão *
		// Utilizado para calcular o pcc quando  *
		// data alterada na inclusão.            *
		If (Month(M->E2_VENCREA) <> Month(dVencReaAnt)) .and. nTpVenc==2 .and. M->E2_LA != "S"
			If ! ( Alltrim(SE2->E2_ORIGEM) == "FINA290" .And. Alltrim(SE2->E2_FATURA)  == "NOTFAT" )
				FA050Nat2()
			EndIf
			dVencReaAnt := M->E2_VENCREA
		EndIf

	Endif

ElseIf cPaisLoc == "BRA" .and. INCLUI .and. !lPccBaixa
	// Quando alterou o mes e PCC na emissão *
	// Utilizado para calcular o pcc quando  *
	// data alterada na inclusão.            *
	If (Month(M->E2_VENCREA) # Month(dVencReaAnt)) .and. M->E2_LA != "S"
		FA050Nat2()
		dVencReaAnt := M->E2_VENCREA
	EndIf

Endif

If lRetorna

	//Vencimento original do titulo
	If Empty(SE2->E2_VENCORI)
		M->E2_VENCORI := M->E2_VENCTO
	EndIf

	//Apenas para E2_VENCTO
	//Atualizacao do E2_VENCREA
	If nTpVenc == 1
		M->E2_VENCREA := DataValida(M->E2_VENCTO,.T.)
	Endif

	//Data de Agendamento do titulo
	M->E2_DATAAGE := M->E2_VENCREA

	lRefresh := .T.

EndIf

Return lRetorna


/*/
±±³Fun‡…o	 ³FA050Perg ³ Autor ³ Wagner Xavier 		  ³ Data ³ 29/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Carrega funcao Pergunte 											  ³±±
/*/
Function FA050Perg()
Return (.T.)

/*/
±±³Fun‡…o	 ³fa050Visua³ Autor ³ Wagner Xavier 		  ³ Data ³ 16/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa para visualizacao de contas a pagar 				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ FA050Visua(ExpC1,ExpN1,ExpN2) 									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo											  ³±±
±±³			 ³ ExpN1 = Numero do registro 										  ³±±
±±³			 ³ ExpN2 = Numero da opcao selecionada 							  ³±±
/*/
Function Fa050Visua( cAlias,nReg,nOpc )
LOCAL nOpcA
Local aBut050
Local lF050VIS := Existblock("F050VIS")

PRIVATE aRatAFR		:= {}
PRIVATE bPMSDlgFI	:= {||PmsDlgFI(2,M->E2_PREFIXO,M->E2_NUM,M->E2_PARCELA,M->E2_TIPO,M->E2_FORNECE,M->E2_LOJA)}
PRIVATE _Opc 		:= nOpc
Private aSE2FI2		:=	{} // Utilizada para gravacao das justificativas
Private aCposAlter  :=  {}

dbSelectArea("SA2")
dbSeek(cFilial+SE2->E2_FORNECE+SE2->E2_LOJA)

//Botoes adicionais na EnchoiceBar
aBut050 := fa050BAR('SE2->E2_PROJPMS == "1"')

///Projeto
//inclusao do botao Posicao
AADD(aBut050, {"HISTORIC", {|| Fc050Con() }, STR0204}) //"Posicao"

//inclusao do botao Rastreamento
AADD(aBut050, {"HISTORIC", {|| Fin250Pag(2) }, STR0205}) //"Rastreamento"

If lIntPFS .And. FindFunction("JURA246") .And. !(SE2->E2_TIPO $ MVTAXA+"|"+MVINSS+"|"+MVISS+"|"+MVTXA+"|SES|INA|IRF|PIS|COF|CSL")
	Aadd(aBut050,{"", {|| JURA246(1) }, STR0296}) //"Detalhe / Desdobramentos" (Módulo SIGAPFS)
EndIF

//Motor de retenções
If lTemMR
	AADD(aBut050, {"HISTORIC", {|| FINCRET('SE2') }, STR0300}) //'Consulta de Retenções'
EndIF

// integração com o PMS
If IntePMS() .And. SE2->E2_PROJPMS == "1"
	SetKey(VK_F10, {|| Eval(bPMSDlgFI)})
EndIf
dbSelectArea(cAlias)
RegToMemory("SE2",.T.,,.F.,FunName())
nOpca := AxVisual(cAlias,nReg,nOpc,,4,SA2->A2_NOME,"FA050MCPOS",aBut050)
If lF050VIS		// ponto na saida da visualizacao
	Execblock("F050VIS",.f.,.f.)
Endif

If IntePMS() .And. SE2->E2_PROJPMS == "1"
	SetKey(VK_F10, Nil)
EndIf
If cPaisLoc=="BRA"
	F986LimpaVar() //Limpa as variaveis estaticas - Complemento de Titulo
EndIf

Return

/*/
±±³Fun‡…o	 ³Fa050Subst³ Autor ³ Wagner Xavier 	    ³ Data ³ 18/05/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Rotina para substituicao de titulos provisorios.			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ FA050Subst(ExpC1,ExpN1,ExpN2) 							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo									  ³±±
±±³			 ³ ExpN1 = Numero do registro 								  ³±±
±±³			 ³ ExpN2 = Numero da opcao selecionada 						  ³±±
/*/
Function Fa050Subst( cAlias,nReg,nOpc )
LOCAL lPanelFin := IsPanelFin()
LOCAL cIndex	:= ""
LOCAL cChave	:= ""
LOCAL aDeletar 	:= {}
LOCAL lPadrao   := .F.
LOCAL cPadrao   := "533"
LOCAL cArquivo  := ""
LOCAL nHdlPrv   := 0
LOCAL nTotal    := 0
LOCAL lDigita	:= .F.
LOCAL nValorSe2	:= 0
LOCAL nRecSubs  := 0
LOCAL nHdlLock	:= 0
LOCAL lInverte 	:= .F.
LOCAL oValor	:= 0
LOCAL oQtdTit	:= 0
LOCAL oDlg
LOCAL oDlg1
LOCAL nRecSE2	:= SE2->(RECNO())
LOCAL aMoedas	:= {}
LOCAL aOutMoed	:= {STR0107,STR0108}	//"1=Nao Considera"###"2=Converte"
LOCAL cOutMoeda	:= "1"
LOCAL oCbx
LOCAL oCbx2
LOCAL oPanel
LOCAL oPanel2
LOCAL cMoeda	:= "1"
LOCAL cSimb		:= ""
LOCAL nRecno	:= 0
LOCAL aSize		:= {}
LOCAL aFlagCTB	:= {}
LOCAL lUsaFlag	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
LOCAL lAtuSldNat:= .T.
LOCAL nI		:=  0
LOCAL nPosPre	:=  0
LOCAL nPosNum	:=  0
LOCAL nPosPar	:=  0
LOCAL nPosTip	:=  0
LOCAL nPosFor	:=  0
LOCAL nPosLoj	:=  0

//Ponto de entrada para deletar provisorios ao inves de baixa-los
LOCAL lF50DelPr := ExistBlock("F50DELPR")
LOCAL lDelProvis := If(lF50DelPr, ExecBlock("F50DELPR",.F.,.F.), .F.)
//Substituicao automatica
Local lFA050SCL := ExistBlock("FA050SCL")
LOCAL cFIISeq	 := ""   // Armazena Sequencial gerado na baixa (SE5)
LOCAL cPrefOri   := ""   // Armazena prefixo do titulo PR
LOCAL cNumOri    := ""   // Armazena numero do titulo PR
LOCAL cParcOri   := ""   // Armazena parcela do titulo PR
LOCAL cTipoOri   := ""   // Armazena tipo do titulo PR
LOCAL cCfOri     := ""   // Armazena cliente/fornecedor do titulo PR
LOCAL cLojaOri   := ""   // Armazena loja do titulo PR
LOCAL cPrefDest  := ""   // Armazena prefixo do titulo NF
LOCAL cNumDest   := ""   // Armazena numero do titulo NF
LOCAL cParcDest  := ""   // Armazena parcela do titulo NF
LOCAL cTipoDest  := ""   // Armazena tipo do titulo NF
LOCAL cCfDest    := ""   // Armazena cliente/fornecedor do titulo NF
LOCAL cLojaDest  := ""   // Armazena loja do titulo NF
LOCAL cFilDest	 := ""   // Armazena filial de destino do titulo NF
LOCAL dDtEmiss   := dDatabase  // Variavel para armanzenar a data de emissao do titulo
Local aNtit		 := {}
Local aGravaAFR	:= {}
Local nMaxTam		:= 0
Local nRegSel		:= 0
Local aAreaSE2 := (cAlias)->(GetArea())
Local oSize
Local a1stRow		:= {}
Local a2ndRow		:= {}
Local oButton
PRIVATE aCampos		:= {}
PRIVATE nOpca		:= 0
PRIVATE aChaveLbn	:= {}
PRIVATE oMark		:= 0
PRIVATE nValorS		:= 0
PRIVATE nQtdTit 	:= 0
PRIVATE cCodFor		:= CriaVar("A2_COD",.F.)
PRIVATE cLojaFor	:= CriaVar("A2_LOJA")
PRIVATE cNomeFor	:= CriaVar("A2_NREDUZ",.F.)
PRIVATE lSubs		:=.F.
PRIVATE nMoedSubs	:= 1
PRIVATE aTitulo2CC  := {}

lPadrao:=VerPadrao(cPadrao)

lDelProvis := If(ValType(lDelProvis) != "L",.F.,lDelProvis)

VALOR := 0

//³ Verifica se data do movimento n„o ‚ menor que data limite de ³
//³ movimentacao no financeiro    								 ³
If !DtMovFin(,,"1")
	Return
Endif

//³ A ocorrencia 23 (ACS), verifica se o usuario poder  ou n„o   ³
//³ efetuar substitui‡„o de titulos provis¢rios.					  ³
IF !ChkPsw(23)
	If lF050Auto 
		AutoGRLog(STR0242)
	EndIf
	Return .F.
EndIf

If AllTrim(SE2->E2_ORIGEM) $"CNTA090|CNTA100|CNTA120"
	Aviso(OemToAnsi(STR0026),OemToAnsi(STR0150),{"Ok"})//"Atencao" ### "Este titulo foi gerado pelo módulo SIGAGCT e não pode ser utilizado para substituição."
	Return
EndIf

//³ Verifica se o titulo esta bloqueado - Gestao de Contratos ³
If !Empty(SE2->(FieldPos("E2_MSBLQL"))) .And. SE2->E2_MSBLQL == "1" .And. lVerifyBlq
	Help(" ",1,"SE2BLOQ")
	Return
EndIf

If ! lF050Auto

	//³ Inicializa array com as moedas existentes.						  ³
	aMoedas := FDescMoed()

	While .T.

		//³ Desenha tela para gets do codigo e loja  - WINDOWS			  ³
		nOpca := 0
		cSimb := Pad(Getmv("MV_SIMB"+Alltrim(STR(nMoedSubs))),4)+":"

		//Faz o calculo automatico de dimensoes de objetos
		oSize := FwDefSize():New(.T.)

		oSize:lLateral := .F.
		oSize:lProp	:= .T. // Proporcional

		oSize:AddObject( "1STROW" ,  100, 10, .T., .T. ) // Totalmente dimensionavel
		oSize:AddObject( "2NDROW" ,  100, 90, .T., .T. ) // Totalmente dimensionavel

		oSize:aMargins := { 1, 1, 1, 1 } // Espaco ao lado dos objetos 0, entre eles 3

		oSize:Process() // Dispara os calculos

		a1stRow := {oSize:GetDimension("1STROW","LININI"),;
		oSize:GetDimension("1STROW","COLINI"),;
		oSize:GetDimension("1STROW","LINEND"),;
		oSize:GetDimension("1STROW","COLEND")}

		a2ndRow := {oSize:GetDimension("2NDROW","LININI"),;
		oSize:GetDimension("2NDROW","COLINI"),;
		oSize:GetDimension("2NDROW","LINEND"),;
		oSize:GetDimension("2NDROW","COLEND")}

		DEFINE MSDIALOG oDlg TITLE STR0020 + " - " + STR0006 From oSize:aWindSize[1],oSize:aWindSize[2] to oSize:aWindSize[3],oSize:aWindSize[4] OF oMainWnd PIXEL // "Informe Fornecedor e Loja"
		oDlg:lMaximized := .T.

		@ a1stRow[1] + 003,a1stRow[2] + 003 Say STR0017				 										PIXEL OF oDlg COLOR CLR_HBLUE // "Fornecedor : "
		@ a1stRow[1] + 003,a1stRow[2] + 035 MSGET cCodFor F3 "FOR" Picture "@!" SIZE 70,08			  	PIXEL OF oDlg HASBUTTON

		@ a1stRow[1] + 003,a1stRow[2] + 110 Say STR0018 														PIXEL OF oDlg COLOR CLR_HBLUE // "Loja : "
		@ a1stRow[1] + 003,a1stRow[2] + 125 MSGET cLojaFor Picture "@!" SIZE 20,08 						PIXEL OF oDlg

		@ a1stRow[1] + 003,a1stRow[2] + 150 Say STR0105														PIXEL OF oDlg	//"Moeda "
		@ a1stRow[1] + 003,a1stRow[2] + 175 MSCOMBOBOX oCbx  VAR cMoeda		ITEMS aMoedas SIZE 50, 10 	PIXEL OF oDlg	ON CHANGE (nMoedSubs := Val(Substr(cMoeda,1,2)))

		@ a1stRow[1] + 003,a1stRow[2] + 245 Say STR0106														PIXEL OF oDlg	//"Outras Moedas"
		@ a1stRow[1] + 003,a1stRow[2] + 295 MSCOMBOBOX oCbx2 VAR cOutMoeda	ITEMS aOutMoed SIZE 60, 10	PIXEL OF oDlg

		@ a1stRow[1] + 016,a1stRow[2] + 003 Say STR0023					PIXEL Of oDlg //"N§ T¡tulos Selecionados: "
		@ a1stRow[1] + 016,a1stRow[2] + 245 Say STR0024+cSimb  		FONT oDlg:oFont PIXEL Of oDlg //"Valor Total: "


		oButton := TButton():New( a1stRow[1] + 003, a1stRow[2] + 365, STR0246,oDlg,{||If(!Empty(cCodFor+cLojaFor),F050SelPR(oDlg,cOutMoeda,@nValorS,@nQtdTit,cMarca,oValor,oQtdTit,nMoedSubs,oButton,a1stRow,a2ndRow,@nRegSel),HELP(" ",1,"OBRIGAT",,SPACE(45),3,0))},40,10,,,.F.,.T.,.F.,,.F.,,,.F. ) //"Ok"

		If IsPanelFin()
			ACTIVATE MSDIALOG oDlg ON INIT FaMyBar(oDlg,{||nOpca:=1,If(!Empty(cCodFor+cLojaFor),(nOpca := 1,oDlg:End()),HELP(" ",1,"OBRIGAT",,SPACE(45),3,0))},{||nOpca:=0,oDlg:End()})
			nMoedSubs := Val(Substr(cMoeda,1,2))
		Else
			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{|| If(FA050VLSUB(),(nOpca := 1,oDlg:End()),NIL)},{|| nOpca := 2,oDlg:End()})
		Endif

		Exit

	Enddo
Else
	lSubs := .T.
Endif

// Permitir substituir títulos normais por CC/CD e controlar baixa através do Cartão de Crédito
If cPaisLoc == "EQU" .and. Len(aTitulo2CC) > 0
	Fa050Tit2CC()
	Return
EndIf
VALOR 		:= 0
VLRINSTR 	:= 0
IF lSubs .Or. (nQtdTit > 0 .And. nOpca == 1)
	dbSelectArea( cAlias )
	dbSetOrder(1)
	dbGoTo(nRegSel)

	nOpc:=3			 //Inclusao
	lSubst:=.T.

	BEGIN TRANSACTION

		If FA050Inclu("SE2",nReg,nOpc,,,lSubst) == 1
			lSubst:=.F.
			nValorSe2 := SE2->E2_VALOR

			//Dados do titulo gerado (Destino)
			If !lDelProvis
				cPrefDest	:= SE2->E2_PREFIXO
				cNumDest	:= SE2->E2_NUM
				cParcDest	:= SE2->E2_PARCELA
				cTipoDest	:= SE2->E2_TIPO
				cCfDest		:= SE2->E2_FORNECE
				cLojaDest	:= SE2->E2_LOJA
				cFilDest	:= SE2->E2_FILIAL
				dDtEmiss	:= SE2->E2_EMISSAO
			Endif

			//³ Leitura para dele‡„o dos titulos provis¢rios.             	  ³
			If ( lPadrao )
				//³ Inicializa Lancamento Contabil                                   ³
				nHdlPrv := HeadProva( cLote,;
				"FINA050" /*cPrograma*/,;
				Substr(cUsuario,7,6),;
				@cArquivo )
			EndIf

			//³ Inicializa a gravacao dos lancamentos do SIGAPCO          ³
			PcoIniLan("000002")

			//Substituicao Manual
			If ! lF050Auto
				dbSelectArea("__SUBS")
				dbGoTop()
				While !Eof()
					If E2_OK == cMarca
						nRecSubs := RecNo()

						aAdd(aNtit,	{	SE2->E2_PREFIXO,	;
						SE2->E2_NUM,		;
						SE2->E2_PARCELA,  ;
						SE2->E2_TIPO,     ;
						SE2->E2_FORNECE,  ;
						SE2->E2_LOJA,     ;
						SE2->E2_VENCREA,  ;
						xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO),;
						xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,2,SE2->E2_EMISSAO),;
						xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,3,SE2->E2_EMISSAO),;
						xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,4,SE2->E2_EMISSAO),;
						xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,5,SE2->E2_EMISSAO),;
						SE2->(RECNO()),;	// [13]
						.F.}) // [14] -> Se integrou com PMS

						dbSelectArea("SE2")
						dbGoto(nRecSubs)

						If ( lPadrao )
							//³ Prepara Lancamento Contabil                                      ³
							If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
								aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
							Endif
							nTotal += DetProva( nHdlPrv,;
							cPadrao,;
							"FINA050" /*cPrograma*/,;
							cLote,;
							/*nLinha*/,;
							/*lExecuta*/,;
							/*cCriterio*/,;
							/*lRateio*/,;
							/*cChaveBusca*/,;
							/*aCT5*/,;
							/*lPosiciona*/,;
							@aFlagCTB,;
							/*aTabRecOri*/,;
							/*aDadosProva*/ )
						EndIf

						//Processo antigo (deletando o PR)
						If lDelProvis
							//³ Atualizacao dos dados do Modulo SIGAPMS    ³
							If IntePms()
								IF PmsVerAFR()
									aGravaAFR := PmsIncAFR()
								Endif
								lPrimeiro:= .T. //Wilson em 06/06/2011
								PmsWriteFI(2,"SE2")	//Estorno
								PmsWriteFI(3,"SE2")	//Exclusao
							EndIf

							//³ Chama a integracao com o SIGAPCO antes de apagar o titulo ³
							PcoDetLan("000002","01","FINA050",.T.)

							If lF050PROV
								ExecBlock("F050PROV",.F.,.F.)
							Endif

							If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
								AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
							Endif
							//³ Exclui registros de rateio multiplas naturezas x centro de custo, no caso ³
							//³ do titulo provisorio possuir rateio.                                      ³
							If SE2->E2_MULTNAT == "1"
								FDelRatPR( "P" )
							EndIf

							FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
							Reclock("SE2",.F.,.T.)
							dbDelete()
							MsUnlock()

							nMaxTam := Len(aNtit)
							If Len(aGravaAFR) > 0 .And. (!AFR->(dbSeek(aGravaAFR[1]+aNtit[nMaxTam][1]+aNtit[nMaxTam][2]+aNtit[nMaxTam][3]+aNtit[nMaxTam][4]+aNtit[nMaxTam][5]+aNtit[nMaxTam][6])))
								RecLock("AFR",.T.)
								AFR->AFR_FILIAL	:= aGravaAFR[1]
								AFR->AFR_PROJET	:= aGravaAFR[2]
								AFR->AFR_REVISA	:= aGravaAFR[3]
								AFR->AFR_TAREFA	:= aGravaAFR[4]
								AFR->AFR_TIPOD		:= aGravaAFR[17]
								AFR->AFR_PREFIX	:= aNtit[nMaxTam][1]
								AFR->AFR_NUM		:= aNtit[nMaxTam][2]
								AFR->AFR_PARCEL	:= aNtit[nMaxTam][3]
								AFR->AFR_TIPO		:= aNtit[nMaxTam][4]
								AFR->AFR_FORNEC	:= aNtit[nMaxTam][5]
								AFR->AFR_LOJA		:= aNtit[nMaxTam][6]
								AFR->AFR_VENREA	:= aNtit[nMaxTam][7]
								AFR->AFR_VALOR1	:= aNtit[nMaxTam][8]
								AFR->AFR_VALOR2	:= aNtit[nMaxTam][9]
								AFR->AFR_VALOR3	:= aNtit[nMaxTam][10]
								AFR->AFR_VALOR4	:= aNtit[nMaxTam][11]
								AFR->AFR_VALOR5	:= aNtit[nMaxTam][12]

								aNtit[nMaxTam][14]:= .T.

								MsUnLock()
							EndIf
						Else

							If IntePms()
								IF PmsVerAFR()
									aGravaAFR := PmsIncAFR()
								Endif
								lPrimeiro:= .T. //Wilson em 06/06/2011
								PmsWriteFI(2,"SE2")	//Estorno
								PmsWriteFI(3,"SE2")	//Exclusao
							EndIf

							If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
								AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
							Endif

							//Processo novo (baixando o PR)
							lMsErroAuto := .F.

							cPrefOri  := SE2->E2_PREFIXO
							cNumOri   := SE2->E2_NUM
							cParcOri  := SE2->E2_PARCELA
							cTipoOri  := SE2->E2_TIPO
							cCfOri    := SE2->E2_FORNECE
							cLojaOri  := SE2->E2_LOJA

							//Baixa Provisorio
							aVetor 	:= {{"E2_PREFIXO"	, SE2->E2_PREFIXO 		,Nil},;
							{"E2_NUM"		, SE2->E2_NUM       	,Nil},;
							{"E2_PARCELA"	, SE2->E2_PARCELA  		,Nil},;
							{"E2_TIPO"	    , SE2->E2_TIPO     		,Nil},;
							{"E2_FORNECE"	, SE2->E2_FORNECE  		,Nil},;
							{"E2_LOJA"	    , SE2->E2_LOJA     		,Nil},;
							{"AUTMOTBX"	    , "STP"             	,Nil},;
							{"AUTDTBAIXA"	, dDataBase				,Nil},;
							{"AUTDTDEB"		, dDataBase				,Nil},;
							{"AUTHIST"	    , "Baixa ref. substituicao de titulo Provisorio para Efetivo."	,Nil}}

							MSExecAuto({|x,y| Fina080(x,y)},aVetor,3)

							//Em caso de erro na baixa desarma a transacao
							If lMsErroAuto
								DisarmTransaction()
								MostraErro()
								Exit
							Else
								//³		Ponto de gravação dos campos da tabela auxiliar.		³
								dbselectarea("FII")
								cFIISeq	 := SE5->E5_SEQ

								FCriaFII("SE2", cPrefOri, cNumOri, cParcOri, cTipoOri, cCfOri, cLojaOri,;
								"SE2", cPrefDest, cNumDest, cParcDest, cTipoDest, cCfDest, cLojaDest,;
								cFilDest, cFIISeq )
							EndIf

							nMaxTam := Len(aNtit)
							If Len(aGravaAFR) > 0 .And. (!AFR->(dbSeek(aGravaAFR[1]+aNtit[nMaxTam][1]+aNtit[nMaxTam][2]+aNtit[nMaxTam][3]+aNtit[nMaxTam][4]+aNtit[nMaxTam][5]+aNtit[nMaxTam][6])))
								RecLock("AFR",.T.)
								AFR->AFR_FILIAL	:= aGravaAFR[1]
								AFR->AFR_PROJET	:= aGravaAFR[2]
								AFR->AFR_REVISA	:= aGravaAFR[3]
								AFR->AFR_TAREFA	:= aGravaAFR[4]
								AFR->AFR_TIPOD		:= aGravaAFR[17]
								AFR->AFR_PREFIX	:= aNtit[nMaxTam][1]
								AFR->AFR_NUM		:= aNtit[nMaxTam][2]
								AFR->AFR_PARCEL	:= aNtit[nMaxTam][3]
								AFR->AFR_TIPO		:= aNtit[nMaxTam][4]
								AFR->AFR_FORNEC	:= aNtit[nMaxTam][5]
								AFR->AFR_LOJA		:= aNtit[nMaxTam][6]
								AFR->AFR_VENREA	:= aNtit[nMaxTam][7]
								AFR->AFR_VALOR1	:= aNtit[nMaxTam][8]
								AFR->AFR_VALOR2	:= aNtit[nMaxTam][9]
								AFR->AFR_VALOR3	:= aNtit[nMaxTam][10]
								AFR->AFR_VALOR4	:= aNtit[nMaxTam][11]
								AFR->AFR_VALOR5	:= aNtit[nMaxTam][12]

								aNtit[nMaxTam][14]:= .T.

								MsUnLock()
							EndIf

						Endif
					Endif
					dbSelectArea("__SUBS")
					dbSkip()
				Enddo

				If IntePms()
					PMSProjPms(aNtit) // Atualiza campo E2_PROJPMS (FUNÇÃO NO PROPRIO FINA050)
				Endif

				//Automatica nova
			ElseIf Len(aItnTitPrv) > 0
				For nI:= 1 to Len(aItnTitPrv)

					If	(nPosPre := aScan(aItnTitPrv[nI], {|x| AllTrim(x[1]) == "E2_PREFIXO"} )) == 0 .Or.;
					(nPosNum := aScan(aItnTitPrv[nI], {|x| AllTrim(x[1]) == "E2_NUM"    } )) == 0 .Or.;
					(nPosPar := aScan(aItnTitPrv[nI], {|x| AllTrim(x[1]) == "E2_PARCELA"} )) == 0 .Or.;
					(nPosTip := aScan(aItnTitPrv[nI], {|x| AllTrim(x[1]) == "E2_TIPO"   } )) == 0 .Or.;
					(nPosFor := aScan(aItnTitPrv[nI], {|x| AllTrim(x[1]) == "E2_FORNECE"} )) == 0 .Or.;
					(nPosLoj := aScan(aItnTitPrv[nI], {|x| AllTrim(x[1]) == "E2_LOJA"   } )) == 0

						Loop

					EndIf


					SE2->(DbSetOrder(1))
					If SE2->(MsSeek(xFilial("SE2") + aItnTitPrv[nI,nPosPre,2] + aItnTitPrv[nI,nPosNum,2] + aItnTitPrv[nI,nPosPar,2] +;
					aItnTitPrv[nI,nPostip,2] + aItnTitPrv[nI,nPosFor,2] + aItnTitPrv[nI,nPosLoj,2] ))

						If ( lPadrao )
							//³ Prepara Lancamento Contabil                                      ³
							If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
								aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
							Endif
							nTotal += DetProva( nHdlPrv,;
							cPadrao,;
							"FINA050" /*cPrograma*/,;
							cLote,;
							/*nLinha*/,;
							/*lExecuta*/,;
							/*cCriterio*/,;
							/*lRateio*/,;
							/*cChaveBusca*/,;
							/*aCT5*/,;
							/*lPosiciona*/,;
							@aFlagCTB,;
							/*aTabRecOri*/,;
							/*aDadosProva*/ )
						EndIf

						//Processo antigo (deletando o PR)
						If lDelProvis

							If IntePms()
								//³ Atualizacao dos dados do Modulo SIGAPMS    ³
								lPrimeiro:= .T. //Wilson em 06/06/2011
								PmsWriteFI(2,"SE2")	//Estorno
								PmsWriteFI(3,"SE2")	//Exclusao
							EndIf

							//³ Chama a integracao com o SIGAPCO antes de apagar o titulo ³
							PcoDetLan("000002","01","FINA050",.T.)

							If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
								AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
							Endif

							//³ Exclui registros de rateio multiplas naturezas x centro de custo, no caso ³
							//³ do titulo provisorio possuir rateio.                                      ³
							If SE2->E2_MULTNAT == "1"
								FDelRatPR( "P" )
							EndIf

							FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
							Reclock("SE2",.F.,.T.)
							dbDelete()
							MsUnlock()

							nMaxTam := Len(aNtit)
							If Len(aGravaAFR) > 0 .And. (!AFR->(dbSeek(aGravaAFR[1]+aNtit[nMaxTam][1]+aNtit[nMaxTam][2]+aNtit[nMaxTam][3]+aNtit[nMaxTam][4]+aNtit[nMaxTam][5]+aNtit[nMaxTam][6])))
								RecLock("AFR",.T.)
								AFR->AFR_FILIAL	:= aGravaAFR[1]
								AFR->AFR_PROJET	:= aGravaAFR[2]
								AFR->AFR_REVISA	:= aGravaAFR[3]
								AFR->AFR_TAREFA	:= aGravaAFR[4]
								AFR->AFR_TIPOD		:= aGravaAFR[17]
								AFR->AFR_PREFIX	:= aNtit[nMaxTam][1]
								AFR->AFR_NUM		:= aNtit[nMaxTam][2]
								AFR->AFR_PARCEL	:= aNtit[nMaxTam][3]
								AFR->AFR_TIPO		:= aNtit[nMaxTam][4]
								AFR->AFR_FORNEC	:= aNtit[nMaxTam][5]
								AFR->AFR_LOJA		:= aNtit[nMaxTam][6]
								AFR->AFR_VENREA	:= aNtit[nMaxTam][7]
								AFR->AFR_VALOR1	:= aNtit[nMaxTam][8]
								AFR->AFR_VALOR2	:= aNtit[nMaxTam][9]
								AFR->AFR_VALOR3	:= aNtit[nMaxTam][10]
								AFR->AFR_VALOR4	:= aNtit[nMaxTam][11]
								AFR->AFR_VALOR5	:= aNtit[nMaxTam][12]

								aNtit[nMaxTam][14]:= .T.

								MsUnLock()
							EndIf


						Else
							//Processo novo (baixando o PR)
							// Titulo PR será baixado na substituicao automatica
							lMsErroAuto := .F.

							cPrefOri  := SE2->E2_PREFIXO
							cNumOri   := SE2->E2_NUM
							cParcOri  := SE2->E2_PARCELA
							cTipoOri  := SE2->E2_TIPO
							cCfOri    := SE2->E2_FORNECE
							cLojaOri  := SE2->E2_LOJA

							//Baixa Provisorio
							aVetor 	:= {{"E2_PREFIXO"	, SE2->E2_PREFIXO 		,Nil},;
							{"E2_NUM"		, SE2->E2_NUM       	,Nil},;
							{"E2_PARCELA"	, SE2->E2_PARCELA  		,Nil},;
							{"E2_TIPO"	    , SE2->E2_TIPO     		,Nil},;
							{"E2_FORNECE"	, SE2->E2_FORNECE  		,Nil},;
							{"E2_LOJA"	    , SE2->E2_LOJA     		,Nil},;
							{"AUTMOTBX"	    , "STP"             	,Nil},;
							{"AUTDTBAIXA"	, dDataBase				,Nil},;
							{"AUTDTDEB"		, dDataBase				,Nil},;
							{"AUTHIST"	    , "Baixa ref. substituicao de titulo Provisorio para Efetivo."	,Nil}}

							MSExecAuto({|x,y| Fina080(x,y)},aVetor,3)

							//Em caso de erro na baixa desarma a transacao
							If lMsErroAuto
								DisarmTransaction()
								MostraErro()
								Exit
							Else
								//³		Ponto de gravação dos campos da tabela auxiliar.		³
								dbselectarea("FII")
								cFIISeq	 := SE5->E5_SEQ

								FCriaFII("SE2", cPrefOri, cNumOri, cParcOri, cTipoOri, cCfOri, cLojaOri,;
								"SE2", cPrefDest, cNumDest, cParcDest, cTipoDest, cCfDest, cLojaDest,;
								cFilDest, cFIISeq )
							EndIf
						Endif
					EndIf
				Next nI
			Else
				//Automatica Antiga
				If ( lPadrao )
					//³ Prepara Lancamento Contabil                                      ³
					If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
						aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
					Endif
					nTotal += DetProva( nHdlPrv,;
					cPadrao,;
					"FINA050" /*cPrograma*/,;
					cLote,;
					/*nLinha*/,;
					/*lExecuta*/,;
					/*cCriterio*/,;
					/*lRateio*/,;
					/*cChaveBusca*/,;
					/*aCT5*/,;
					/*lPosiciona*/,;
					@aFlagCTB,;
					/*aTabRecOri*/,;
					/*aDadosProva*/ )
				EndIf
				dbSelectArea("SE2")
				dbGoto(nReg)
				If IntePms()
					//³ Atualizacao dos dados do Modulo SIGAPMS    ³
					lPrimeiro:= .T. //Wilson em 06/06/2011
					PmsWriteFI(2,"SE2")	//Estorno
					PmsWriteFI(3,"SE2")	//Exclusao
				EndIf

				//³ Chama a integracao com o SIGAPCO antes de apagar o titulo ³
				PcoDetLan("000002","01","FINA050",.T.)
				If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
					AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
				Endif
				//³ Exclui registros de rateio multiplas naturezas x centro de custo, no caso ³
				//³ do titulo provisorio possuir rateio.                                      ³
				If SE2->E2_MULTNAT == "1"
					FDelRatPR( "P" )
				EndIf

				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				If lDelProvis
					Reclock("SE2",.F.,.T.)
					dbDelete()
					MsUnlock()
				Else
					If (FindFunction( "FinSubNov" ),FinSubNov(),)
				Endif
			Endif

			//³ Finaliza a gravacao dos lancamentos do SIGAPCO          ³
			PcoFinLan("000002")

			//³ Contabiliza a diferenca               				  ³
			dbSelectArea("SE2")
			nRecSE2 := Recno()
			dbGoBottom()
			dbSkip()
			VALOR := (nValorS - nValorSe2)
			VLRINSTR := VALOR
			If nTotal > 0
				//³ Prepara Lancamento Contabil                                      ³
				//Contabiliza pela variavel VALOR. Nao necessita de controle de flag.
				nTotal += DetProva( nHdlPrv,;
				cPadrao,;
				"FINA050" /*cPrograma*/,;
				cLote,;
				/*nLinha*/,;
				/*lExecuta*/,;
				/*cCriterio*/,;
				/*lRateio*/,;
				/*cChaveBusca*/,;
				/*aCT5*/,;
				/*lPosiciona*/,;
				/*@aFlagCTB*/,;
				/*aTabRecOri*/,;
				/*aDadosProva*/ )
			Endif
			dbSelectArea("SE2")
			dbGoTo(nRecSE2)
			If nTotal > 0
				//³ Envia para Lancamento Contabil							  ³
				If  UsaSeqCor()
					aDiario := {}
					aDiario := {{"SE2",SE2->(recno()),SE2->E2_DIACTB,"E2_NODIA","E2_DIACTB"}}
				Else
					aDiario := {}
				EndIf
				//³ Efetiva Lan‡amento Contabil                                      ³
				RodaProva( nHdlPrv,;
				nTotal )
				cA100Incl( cArquivo,;
				nHdlPrv,;
				3 /*nOpcx*/,;
				cLote,;
				( mv_par01 == 1 ) /*lDigita*/,;
				( mv_par07 == 1 ) /*lAglut*/,;
				/*cOnLine*/,;
				/*dData*/,;
				/*dReproc*/,;
				@aFlagCTB,;
				/*aDadosProva*/,;
				aDiario )
				aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento
			EndIf
		EndIf

	END TRANSACTION

Endif

If !Empty(aChaveLbn)
	aEval(aChaveLbn, {|e| UnLockByName(e,.T.,.F.) } ) // Libera Lock
Endif

VALOR    := 0
VLSINSTR := 0
If Select("__SUBS") > 0
	dbSelectArea("__SUBS")
	dbCloseArea()
	Ferase(cIndex+OrdBagExt())
Endif
dbSelectArea("SE2")
If ! lF050Auto
	RetIndex("SE2")
	dbGoto(nReg)
	//³Ponto de entrada que permite que a classificacao a ser   ³
	//³apresentada na Grid com os titulos provisorios possa ser ³
	//³alterada. Eh passado o indice corrente, o retorno deve   ³
	//³ser o indice da tabela SE2 determinado pelo usuario.     ³
	//³FNC : 00000010532/2009									³
	If lFA050SCL
		nPosInd := 0
		cChave := ExecBlock("FA050SCL",.F.,.F.,{SE2->(IndexOrd())})
		If !Empty(cChave)
			If ValType(cChave) # "C"
				cChave := Str(cChave)
			Endif
			cChave := Substr(LTrim(cChave),1,1)
			//Tratamento para indice numerico
			If cChave $ "1234567890"
				nPosInd := Val(cChave)
			Else
				//Tratamento para indice hexadecimal
				If (nPosInd := At(cChave,"ABCDEFGHIJKLMNOPQRSTUVXYWZ")) # 0
					nPosInd += 9
				Endif
			Endif
		Endif
		If nPosInd > 0
			cChave := SE2->(IndexKey(nPosInd))
			//Caso a chave seja invalida, utilizar a padrao
			If Empty(cChave)
				cChave := SE2->(IndexKey())
			Endif
		Else
			cChave := SE2->(IndexKey())
		Endif
	Else
		cChave := IndexKey()
	Endif

	//³ Apaga o sem foro                                             ³
	fclose(nHdlLock)
	Ferase("FINA050.LCK")
Endif

RestArea(aAreaSE2)
Return

/*/
±±³Fun‡…o	 ³fa050LinOk³ Autor ³ Wagner Xavier 		  ³ Data ³ 18/05/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Analisa a linha digitada 											  ³±±
/*/
Function FA050LinOK()
Local lRet := .T.
Local lF050LRat := ExistBlock("F050LRAT") // Validar a inclusao da linha do rateio on-line

// Se existir o PE F050LRAT, utiliza o retorno do PE para validar a linha
If lF050LRat
	lRet := ExecBlock("F050LRAT", .F., .F. )
Endif

Return lRet

/*/
±±³Fun‡…o	 ³fa050TudOk³ Autor ³ Wagner Xavier 		  ³ Data ³ 18/05/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Analisa a tela digitada												  ³±±
/*/
Function FA050TudOK(cPrograma)
LOCAL n,lRet := .T.
LOCAL nValorRat := 0
Local nInss := 0
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)
Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"

If !lInssBx
	If cPrograma == "FINA050"
		nInss := M->E2_INSS
		IF SED->ED_DEDINSS == "2"  //desconta o INSS do principal
			nInss := 0
		Endif
	EndIf
Endif

FOR n:=1 TO LEN(aCOLS)
	If !aCOLS[n][nUsado+1]		// SE n„o ‚ deletado
		nValorRat += aCols[n][5]
	Endif
NEXT n

If lF050RAT
	lRet := ExecBlock("F050RAT",.F.,.F.)
	Return lRet
EndIf

IF Str( nValorRat,17,2 ) != IIF(cPrograma == "FINA050",;
Str(IIF(mv_par06==1,;
SE2->(E2_VALOR+If(lIRPFBaixa,0,E2_IRRF)+If(!lCalcIssBx,E2_ISS,0)+E2_RETENC+E2_SEST+IIF(lPccBaixa,0,E2_PIS+E2_COFINS+E2_CSLL))+nInss,;
SE2->E2_VALOR),17,2 ),Str( SE5->E5_VALOR,17,2 ))
	Help( " ", 1, "FA050RATEI")
	lRet := .F.
Endif

If UsaSeqCor()
	If !CTBvldDiario(M->E1_DIACTB,dDataBase)
		Return(.F.)
	EndIf
EndIf

Return lRet

/*/
±±³Fun‡…o	 ³FA050Herda³ Autor ³ Valter G. Nogueira Jr.³ Data ³ 17/02/94 			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³±±
±±³Descricao ³ Herda os dados do titulo original 									³±±
±±³Campos:   ³E2_PREFIXO;E2_NUM;E2_PARCELA;E2_NATUREZ;E2_FORNECE;E2_LOJA;E2_NOMFOR; ³±±
±±³	 	     ³E2_EMISSAO;E2_VENCTO;E2_VENCREA;E2_HISTORICO;E2_PORTADO;E2_MOEDA		³±±
±±³			 ³																		³±±
±±³	lTdOk    ³ Caso Venha da inclusão de um titulo AB- deve ser True				³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³±±
/*/
STATIC Function FA050Herda(lTdOk)

LOCAL cAlias := Alias()
LOCAL i
LOCAL cCampo
Default	lTdOk := .F.

dbSelectArea("SE2")

//³ Recupera os dados do titulo original								  ³
FOR i := 1 TO FCount()
	cCampo := Field(i)
	if lTdOk //Inclusão de Titulo AB-, não se deve herdar Natureza e Historico
		If cCampo$"E2_PREFIXO;E2_NUM;E2_PARCELA;E2_FORNECE;E2_LOJA;E2_NOMFOR" .or.;
			cCampo$"E2_EMISSAO;E2_VENCTO;E2_VENCREA;E2_PORTADO;E2_MOEDA"
			m->&cCampo := FieldGet(i)
		EndIf
	Else // Herdando todos os campos de outra função generica.
		If cCampo$"E2_PREFIXO;E2_NUM;E2_PARCELA;E2_NATUREZ;E2_FORNECE;E2_LOJA;E2_NOMFOR" .or.;
			cCampo$"E2_EMISSAO;E2_VENCTO;E2_VENCREA;E2_HISTORICO;E2_PORTADO;E2_MOEDA"
			m->&cCampo := FieldGet(i)
		EndIf
	Endif
NEXT i
lRefresh := .T.

dbSelectArea(cAlias)

Return

/*/
±±³Fun‡…o	 ³FA050Irf	³ Autor ³ Antonio Maniero Jr.   ³ Data ³ 11/04/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calcula Irf em cruzeiros 											  ³±±
/*/
Function FA050Irf()

Local lAplicaTP := .T.
Local nBaseIrrf := m->e2_valor

//-- Optante pelo simples
Local lSimples := cPaisLoc == "BRA" .and. SA2->A2_CALCIRF == "3"

//-- Empresa Individual
Local lEmprInd := cPaisLoc == "BRA" .and. SA2->A2_CALCIRF == "4"

// Carrega variavel de verificacao de consideracao de valor minimo de retencao de IR.
Local lAplMinIR := .F.

//Base Impostos diferenciada
Local lBaseImp	 	:= F050BSIMP(2)

//Valor retido
Local lVretIrf		:= .T.
// ignora recalculo de impostos  | Usado pelo TMS com Operadora de Frota
Local lRefImp	:= SuperGetMv('MV_REFIMP',,.F.)
Local lTmsOper	:= SuperGetMv('MV_VSREPOM',,'1')  == '2' .And. SuperGetMv('MV_TMSOPDG',,'1')  == '2'

If lRefImp  .And. lTmsOper .And. (FwIsInCallStack('TMSQUITAC') .Or. FwIsInCallStack('TMA250SE2'))
	lBaseImp := .F.
EndIf

M->E2_IRRF	:= 0
nOldIrr		:= 0

If SED->ED_CALCIRF == "S" .And. M->E2_MULTNAT != "1"

	If lF050ATP
		lAplicaTP := ExecBlock("F050ATP",.F.,.F.)
	Endif

	//Base Impostos diferenciada
	If lBaseImp .and. M->E2_BASEIRF > 0
		nBaseIrrf   := M->E2_BASEIRF
	Endif


	IF (SA2->A2_TIPO == "F" .OR. (SA2->A2_TIPO == "J" .AND. lIrProg == "1")) .AND. lAplicaTP .AND. !lEmprInd
		If lIRPFBaixa
			If M->E2_TIPO $ MVPAGANT
				//³Busca base de cálculo para o  IRPF ³
				//³caso não tenha sido calculada      ³
				aCalcIRPF := F241BsIRPF(,"SE2",M->E2_VALOR,,M->E2_FORNECE,M->E2_LOJA)

				//³Calcula IRPF e deduz os valores retidos anteriormente³
				M->E2_IRRF := Fa050TabIR(aCalcIRPF[1]) - aCalcIRPF[2]
				M->E2_IRRF := IIF(M->E2_IRRF <= GetMv("MV_VLRETIR",,0),0,M->E2_IRRF)

				If M->E2_TIPO $ MVPAGANT .And. lVretIrf
					M->E2_VRETIRF := M->E2_IRRF
				EndIf

			EndIf

		Else

			M->E2_IRRF := FCalcIr(nBaseIrrf,"F",.T.)

		EndIf

	ElseIf !lSimples
		If lIRPFBaixa
			M->E2_IRRF := FClcIRPJ(nBaseIrrf,.T.,.T.)
			If M->E2_TIPO $ MVPAGANT .And. lVretIrf
				M->E2_VRETIRF := M->E2_IRRF
			EndIf
		Else
			M->E2_IRRF := FCalcIr(nBaseIrrf,"J",.T.)
		EndIf
	EndiF
	IF lF050CIRF

		M->E2_IRRF := ExecBlock("F050CIRF",.f.,.f.,nBaseIrrf)

	Endif
EndIf

// Verifica se o fornecedor trata o valor minimo de retencao.
// 1 - Não considera  2 - Considera o parâmetro MV_VLRETIR
If cPaisLoc == "BRA" .and. SA2->A2_MINIRF == "2"
	lAplMinIR := .T.
Endif

If !(lIRPFBaixa .And. M->E2_TIPO $ MVPAGANT) .And. If(lAplMinIR,(M->E2_IRRF <= GetMv("MV_VLRETIR")),.F.)
	nIrrfAnt := M->E2_IRRF
	M->E2_IRRF := 0
EndIf

lRefresh:=.t.

Return .t.

/*/
±±³Fun‡…o	 ³FA050blank³ Autor ³ Wagner Xavier 		  ³ Data ³ 08/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Limpa as marcacoes do arquivo (E2_OK)							  ³±±
/*/
Function fa050DesMarca(aChaveLbn)
LOCAL lSavTTS
Local nRec
Local cChaveLbn


lSavTTS := __TTSInUse
__TTSInUse := .F.

nRec := __SUBS->(Recno())
While __SUBS->(!Eof())
	cChaveLbn := "SUBS" + xFilial("SE2")+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
	If LockByName(cChaveLbn,.T.,.F.)
		If Reclock("__SUBS",.F.)
			__SUBS->E2_OK := "  "
			__SUBS->(MsUnlock())
		Endif
		__SUBS->(MsUnlock())
		UnLockByName(cChaveLbn,.T.,.F.) // Libera Lock
	Endif
	__SUBS->(dbSkip())
End
__SUBS->(dbGoto(nRec))

__TTSInUse := lSavTTS

Return Nil

/*/
±±³Fun‡„o	 ³FA050Alter³ Autor ³ Wagner Xavier 		  ³ Data ³ 27/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Programa para altera‡„o de contas a pagar 					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ FA050Alter(ExpC1,ExpN1,ExpN2) 									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo											  ³±±
±±³			 ³ ExpN1 = N£mero do registro 										  ³±±
±±³			 ³ ExpN2 = N£mero da op‡„o selecionada 							  ³±±
/*/
Function FA050Alter(cAlias,nReg,nOpc)

Local lPanelFin := IsPanelFin()
LOCAL nOpca
LOCAL aCpos
LOCAL cParcela 	:= E2_PARCELA
LOCAL K
LOCAL aUsers 		:= {}
LOCAL nIndex	 	:= SE2->(IndexOrd())
Local cTudoOK := Nil
Local aBut050		:= {}
Local dDataFim  := LastDay( ddatabase )
Local lContrRet := .T.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local lIRPFBaixa := .F.
Local aArea := GetArea()
Local nInss := SE2->E2_INSS
Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local lJustCP := CposJust()
//Verifica se os campos utilizados para o imposto CIDE.
Local lCIDE  := cPaisLoc == "BRA"
Local nVlMinImp := GetNewPar("MV_VL10925",5000)
Local nVlr_Rtd_Tot := 0
Local cDirfImp := ""
Local cDirfPai := ""
Local lFoundTx := .F.

Local cLojaImp := PadR( "00", TamSX3("A2_LOJA")[1], "0" )
Local aCRets 	:= {}
Local lRatPrj	:=.T.//indica se existe rateio de projetos
Local lInssBx := SuperGetMv("MV_INSBXCP",.F.,"2") == "1"

Local cE2NATUREZ := Alltrim(SE2->E2_NATUREZ)
Local cE2VENCTO  := DTOC(SE2->E2_VENCTO)
Local cE2VENCREA := DTOC(SE2->E2_VENCREA)
Local cE2VALOR   := Alltrim(Transform(SE2->E2_VALOR,PesqPict("SE2","E2_VALOR")))
Local cE2DECRESC := Alltrim(Transform(SE2->E2_DECRESC,PesqPict("SE2","E2_DECRESC")))
Local cE2ACRESC  := Alltrim(Transform(SE2->E2_ACRESC,PesqPict("SE2","E2_ACRESC")))
Local cE2VALJUR  := Alltrim(Transform(SE2->E2_VALJUR,PesqPict("SE2","E2_VALJUR")))
Local cE2PORCJUR := Alltrim(Transform(SE2->E2_PORCJUR,PesqPict("SE2","E2_PORCJUR")))
Local cE2HIST    := Alltrim(SE2->E2_HIST)
Local aAlt       := {}
Local cKeySE2 	 := SE2->(indexkey())
Local nRecSE2 	 := SE2->(Recno())
Local lFA050ALT  := ExistBlock("FA050ALT")
Local lF050ALT	 := ExistBlock("F050ALT")
Local lAltPA     := .F.
Local cTxDirf	 := ""

Private aHeader := {}, aCols := {}, aRegs := {}

Private cParcIr
Private cFunct		:= ""
Private cParcIss

PRIVATE dOldVencRe	:= SE2->E2_VENCREA
PRIVATE nOldVlCruz	:= SE2->E2_VLCRUZ
PRIVATE dEmissao 	:= SE2->E2_EMISSAO
PRIVATE lFirstAlt := .T.
//³ A variavel abaixo ira guardar valor da ultima alteracao em tela. Serve	³
//³ p/ evitar erro na reconstituicao do valor qdoe, numa 2¦ ou n¦ altera-	³
//³ cao, o valor do INSS for zerado.													³
PRIVATE nVlAltInss	:= 0
PRIVATE nVlAltSEST   := 0

PRIVATE aRatAFR		:= {}
PRIVATE bPMSDlgFI	:= {||PmsDlgFI(4,M->E2_PREFIXO,M->E2_NUM,M->E2_PARCELA,M->E2_TIPO,M->E2_FORNECE,M->E2_LOJA)}
PRIVATE aAutRatAFR	:= {}

PRIVATE nOldVlAcres  := SE2->E2_ACRESC
PRIVATE nOldVlDecres := SE2->E2_DECRESC

PRIVATE cModRetPIS := GetNewPar( "MV_RT10925", "1" )
PRIVATE nIndexSE2  := ""
PRIVATE aDadosRet  := Array(5)
PRIVATE cIndexSE2  := ""
PRIVATE lAlterNat  := .F.
Private nVlrOri    := SE2->E2_VALOR
Private nPisOri    := SE2->E2_PIS
Private nCofOri    := SE2->E2_COFINS
Private nCslOri    := SE2->E2_CSLL
Private nIrfOri    := SE2->E2_IRRF
Private nISSOri    := SE2->E2_ISS
Private nBtrISSOri := 0
Private nPisInter  := SE2->E2_PIS
Private nCofInter  := SE2->E2_COFINS
Private nCslInter  := SE2->E2_CSLL

Private cOldNaturez := SE2->E2_NATUREZ
Private cOldNatPFS  := SE2->E2_NATUREZ
Private aCposAlter  := {}
Private _Opc := nOpc
Private aSE2FI2		:=	{} // Utilizada para gravacao das justificativas

PRIVATE lAltValor 	:= .F.
PRIVATE lTitRetA 	:= .F.
Private lAlteraTit  := .F. //DFS - 06/08/13 - Inclusão de flag para permitir apenas alterar o vencimento da Nota Fiscal gerada a partir do módulo EIC
Private aCposEIC    := {}  //LGS - 18/05/16 - Utilizado no tratamento de validações para titulos originados pelo sigaeic
// Utilizado para avaliar alteração *
// no vencimento real               *
Private dVencReaAnt	:= SE2->E2_VENCREA

// Utilizado para armazemar valor *
// alterado na tela de alteração  *
Private cDirfAlt

SE2->(DbSetOrder(nIndex))
If !(SE2->(MsSeek(SE2->(&(cKeySE2)))))
	Help(" ",1,"ARQVAZIO")
	Return .T.
Else
	SE2->(dbGoto(nRecSE2))
Endif

If lBtrISS
	nBtrISSOri := SE2->E2_BTRISS
EndIf

SA2->(dbSetOrder(1))
SA2->(MSSeek(xFilial("SA2")+SE2->(E2_FORNECE+E2_LOJA)))

//Motor de retenções,verifica quais impostos estão configurados
If lTemMR
	F050ImpCon(4)
EndIf

lIRProg := IIf(cPaisLoc == "BRA",IIf(!Empty(SA2->A2_IRPROG),SA2->A2_IRPROG,"2"),"2")

lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)

lF050Auto   := IF(Type("lF050Auto") == "U", .F., lF050Auto)

//Permite rateio de Múltiplas natureza
lRatMulNat := MV_MULNATP .And. Empty(SE2->E2_BAIXA) .And. AllTrim(SE2->E2_LA) <> "S" .And.;
SE2->(E2_VALOR == E2_SALDO) .And. Alltrim(SE2->E2_ORIGEM) <> "MATA100"

If !lInssBx
	IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
		nInss := 0
	Endif
Endif

//Verifica se o título gera ou nao DIRF, buscando essa informação nos TXs.
If cPaisLoc == "BRA" .And. !(Alltrim(SE2->E2_TIPO) $ MVTAXA+"|"+MVTXA)
	nRecno   := SE2->(Recno())
	cChave   := SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM
	cDirfPai := SE2->E2_DIRF
	cTxDirf := If(lAltPa,MVTXA,MVTAXA)

	dbSeek(SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM,.T.)
	Do While !EOF() .And. SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM == cChave
		If Alltrim(SE2->E2_TIPO) == cTxDirf .And. Alltrim(SE2->E2_NATUREZ) $ "IRF/PIS/COFINS/CSLL"
			cDirfImp := SE2->E2_DIRF
			Exit
		Endif
		dbSkip()
	Enddo
	SE2->(dbGoto(nRecno))
	cDirfImp := If(AllTrim(cDirfImp) <> "", cDirfImp, cDirfPai)
	//Atualizo o campo E2_DIRF com o valor preenchido inicialmente, somente para a tela de alteração.
	If SE2->E2_DIRF<>cDirfImp
		RecLock("SE2",.F.)
		SE2->E2_DIRF := cDirfImp
		MsUnlock()
	EndIf
Endif

// Codigo de retenção anterior para IN4815
cOldCodRet	:= SE2->E2_CODRET
nOldIrrf 	:= SE2->E2_IRRF
nOldIssInt 	:= SE2->E2_ISS
nOldValor	:= SE2->E2_VALOR
nOldSaldo	:= SE2->E2_SALDO
nOldIns	 	:= SE2->E2_INSS
nOldSES     := SE2->E2_SEST
nValorAnt 	:= SE2->E2_VALOR
If lCIDE
	nOldCID		:= SE2->E2_CIDE
EndIf
nOldPisAnt	:= SE2->E2_PIS
nOldCofAnt	:= SE2->E2_COFINS
nOldCslAnt	:= SE2->E2_CSLL
If !lF050Auto
	aDadosRet := Array(5)
	nVlRetPis	:= 0
	nVlRetCof	:= 0
	nVlRetCsl	:= 0
	Afill(aDadosRet,0)
Endif

//Se controla Retencao
If lContrRet .and. !lPccBaixa
	nOldPisAnt := IIF(Empty(SE2->E2_VRETPIS), SE2->E2_PIS , SE2->E2_VRETPIS )
	nOldCofAnt := IIF(Empty(SE2->E2_VRETCOF), SE2->E2_COFINS , SE2->E2_VRETCOF )
	nOldCslAnt := IIF(Empty(SE2->E2_VRETCSL), SE2->E2_CSLL , SE2->E2_VRETCSL )
Endif

// Grava o valor que realmente foi retido nos campos do PCC  *
// para ser apresentado na tela do AxAltera e não afetar os  *
// titulos de PCC gerados na emissão.                        *
If cPaisLoc=="BRA" .and. lContrRet .and. !lPccBaixa .and. !lAlterNat
	//Gravo temporariamente do PIS/Cofins/Csll.
	RECLOCK("SE2",.F.,,.T.)
	SE2->E2_PIS := nOldPisAnt
	SE2->E2_COFINS := nOldCofAnt
	SE2->E2_CSLL := nOldCslAnt
	MsUnlock()
EndIf

//Botoes adicionais na EnchoiceBar

aBut050 := fa050BAR('IntePms()')

//inclusao do botao Posicao
AADD(aBut050, {"HISTORIC", {|| Fc050Con() }, STR0204}) //"Posicao"

//inclusao do botao Rastreamento
AADD(aBut050, {"HISTORIC", {|| Fin250Pag(2) }, STR0205}) //"Rastreamento"

If lJustCP // Adiciona botao para justificativa
	Aadd(aBut050,{'BAIXATIT',{||Fa050JUST()},STR0134})		//"Justificativa"
Endif

If lIntPFS .And. FindFunction("JURA246") .And. !(SE2->E2_TIPO $ MVTAXA+"|"+MVINSS+"|"+MVISS+"|"+MVTXA+"|SES|INA|IRF|PIS|COF|CSL")
	Aadd(aBut050,{"", {|| JURA246(4) }, STR0296}) //"Detalhe / Desdobramentos" (Modulo SIGAPFS)
EndIf

// Somente permite a alteracao de multiplas naturezas para titulo digitados
If ((SE2->E2_MULTNAT == "1" .And. Alltrim(SE2->E2_ORIGEM) <> "MATA100") .OR. lRatMulNat) .And.;
	SE2->E2_FORNECE + SE2->E2_LOJA # GetMV("MV_UNIAO"  ) + Space(Len(SE2->E2_FORNECE) - Len(GetMV("MV_UNIAO"  ))) + cLojaImp .And.;
	SE2->E2_FORNECE + SE2->E2_LOJA # GetMV("MV_FORINSS") + Space(Len(SE2->E2_FORNECE) - Len(GetMV("MV_FORINSS"))) + cLojaImp .And.;
	SE2->E2_FORNECE + SE2->E2_LOJA # GetMV("MV_MUNIC"  ) + Space(Len(SE2->E2_FORNECE) - Len(GetMV("MV_MUNIC"  ))) + cLojaImp

	Aadd(aBut050, {'S4WB013N',;
	{||	MultNat(	"SE2",;
	0 /*@nHdlPrv*/,;
	M->E2_VALOR /*@nTotal*/,;
	"", /*@cArquivo*/;
	.F. /*lContabiliza*/,;
	If( SE2->E2_LA != "S", 4, 2 ) /*nOpc*/,;
	If(	/*lExpr*/	mv_par06==1,;
	/*T*/	If(	lPccBaixa .Or. ( lIRPFBaixa .And. ! M->E2_TIPO $ MVPAGANT ),;
	0,;
	M->E2_IRRF ) +;
	If( !lCalcIssBx, M->E2_ISS, 0 ) +;
	nInss +;
	M->E2_RETENC +;
	M->E2_SEST +;
	If( lPccBaixa, 0, E2_PIS + E2_COFINS + E2_CSLL ),;
	/*F*/	0 ) /*nImpostos*/,;
	mv_par10 = 2 .And. mv_par06 = 2 /*lRatImpostos*/,;
	aHeader /*acolsM*/,;
	aCols /*aHeaderM*/,;
	aRegs /*aRegs*/,;
	.F. /*lGrava*/,;
	/*lMostraTela*/,;
	/*lRotAuto*/,;
	/*lUdaFlag*/,;
	/*@aFlagCTB*/) },;
	STR0116 /*Rateio das Naturezas do titulo*/,;
	STR0123 /*Rateio*/ } )
Endif

If SE2->( EOF()) .or. xFilial("SE2") # SE2->E2_FILIAL
	Help(" ",1,"ARQVAZIO")
	Return .T.
Endif

///Projeto
//³ Verifica campos do usuario      			  ³
dbSelectArea("SX3")
dbSetOrder(1)
dbSeek("SE2")

While !Eof() .and. X3_ARQUIVO == "SE2"
	If SX3->X3_PROPRI == "U"
		Aadd(aUsers,SX3->X3_CAMPO)
	Endif
	dbSkip()
Enddo

// Validação Siafi
If FinTemDH()
	Return .T.
Endif

//Se veio atraves da integracao Protheus X Tin nao Pode ser alterado
If (!Type("lF050Auto") == "L" .Or. !lF050Auto) .and.  Upper(AllTrim(SE2->E2_ORIGEM))=="FINI055"
	HELP(" ",1,"ProtheusXTIN",,STR0213,2,0)//"Título gerado pela Integração Protheus X Tin não Pode ser alterado pelo Protheus"
	Return
Endif

//³ AAF - Titulos originados no SIGAEFF não devem ser alterados   ³
If !lF050Auto .AND. "SIGAEFF" $ SE2->E2_ORIGEM
	Help(" ",1,"FAORIEFF")
	Return
EndIf

//verifica se e titulo originado do SIGAPLS e nao deixa alterar.
if lPLSFN050 .and. ! lF050Auto .and. PLSFN050(nOpc)
    return(.f.)
endIf

// DFS - 16/03/11 - Deve-se verificar se os títulos foram gerados por módulos Trade-Easy, antes de apresentar a mensagem.
// TDF - 26/12/11 - Acrescentado o módulo EFF para permitir liquidação
// NCF - 25/03/13 - Acrescentado o módulo SIGAESS (Siscoserv)
If (UPPER(Alltrim(SE2->E2_ORIGEM)) $ "SIGAEEC/SIGAEIC/SIGAEDC/SIGAECO/SIGAESS" .OR.;
(!(Left(Alltrim(SE2->E2_ORIGEM),3) == 'FIN') .And. SE2->E2_PREFIXO == 'EIC')) .AND. !(cModulo $ "EEC/EIC/EDC/ECO/EFF/ESS")

	If FindFunction("EasyOrigem")
		If F050EasyOrig(AllTrim(SE2->E2_ORIGEM))
			If lAlteraTit
				aCpos := aClone( aCposEIC )
			Else
				Return
			EndIf
		EndIf
	Else
		If Posicione("SA2",1,xFilial("SA2")+SE2->(E2_FORNECE+E2_LOJA),"A2_PAIS") <> "105" .AND. SE2->E2_MOEDA > 1
			F050Help()
			HELP(" ",1,"FAORIEEC")
			Return
			// GFP - 07/03/2014 - Tratamento para liberar os campos que são permitidos para alteração, com exceção daqueles utilizados pelos módulos de Comercio Exterior.
		ElseIf UPPER(Alltrim(SE2->E2_TIPO)) == "NF" .AND. SE2->E2_MOEDA == 1
			aCpos := fa050MCpo(4)
			If (nPos := aScan(aCpos, "E2_VENCREA")) # 0
				ADEL(aCpos,nPos)
				ASIZE(aCpos,LEN(aCpos)-1)
			EndIf
			If (nPos := aScan(aCpos, "E2_VALOR")) # 0
				ADEL(aCpos,nPos)
				ASIZE(aCpos,LEN(aCpos)-1)
			EndIf
			If (nPos := aScan(aCpos, "E2_VLCRUZ")) # 0
				ADEL(aCpos,nPos)
				ASIZE(aCpos,LEN(aCpos)-1)
			EndIf
			lAlteraTit := .T.
		Else
			F050Help()
			HELP(" ",1,"FAORIEEC")
			Return
		EndIf
	EndIf
Endif

//³ Caso titulo esteja num bordero nao pode sofrer alteracao	³
If !Empty(SE2->E2_NUMBOR)
	Help(" ",1,"F050BORD",,STR0099+CHR(13)+STR0100,1,0)
	Return
EndIf

//³ Verifica se o titulo esta bloqueado  ³
If !Empty(SE2->(FieldPos("E2_MSBLQL"))) .And. SE2->E2_MSBLQL == "1" .And. lVerifyBlq .and. UPPER(Alltrim(SE2->E2_ORIGEM)) $ "CNTA090/CNTA100/CNTA120/CNTA121"
	Help(" ",1,"SE2BLOQ")
	Return
EndIf

//³ Verifica se data do movimento n„o ‚ menor que data limite de ³
//³ movimentacao no financeiro    								 ³
If !DtMovFin(,,"1")
	Return
Endif

nOldIRR 	:= SE2->E2_IRRF
nOldISS 	:= SE2->E2_ISS
If lBtrISS
	nOldBtrISS := SE2->E2_BTRISS
EndIf
nOldInss	:= SE2->E2_INSS
nOldSEST	:= SE2->E2_SEST
If lCIDE
	nOldCID  := SE2->E2_CIDE
EndIf

// Se existir os campos de impostos a pagar, PIS, COFINS, CSLL - MP 135
If !lPccBaixa
	nOldPis	   := SE2->E2_PIS
	nOldCofins := SE2->E2_COFINS
	nOldCsll   := SE2->E2_CSLL
Endif
//³ Atencao para criar o array aCpos                    ³
cParcIss	 := If(Empty(SE2->E2_PARCISS),cParcela,SE2->E2_PARCISS)
cParcIr	 := If(Empty(SE2->E2_PARCIR ),cParcela,SE2->E2_PARCIR )
cParcInss := If(Empty(SE2->E2_PARCINS),cParcela,SE2->E2_PARCINS)
cParcSEST := If(Empty(SE2->E2_PARCSES),cParcela,SE2->E2_PARCSES)
If lCIDE
	cParcCIDE := If(Empty(SE2->E2_PARCCID),cParcela,SE2->E2_PARCCID)
EndIf

//Monta campos para usuario
//DFS - 06/08/13 - Caso não seja alteração de título gerado pelo EIC, pode incluir os outros campos para alteração
If !lAlteraTit
	aCpos := fa050MCpo(4)
EndIf
If aCpos == Nil
	return
EndIf

//³ Caso seja um PA, somente permite alterar o historico e campos de usuario
If SE2->E2_TIPO $ MVPAGANT .And. F050MovBco()
	lAltPA := .T.
	aCpos := {"E2_HIST"}
EndIf

aCposAlter := aClone( aCpos )

//³ Preenche campos alter veis (usu rio)       ³
If Len(aUsers) > 0
	FOR k:=1 TO Len(aUsers)
		Aadd(aCpos,Alltrim(aUsers[k]))
	NEXT k
EndIf

lAltera := .T.

dbSelectArea("SA2")
dbSeek(cFilial+SE2->E2_FORNECE+SE2->E2_LOJA)

dbSelectArea( cAlias )
dbSetOrder(1)

IF lFA050UPD
	//³ Ponto de Entrada para Pre-Validacao de Alteracao    ³
	IF !ExecBlock("FA050UPD",.f.,.f.)
		Return .F.
	Endif
Endif

// integração com o PMS
If IntePMS()
	SetKey(VK_F10, {|| Eval(bPMSDlgFI)})
EndIf

cTudoOk := 'Iif(Len(aSE2FI2)==0,Fa050JUST(),.T.) .And. F050PcoLan() '
If !lF050Auto
	cTudoOk += ' .And. If(M->E2_TEMDOCS == "1",CN062NecDocs(),.T.) ' //Documentos
EndIf

IF lFA050ALT
	cTudoOK += ' .and. ExecBlock("FA050ALT",.f.,.f.)'
Endif
If  IntePMS() .and. (nPosAFR:=AScan(aAutocab,{|x|AllTrim(x[1])=="AUTRATAFR"})) >0 //rateio automatico de projetos
	aAutoAFR:=aClone(aAutoCab[nPosAFR][2])
	cTudoOk+=' .and. F050AutAFR('+Str(nOpc,2)+') '
Endif

cTudoOK += ' .And. F050VldVlr() '

If FindFunction("JurValidCP") .And. lIntPFS
	cTudoOK += ' .And. JurValidCP(4) '
EndIf

Afill(aDadosRet,0)
//Controle de retencao do PIS/Cofins/CSLL
If cPaisLoc=="BRA" .and. lContrRet .and. !lPccBaixa .and. !lAltPA

	If (SE2->E2_PRETPIS == "1" .or. SE2->E2_PRETCOF == "1" .or. SE2->E2_PRETCSL == "1" )
		nOldPis := 0
		nOldCofins := 0
		nOldCsll := 0
	Else
		nOldPis := IIF(Empty(SE2->E2_VRETPIS), SE2->E2_PIS , SE2->E2_VRETPIS )
		nOldCofins := IIF(Empty(SE2->E2_VRETCOF), SE2->E2_COFINS , SE2->E2_VRETCOF )
		nOldCsll := IIF(Empty(SE2->E2_VRETCSL), SE2->E2_CSLL , SE2->E2_VRETCSL )
	Endif

	//Apresento o botao de retencao apenas se existir possibilidade de alteracao do valor
	If (nPos := Ascan(aCpos,{ |x| x == "E2_VALOR" } )) > 0
		Aadd(aBut050,{"NOTE",{||F050CalcRt()},STR0125,STR0126})  //"Modalidade de Retenção Pis/Cofins/Csll"###"Impostos"
	Endif
EndIf

///Projeto
//³ Inicializa a gravacao dos lancamentos do SIGAPCO          ³
PcoIniLan("000002")

If lAltPA
	cFunct :=""
	aBut050 := {}
Else
	cFunct :="FA050AXALT('"+cAlias+"','"+cParcIss+"','"+cParcIr+"','"+cParcInss+"','"+cParcSEST+"')"
EndIf

Begin Transaction
	nVlrMR    := 0 
	If !Type("lF050Auto") == "L" .or. !lF050Auto
		If lPanelFin  //Chamado pelo Painel Financeiro
			dbSelectArea("SE2")
			RegToMemory("SE2",.F.,.F.,.F.,FunName())
			nValDig := M->E2_VALOR	// Carrega o valor do titulo para nao zerar variavel de memoria no uso de gatilho
			oPanelDados := FinWindow:GetVisPanel()
			oPanelDados:FreeChildren()
			aDim := DLGinPANEL(oPanelDados)
			nOpca := AxAltera(cAlias,nReg,nOpc,,aCpos,4,SA2->A2_NOME,cTudoOk,cFunct,,aBut050,/*aParam*/,/*aAuto*/,/*lVirtual*/,/*lMaximized*/,/*cTela*/,.T.,oPanelDados,aDim,FinWindow)

		Else
			RegToMemory("SE2",.F.,.F.,.F.,FunName()) // incluido Eduardo
			nValDig := M->E2_VALOR	// Carrega o valor do titulo para nao zerar variavel de memoria no uso de gatilho
			nOpca := AxAltera(cAlias,nReg,nOpc,,aCpos,4,SA2->A2_NOME,cTudoOk,cFunct,,aBut050)
		Endif
	Else
		RegToMemory("SE2",.F.,.F.)
		nValDig := M->E2_VALOR
		If EnchAuto(cAlias,aAutoCab,cTudoOk,nOpc)
			// Apenas valida impostos caso alteração dos campos abaixo.
			If aScan(aAutoCab,{|x| Alltrim(x[1]) $ "E2_TIPO|E2_NATUREZ|E2_FORNECE|E2_EMISSAO|E2_VALOR|E2_MOEDA"}) > 0
				Fa050Natur()
			ElseIf aScan(aAutoCab,{|x| Alltrim(x[1]) $ "E2_VENCTO|E2_VENCREA"}) > 0
				FA050Venc()
			EndIf
			nOpcA := AxIncluiAuto(cAlias,,cFunct,4,SE2->(RecNo()))
		EndIf
	EndIf

	IF lF050ALT .and. !lAltPA
		//³ Ponto de Entrada para Valida‡Æo pos-Confirma‡Æo de Alteracao  ³
		ExecBlock("F050ALT",.f.,.f.,{nOpca})
	Endif

	If nOpca == 1 //verifica se houve alterações, para geração do log de alterações

		If !(cE2NATUREZ == Alltrim(SE2->E2_NATUREZ))
			aadd( aAlt,{ STR0253 , STR0254 + ' :', STR0255 + ' - '  + STR0258 , STR0256 + ' - ' +  Alltrim(cE2NATUREZ) , STR0257 + ' - ' + Alltrim(SE2->E2_NATUREZ)})
		endif

		If !(cE2VENCTO == Alltrim(DTOC(SE2->E2_VENCTO)))
			aadd( aAlt,{ STR0253 , STR0254 + ' :', STR0255 + ' - '  + STR0259 , STR0256 + ' - ' + Alltrim(cE2VENCTO) , STR0257 + ' - ' +  Alltrim(DTOC(SE2->E2_VENCTO))})
		endif

		If !(cE2VENCREA == Alltrim(DTOC(SE2->E2_VENCREA)))
			aadd( aAlt,{ STR0253 , STR0254 + ' :', STR0255 + ' - '  + STR0260 , STR0256 + ' - '  +  Alltrim(cE2VENCREA) , STR0257 + ' - ' +  Alltrim(DTOC(SE2->E2_VENCREA))})
		endif

		If !(cE2VALOR == Alltrim(Transform(SE2->E2_VALOR,PesqPict("SE2","E2_VALOR"))))
			aadd( aAlt,{ STR0253 , STR0254 + ' :', STR0255 + ' - '  + STR0261 , STR0256 + ' - '  +  Alltrim(cE2VALOR) , STR0257 + ' - ' + Alltrim(Transform(SE2->E2_VALOR,PesqPict("SE2","E2_VALOR"))) })
		endif

		If !(cE2DECRESC == Alltrim(Transform(SE2->E2_DECRESC,PesqPict("SE2","E2_DECRESC"))))
			aadd( aAlt,{ STR0253 , STR0254 + ' :', STR0255 + ' - '  + STR0262 , STR0256 + ' - '  +  Alltrim(cE2DECRESC) ,STR0257 + ' - ' + Alltrim(Transform(SE2->E2_DECRESC,PesqPict("SE2","E2_DECRESC"))) })
		endif

		If !(cE2ACRESC == Alltrim(Transform(SE2->E2_ACRESC,PesqPict("SE2","E2_ACRESC"))))
			aadd( aAlt,{ STR0253 , STR0254 + ' :', STR0255 + ' - '  + STR0263 , STR0256 + ' - '  +  Alltrim(cE2ACRESC) ,STR0257 + ' - ' + Alltrim(Transform(SE2->E2_ACRESC,PesqPict("SE2","E2_ACRESC"))) })
		endif

		If !(cE2VALJUR == Alltrim(Transform(SE2->E2_VALJUR,PesqPict("SE2","E2_VALJUR"))))
			aadd( aAlt,{ STR0253 , STR0254 + ' :', STR0255 + ' - '  + STR0264 , STR0256 + ' - ' +  Alltrim(cE2VALJUR) , STR0257 + ' - ' +  Alltrim(Transform(SE2->E2_VALJUR,PesqPict("SE2","E2_VALJUR"))) })
		endif

		If !(cE2PORCJUR == Alltrim(Transform(SE2->E2_PORCJUR,PesqPict("SE2","E2_PORCJUR"))))
			aadd( aAlt,{ STR0253 , STR0254 + ' :', STR0255 + ' - '  + STR0265 , STR0256 + ' - '  +  Alltrim(cE2PORCJUR) ,STR0257 + ' - ' +  Alltrim(Transform(SE2->E2_PORCJUR,PesqPict("SE2","E2_PORCJUR"))) })
		endif

		If !(cE2HIST == Alltrim(SE2->E2_HIST))
			aadd( aAlt,{ STR0253 , STR0254 + ' :', STR0255 + ' - '  + STR0266 , STR0256 + ' - '  +  Alltrim(cE2HIST) ,STR0257 + ' - ' +  Alltrim(SE2->E2_HIST)})
		endif

		///chamada da Função que cria o Log de alterações
		FinaCONC(aAlt,"SE2")

	endif

	If cPaisLoc=="BRA" .and. lContrRet .and. !lPccBaixa .and. nOpca != 1 .and.(!lAlterNat .or. ;
	STR(SE2->E2_PIS+SE2->E2_COFINS+SE2->E2_CSLL,17,2) == STR(nPisOri+nCofOri+nCslOri,17,2))
		//Regravo os valores originais de PIS/Cofins/Csll em caso de desistencia de alteracao
		RECLOCK("SE2",.F.,,.T.)
		SE2->E2_PIS := nPisOri
		SE2->E2_COFINS := nCofOri
		SE2->E2_CSLL := nCslOri
		MsUnlock()
	EndIf

	nOldValor := SE2->E2_VALOR
	nOldSaldo := SE2->E2_SALDO
	nOldIRR   := SE2->E2_IRRF
	nOldISS   := SE2->E2_ISS
	If lBtrISS
		nOldBtrISS := SE2->E2_BTRISS
	EndIf
	nOldInss  := SE2->E2_INSS
	nOldSEST  := SE2->E2_SEST

	nOldPis	  := SE2->E2_PIS
	nOldCofins:= SE2->E2_COFINS
	nOldCsll  := SE2->E2_CSLL
	//Se controla Retencao
	If lContrRet .and. !lPccBaixa
		nOldPis := IIF(Empty(SE2->E2_VRETPIS), SE2->E2_PIS , SE2->E2_VRETPIS )
		nOldCofins := IIF(Empty(SE2->E2_VRETCOF), SE2->E2_COFINS , SE2->E2_VRETCOF )
		nOldCsll := IIF(Empty(SE2->E2_VRETCSL), SE2->E2_CSLL , SE2->E2_VRETCSL )
	Endif
	//³ Finaliza a gravacao dos lancamentos do SIGAPCO            ³
	PcoFinLan("000002")

	PcoFreeBlq("000002")

	//³ Trexo que altera os campos Gera Dirf e Codigo de Retencao ³
	//³ dos titulos filhos (quando houverem)                      ³
	If cPaisLoc == "BRA" .And. !(Alltrim(SE2->E2_TIPO) $ MVTAXA+"|"+MVTXA)
		nRecno  := SE2->(Recno())
		cChave  := SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM
		cCodRet := SE2->E2_CODRET
		cDirf   := Iif((SE2->E2_DIRF != cDirfImp .AND. cDirfAlt != '1').OR.(SE2->E2_DIRF=="1" .AND.cDirfAlt == "1") , SE2->E2_DIRF, cDirfImp)
		cTxDirf := If(lAltPa,MVTXA,MVTAXA)
		lFoundTx := .F.

		If SE2->E2_DIRF != cDirfImp
			//Se houve alteração do status da DIRF, atualizo os TXs e o tit. principal na sequencia.
			dbSeek(SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM,.T.)
			Do While !EOF() .And. SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM == cChave
				If Alltrim(SE2->E2_TIPO) == cTxDirf .And. Alltrim(SE2->E2_NATUREZ) $ "IRF/PIS/COFINS/CSLL"
					RecLock("SE2",.F.,,.T.)
					SE2->E2_DIRF := cDirf
					lFoundTx := .T.
					If "IRF" $ SE2->E2_NATUREZ
						SE2->E2_CODRET := cCodRet
					Endif
					If Alltrim(SE2->E2_NATUREZ) $ "PIS/COFINS/CSLL"
						//uso de código único de retenção - empresa pública
						If lFINCDRET
							aCRets :=ExecBlock("FINCDRET")
							If aScan(aCRets,cCodRet) > 0
								SE2->E2_CODRET := cCodRet
							EndIf
						EndIf
					EndIf
					MsUnlock()
				Endif
				dbSkip()
			Enddo
			SE2->(dbGoto(nRecno))
			RecLock("SE2",.F.,,.T.)
			SE2->E2_DIRF := If(lFoundTx,"2",cDirf)
			MsUnlock()
		Else
			//Se não houve alteração do status da DIRF, restauro o valor original.
			RecLock("SE2",.F.,,.T.)
			SE2->E2_DIRF := cDirfPai
			MsUnlock()
		Endif
	Endif

	If IntePMS()
		SetKey(VK_F10, Nil)
	EndIf
	If SE2->E2_INSS > 0 .and. !lAltPA
		Reclock("SE2",.F.,,.T.)
		SE2->E2_VRETINS := SE2->E2_INSS
		MsUnlock()
	EndIf

	If 	cPaisLoc $ "DOM|COS"  .And. !lF050Auto  .And. (SE2->E2_NATUREZ <> M->E2_NATUREZ .Or. SE2->E2_VALOR <> M->E2_VALOR)
		//Deleção dos titulos de Abatimento Gerados Anteriormente
		fa050DelRet()
		//Geração das Retenções de Impostos - Republica Dominicana //1-Contas a Pagar ou 3-Ambos e Fato Gerador 1-Emissao.
		fa050CalcRet("'1|3'", "2", SE2->E2_NATUREZ, SE2->E2_VALOR, SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_FORNECE)
	EndIf

	If nOpcA == 1 .AND. GetNewPar('MV_NGMNTFI','N') == 'S'  .and. !lAltPA
		NGMNTSE2(nOpc)
	Endif

	// Integração protheus X tin.
	If nOpcA == 1 .and. __lFWHasEAI .and. !lAltPA
		lRatPrj := PMSRatPrj("SE2",,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
		If !( AllTrim(SE2->E2_TIPO) $ MVPAGANT .and. lRatPrj  .and. !(cPaisLoc $ "BRA|")) //nao integra PA  para Totvs Obras e Projetos Localizado
			aEaiRet := FWIntegDef('FINA050',,,, 'FINA050')
			If !aEaiRet[1]
				Help(" ", 1, "HELP", STR0315, STR0316 + CRLF + aEAIRET[2], 3, 1)  // "Erro EAI" / "Problemas na integração EAI. Transação não executada."
				DisarmTransaction()
				nOpcA := 2
			Endif
		Endif
	Endif

End Transaction

If cPaisLoc=="BRA"
	F986LimpaVar() //Limpa as variaveis estaticas - Complemento de Titulo
EndIf

dbSelectArea( "SE2" )
dbSetOrder(nIndex)
dbGoTo( nReg )
Return nOPCA

/*/
±±³Fun‡…o	 ³Fa050Pai	³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 28/08/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Procura se titulo de ISS ou TX tem pai					  ³±±
/*/
FuncTion Fa050Pai()
LOCAL nRegSE1
LOCAL nRegSE2
LOCAL lAchou    := .F.
LOCAL cPrefixo  := SE2->E2_PREFIXO
LOCAL cNum		:= SE2->E2_NUM
LOCAL cParcela  := SE2->E2_PARCELA
LOCAL cTipoPai	:= SE2->E2_TIPO
LOCAL cFornece	:= SE2->E2_FORNECE
LOCAL cNatureza := SE2->E2_NATUREZ
LOCAL cParcPai  := ""
LOCAL cValorPai := ""
Local cOrigem	:= Upper(SE2->E2_ORIGEM)
Local lTitPai   := .T.
Local cTitPai   := If(lTitPai,SE2->E2_TITPAI,"")
Local cMunic	:= GetMv("MV_MUNIC")
Local cForIss	:= ""
Local lISSCpom	:= .F.
// Verifica se o ambiente esta configurado com Multiplos Vinculos de ISS
If cPaisLoc == "BRA"
	If !Empty( SE2->E2_CODISS )
		DbSelectArea( "FIM" )
		FIM->( DbSetOrder( 1 ) )
		If FIM->( DbSeek( xFilial( "FIM" ) + SE2->E2_CODISS ) )
			cMunic := FIM->FIM_CODFOR
		EndIf
	EndIf
EndIf
If FindFunction("BtrISS")
	lISSCpom := BtrISS()
EndIf
//³ Verifico qual campo de valor a ser verificado       ³
If lISSCpom
	cValorPai := "SE2->E2_BTRISS"
	cParcPai := "E2_PARCISS"
	cMunic	:= SE2->E2_FORNECE
ElseIf SE2->E2_TIPO $ MVISS
	cValorPai := "SE2->E2_ISS"
	cParcPai := "E2_PARCISS"
ElseIf SE2->E2_TIPO $ MVINSS+"/"+"INA"
	cValorPai := "SE2->E2_INSS"
	cParcPai := "E2_PARCINS"
ElseIf SE2->E2_TIPO $ "SES"
	cValorPai := "SE2->E2_SEST"
	cParcPai := "E2_PARCSES"
ElseIf SE2->E2_TIPO $ "CID"
	cValorPai := "SE2->E2_CIDE"
	cParcPai := "E2_PARCCID"
ElseIf SE2->E2_TIPO $ MVTAXA+"/"+MVTXA .And. !lISSCpom
	cValorPai := "SE2->E2_ISS"
	cParcPai := "E2_PARCISS"
Endif

dbSelectArea("SE2")
dbSetOrder(1)
cForIss := Alltrim(SE2->E2_FORNECE)
nRegSE2:= Recno()
If dbSeek(cFilial+cPrefixo+cNum)
	While !Eof() .and. SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM) == cFilial+cPrefixo+cNum
		//³ Realiza validacoes para identificar o titulo pai    ³
		If Fa050VldPai( cPrefixo, cNum, cParcela, cTipoPai, cFornece, cMunic, cParcPai, cValorPai, cNatureza )
			If lTitPai .AND. !Empty(AllTrim(cTitPai))
				//Não pode liberar a exclusão de títulos com origem FINA050 conforme estava fazendo.
				// a validação de existencia de PAI para o título tem que ser válida para os títulos
				// gerados atraves do FINA050 também.
				If AllTrim(cTitPai) == AllTrim(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
					lAchou := .T.
					Exit
				Else
					lAchou := .F.
				EndIf
			ElseIf lTitPai .AND. Empty(AllTrim(cTitPai)) .AND. "FINA050" $ cOrigem
				lAchou := .F.
			Else
				lAchou := .T.
				Exit
			EndIf
		EndIf
		DbSkip()
	Enddo
EndIf
If !lAchou
	dbSelectArea("SE1")
	dbSetOrder(1)
	nRegSE1 := Recno()
	If dbSeek(cFilial+cPrefixo+cNum)
		While !Eof() .and. SE1->(E1_FILIAL+E1_PREFIXO+E1_NUM) == cFilial+cPrefixo+cNum
			If SE1->E1_ISS != 0 .and. SE1->E1_PARCELA == cParcela .AND. (cForIss==cMunic)
				lAchou := .T.
				Exit
			EndIf
			dbSkip()
		Enddo
	EndIf
	dbGoto(nRegSE1)
EndIf
dbSelectArea("SE2")
dbGoto(nRegSE2)
Return lAchou

/*/
±±³Fun‡…o	 ³fa050valor³ Autor ³ Wagner Xavier 		  ³ Data ³ 18/05/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Trata o valor do titulo. 											  ³±±
/*/
Function fa050valor()
LOCAL lRet:=.T.,cAlias:=Alias(),cMascara
LOCAL nRecSx3 := SX3->(RecNo())
Local nIndexE2 := SE2->(IndexOrd())

nRec:= SE2->(RecNo())

If Type("lAltera")=="U" .and. Funname() == "FINA450" .and. Type("lF080Auto")<>"U"
	lAltera := .T.
EndIf

If m->e2_moeda > 99
	Return .f.
EndIf
//³A moeda do abatimento e titulo devem ser as mesmas para   ³
//³compatibilizacao com multi-moedas e taxas variaveis. Isto ³
//³evita diferencas na consulta FINC060.                     ³
If cPaisLoc <> "BRA" .And. cPaisLoc <> "VEN" .And. cPaisLoc <> "EQU" .And. cPaisLoc <> "PER" .And. M->E2_TIPO $ MVABATIM .And. M->E2_MOEDA <> SE2->E2_MOEDA
	Help(" ",1,"E2MOEDIF")
	Return .f.
ElseIf cPaisLoc == "PER" .And. M->E2_TIPO $ StrTran( MVABATIM , "IR-|" , "" ) .And. M->E2_MOEDA <> SE2->E2_MOEDA
	Help(" ",1,"E2MOEDIF")
	Return .f.
EndIf
//³ Verifica se o abatimento e' maior que valor do titulo              ³
IF !Empty( m->e2_tipo )
	IF m->e2_tipo $ MVABATIM
		dbSelectArea( "SE2" )
		dbSetOrder(6)
		IF dbSeek( xFilial("SE2")+m->e2_fornece+m->e2_loja+m->e2_prefixo + m->e2_num + m->e2_parcela + cTipoParaAbater)
			While !Eof() .and. E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == m->e2_fornece+m->e2_loja+m->e2_prefixo+m->e2_num+m->e2_parcela + cTipoParaAbater
				IF E2_TIPO $ MVABATIM+"/"+MV_CPNEG+"/"+MVPAGANT
					dbSkip( )
					Loop
				Endif
				IF m->e2_valor > SE2->E2_SALDO
					Help(" ",1,"ABATMAIOR")
					lRet := .f.
					Exit
				Endif
				Exit
			Enddo
		Endif
	Endif
Endif
SE2->(dbGoTo(nRec))
If lAltera
	//³ Verifica se o titulo ‚ tipo PA, n†o permitindo altera‡†o do valor  ³
	IF SE2->E2_LA = "S" .OR. SE2->E2_TIPO $ MVPAGANT
		Help(" ",1,"NAOVALOR")
		lRet:=.f.
	EndIF
	If SE2->E2_TIPO $ MVPAGANT
		Help( " ",1,"FA040ADTO")
		lRet := .F.
	Endif
Endif

//Se o titulo tiver desdobramento, devera recalcular a parcela
If M->E2_DESDOBR == 'S'

	Help(" ",1,"F050DESDOB")

EndIf

If lRet
	//³ Inicializa o valor em Real como sugest†o					 ³
	nSavRec := SX3->(Recno())
	cMascara:=PesqPict("SE2","E2_VLCRUZ",19,MsDecimais(1))
	SX3->(DbGoto(nSavRec))
	If ( cPaisLoc == "CHI" )
		M->E2_VLCRUZ:= Round(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA),MsDecimais(1))
	Else
		M->E2_VLCRUZ:= Round(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA),MsDecimais(1))
	Endif

Endif
dbSelectArea( cAlias )
SX3-> (dbGoTo(nRecSx3))
SE2-> (dbGoTo(nRec))
SE2-> (dbSetOrder(nIndexE2))
Return lRet

/*/
±±³Fun‡…o	 ³ fa050Cheq³ Autor ³ Wagner Xavier 		  ³ Data ³ 27/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Teste se o cheque do PA ja' existe.                        ³±±
/*/
Function fa050Cheque(cBanco,cAgencia,cConta,cCheque,lVazio)
LOCAL cAlias	:= Alias()
LOCAL lRet		:= .T.
Local lF050CHEQ := ExistBlock("F050CHEQ")

lVazio:=Iif(lVazio==Nil,.T.,lVazio)

If "FINA050" $ FUNNAME() .and. SubStr(cCheque,1,1) == "*" .And. mv_par05 == 1
	Help(" ",1,"F050CHQINV")
	lRet := .F.
Else
	If lF050CHEQ
		lRet := ExecBlock("F050CHEQ",.F.,.F.)
	Else
		If Empty(cCheque)
			If	lVazio
				Return .T.
			Else
				Help( " ", 1, "FA050CHOB",, STR0154, 4, 0 ) // "O numero do cheque é obrigatório "
				Return .F.
			Endif
		EndIf
		dbSelectArea("SEF")
		dbSetOrder(1)
		If dbSeek(xFilial()+cBanco+cAgencia+cConta+cCheque)
			Help(" ",1,"FA050CHEQ")
			lRet := .F.
		Endif
	EndIf
Endif

dbSelectArea(cAlias)
Return lRet

/*/
±±³Fun‡…o	 ³fa050Rate ³ Autor ³ Wagner Xavier 		  ³ Data ³ 18/05/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Rateia o valor do titulo em v rios Centro de Custos.		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³fa050Rate( ExpC1,ExpC2,ExpC3 ) 									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA050,FINA100														  ³±±
/*/
Function fa050Rate( cPadrao,cProg,cOperacao,nHdlPrv,cArquivo )
Local lPanelFin := IsPanelFin()
LOCAL nOpcA 	 :=0
LOCAL cArq 		 := Space(8)
LOCAL lEstornou := .F.
LOCAL nColunas
LOCAL oDlg
LOCAL oGet
LOCAL j
LOCAL cRateio
LOCAL nMostra
Local nInss := 0
Local lF050ACOL := ExistBlock("F050ACOL")

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)
Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local lInssBX :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
PRIVATE aGETS[0]
PRIVATE cPrograma := cProg
PRIVATE nValRat	:=0
PRIVATE aCols		:= {}
PRIVATE aHeader	:= {}
PRIVATE nUsado 	:= 0
PRIVATE oValRat

If !lInssBX
	If cPrograma == "FINA050"
		nInss := SE2->E2_INSS
		IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
			nInss := 0
		Endif
	Endif
Endif

//³ Definicao de variaveis para posicionamento relativo na tela  ³
nColunas  := IIF( cPrograma == "FINA050" , IIF(mv_par03==1,7,5) , IIF(mv_par03==1,7,5) )

cOperacao := Iif(cOperacao == NIL,"I",cOperacao)

aCampos := { { "I2_CCD"    , "ExistCpo('SI3').or.vazio()",OemToAnsi(STR0032)},;
{ "I2_ITEMD"  , "ExistCpo('SID').or.vazio()",OemToAnsi(STR0073)},;
{ "I2_ITEMC"  , "ExistCpo('SID').or.vazio()",OemToAnsi(STR0074)},;
{ "E2_PORCJUR", "fa050CalcP('"+cProg+"')",OemToAnsi(STR0033)},;
{ "I2_VALOR"  , "fa050CalcV('"+cProg+"')",OemToAnsi(STR0034)},;
{ "I2_DEBITO" , "ExistCpo('SI1').or.vazio()",OemToAnsi(STR0035)},;
{ "I2_CREDITO", "ExistCpo('SI1').or.vazio()",OemToAnsi(STR0036)} }

If cOperacao == "E"
	If cPrograma == "FINA050"
		cArqRat := Alltrim(SE2->E2_ARQRAT)
		cRateio := SE2->E2_RATEIO
	Endif
	If cPrograma == "FINA100"
		cArqRat := Alltrim(SE5->E5_ARQRAT)
		cRateio := SE5->E5_RATEIO
	Endif
	IF cRateio == "S"
		lEstornou := fa050Carr(nUsado,cArqRat,@cArquivo,@nHdlPrv)
	Endif
Endif

If !lEstornou
	//³ Montagem da matriz aHeader											  ³
	nUsado := 0
	For j:=1 To nColunas
		nUsado++
		IF j == 1
			AADD(aHeader,{OemToAnsi(STR0032),"I2_CCD","@!",; // "Centro Custo"
			9,0,"ExistCpo('SI3').or.vazio()","û","C","SI2" } )
		ElseIf j == 2
			AADD(aHeader,{OemToAnsi(STR0073),"I2_ITEMD","@!",; // "Item Debito"
			9,0,"ExistCpo('SID').or.vazio()","û","C","SI2" } )
		ElseIf j == 3
			AADD(aHeader,{OemToAnsi(STR0074),"I2_ITEMC","@!",; // "Item Credito"
			9,0,"ExistCpo('SID').or.vazio()","û","C","SI2" } )
		Elseif j == 4
			AADD(aHeader,{OemToAnsi(STR0033),"E2_PORCJUR","999.99",; //  "Porcent"
			3,0,"fa050CalcP('"+cProg+"')","û","N","SE2" } )
		Elseif j == 5
			AADD(aHeader,{OemToAnsi(STR0034),"I2_VALOR","@E 9999,999,999.99",; // "Valor"
			14,2,"fa050CalcV('"+cProg+"')","û","N","SI2" } )
		Elseif j == 6
			AADD(aHeader,{OemToAnsi(STR0035),"I2_DEBITO","@!",;  //  "Conta Debito"
			20,0,"Vazio().Or.ca050cta(,6)","û","C","SI2" } )
		Else
			AADD(aHeader,{OemToAnsi(STR0036),"I2_CREDITO","@!",; // "Conta Credito"
			20,0,"Vazio().Or.ca050cta(,7)","û","C","SI2" } )
		Endif
	Next j

	//³ Cria aCOLS de acordo com Tamanho do Arquivo enviado  ³
	AADD(aCols,Array(nUsado+1))
	nUsado := 0

	For j:=1 To nColunas
		nUsado++
		IF aHeader[j][8] == "C"
			aCols[1][nUsado] := Space(aHeader[j][4])
		Else
			aCols[1][nUsado] := 0
		EndIf
	Next j
	aCols[1][nUsado+1] := .F.

	//³ Ponto de entrada para pr‚-inicializar aCOLS de Rateio³
	If lF050ACOL
		nMostra := ExecBlock("F050ACOL",.F.,.F.)
	Endif

	//³ Mostra o corpo da rateio 									 ³
	nOpca := 0
	If	Valtype(nMostra) != "N"
		If cPrograma == "FINA050"
			While nOpca == 0
				DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0037) From 9,0 To 28,80 OF oMainWnd	//	"Rateios"
				oDLg:lMaximized := .F.
				@ 1.6 , 1.4	Say OemToAnsi(STR0021) + SE2->E2_FORNECE	FONT oDlg:oFont		// "Fornecedor: "
				@ 1.6 , 7.6	Say OemToAnsi(STR0022) + SE2->E2_LOJA		FONT oDlg:oFont		// "Loja: "
				@ 1.6 , 19   	Say OemToAnsi(STR0038) + SE2->E2_PREFIXO	FONT oDlg:oFont		// "Prefixo: "
				@ 1.6 , 24   	Say OemToAnsi(STR0039) + SE2->E2_NUM		FONT oDlg:oFont		// "N£mero T¡tulo: "
				@ 1.6 , 41   	Say OemToAnsi(STR0040) + SE2->E2_PARCELA	FONT oDlg:oFont		// "Parcela: "
				@ 10.0 , 1.4 	Say OemToAnsi(STR0041)							FONT oDlg:oFont 		// "Valor T¡tulo: "
				@ 10.0 , 7.6 	Say Iif(mv_par06==1,;
				SE2->(E2_VALOR + If(lIRPFBaixa .And. ! (SE2->E2_TIPO $ MVPAGANT),0,E2_IRRF) +;
				If(!lCalcIssBx,E2_ISS,0)+E2_RETENC+E2_SEST+IIF(lPccBaixa,0,E2_PIS+E2_COFINS+E2_CSLL))+nInss,;
				SE2->E2_VALOR) Picture PesqPict("SE2","E2_VALOR",14) 					FONT oDlg:oFont ;
				COLOR CLR_HBLUE
				@ 10.0 , 24 	Say OemToAnsi(STR0042)  						FONT oDlg:oFont		// "Valor Rateio: "
				@ 10.0 , 32  	Say oValRat VAR nValRat Picture PesqPict("SE2","E2_VALOR",14);
				FONT oDlg:oFont COLOR CLR_HBLUE
				@ 1.0, 0.5 To 2.35,18 OF oDlg
				@ 1.0 ,18.6 To 2.35,39 OF oDlg
				oGet := MSGetDados():New(34,5,128,315,3,"Fa050LinOk", "Fa050TudOk('"+cProg+"')","",.T., , ,.f.)

				If lPanelFin //Chamado pelo Painel Financeiro
					ACTIVATE MSDIALOG oDlg CENTERED ON INIT FaMyBar(oDlg,{||nOpca:=1,if(fa050TudOk(cProg),oDlg:End(),nOpca := 0)},{||oDlg:End()})
				Else
					ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,if(fa050TudOk(cProg),oDlg:End(),nOpca := 0)},{||oDlg:End()})
				Endif

			EndDo
		Else
			While nOpca == 0
				DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0037) From 9,0 To 28,80 OF oMainWnd  // "Rateios"
				oDLg:lMaximized := .F.
				@ 1.6,1.4 	SAY OemToAnsi(STR0043) + DtoC(SE5->E5_DATA)  FONT oDlg:oFont 	// "Data: "
				@ 1.6,19	   SAY OemToAnsi(STR0044) + SE5->E5_DOCUMEN FONT oDlg:oFont  			//"Doc.: "
				@ 10.0 , 1.4 	Say OemToAnsi(STR0041)							FONT oDlg:oFont 		// "Valor T¡tulo: "
				@ 10.0 , 7.6 	Say SE5->E5_VALOR			Picture PesqPict("SE5","E5_VALOR",14) 					FONT oDlg:oFont ;
				COLOR CLR_HBLUE
				@ 10.0 , 24 	Say OemToAnsi(STR0042)  						FONT oDlg:oFont		// "Valor Rateio: "
				@ 10.0 , 32  	Say oValRat VAR nValRat Picture PesqPict("SE2","E2_VALOR",14);
				FONT oDlg:oFont COLOR CLR_HBLUE
				@ 1.0, 0.5 To 2.35,39 OF oDlg

				oGet := MSGetDados():New(34,5,128,315,3,"Fa050LinOk","Fa050TudOk('"+cProg+"')","",.T., , ,.f.)

				If lPanelFin //Chamado pelo Painel Financeiro
					ACTIVATE MSDIALOG oDlg CENTERED ON INIT FaMyBar(oDlg,{||nOpca:=1,if(fa050TudOk(cProg),oDlg:End(),nOpca := 0)},{||oDlg:End()})
				Else
					ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,if(fa050TudOk(cProg),oDlg:End(),nOpca := 0)},{||oDlg:End()})
				Endif

			EndDo
		Endif
	Else
		nOpca := 1
		fa050TudOk(cProg)
	Endif
	If nOpca == 1
		Fa050OnLine( @cArq, cOperacao, cPrograma, cPadrao )
	Endif
Endif
Return cArq

/*
±±ºPrograma  ³F050ONLINEºAutor  ³Alessandro Freire   º Data ³  13/02/96   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±³Descri‡…o ³Verifica se a contabilizacao deve ser on-line e a executa.  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fa050OnLine( ExpC1,ExpC2,ExpC3,ExpC4 )                      ³±±
*/
Function Fa050OnLine( cArq, cOperacao, cPrograma, cPadrao )
Local nHandle
Local lResult := .T.

If mv_par04 == 1			// Contabiliza On-Line
	If cOperacao == "I" .And. cPrograma $ "FINA050/FINA100"
		//³ É preciso gerar um arquivo texto nesta contabilizacao, pois ³
		//³ podera existir a sua exclusao e deve-se trazer na tela o que³
		//³ ja foi contabilizado													 ³
		cArq	:= "RT"+cEmpAnt+GetSX8Num("CPR")
		ConfirmSx8()
		Fa050Off(aCols,cPadrao,cLote,cArq,mv_par04,cPrograma,nHandle)
	EndIF
	fa050MontC( cPadrao,nHandle )
ElseIf mv_par04 != 1 	// Para evitar o K_ESC
	If cOperacao == "I"
		cArq	:= "RT"+cEmpAnt+GetSX8Num("CPR")
		ConfirmSx8()
		Fa050Off(aCols,cPadrao,cLote,cArq,mv_par04,cPrograma,nHandle)
	Endif
EndIf

Return ( lResult )

/*/
±±³Fun‡…o	 ³fa050CalcP³ Autor ³ Wagner Xavier 		  ³ Data ³ 18/05/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calcula o porcentual digitado para rateio no Centro Custo   ³±±
/*/
Function FA050CalcP(cPrograma)
LOCAL nCont
Local nInss := 0
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)
Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local lInssBX :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"

nPorcent := &(ReadVar())

If nPorcent > 100
	Return .F.
EndIf

If !lInssBX
	If cPrograma == "FINA050"
		nInss := SE2->E2_INSS
		IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
			nInss := 0
		Endif
	Endif
Endif
nValRat	:= 0

IF nPorcent == 0
	aCOLS[n][5] := 0
Else
	aCOLS[n][5] := NoRound( Iif( cPrograma == "FINA050" 	,;
	Iif(mv_par06==1,;
	SE2->(E2_VALOR + If(lIRPFBaixa .And. ! M->E2_TIPO $ MVPAGANT,0,E2_IRRF) +;
	If(!lCalcIssBx,E2_ISS,0)+E2_RETENC+E2_SEST+IIF(lPccBaixa,0,E2_PIS+E2_COFINS+E2_CSLL))+nInss,;
	SE2->E2_VALOR),;
	SE5->E5_VALOR ) * nPorcent / 100 ,2 )
Endif

For nCont := 1 To Len(aCols)
	If ! aCols[nCont][nUsado+1]
		nValRat += aCols[nCont][5]
	EndIF
Next

If Type("oValRat")=="O"
	oValRat:Refresh()
Endif

Return .t.

/*/
±±³Fun‡…o	 ³fa050CalcV³ Autor ³ Wagner Xavier 		  ³ Data ³ 18/05/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calcula o valor digitado para rateio no Centro Custo		  ³±±
/*/
Function FA050CalcV(cPrograma)

LOCAL nCont

nValRat := 0

aCols[n][5] := &(ReadVar())

For nCont := 1 To Len(aCols)
	If !aCols[nCont][nUsado+1]
		nValRat += aCols[nCont][5]
	EndIf
Next

If Type("oValRat")=="O"
	oValRat:Refresh()
Endif

Return .t.

/*/
±±³Fun‡…o	 ³fa050MontC³ Autor ³ Wagner Xavier 		  ³ Data ³ 18/05/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Monta lan‡amento contabil em funcao do rateio digitado 	  ³±±
/*/
Function FA050MontC( cPadrao, nHandle )

Local lResult		:= .T.
LOCAL cArquivo
LOCAL nTotal		:=0
LOCAL nHdlPrv		:=0
LOCAL lDigita
LOCAL nLinha
LOCAL nCont			:=0
LOCAL nSomaAcols	:=0
Local lAglutina
Local aFlagCTB := {}
Local lUsaFlag	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)

//Nova estrutura SE5
Local oModel
Local oSubFK5
Local oSubFKA
Local cLog := ""
Local aAreaAnt

For nCont := 1 TO Len(aCols)
	If !(aCols[nCont][nUsado+1])
		nSomaAcols++
	Endif
Next nCont

If nSomaAcols != 0
	//³ Inicializa Lancamento Contabil                                   ³
	nHdlPrv := HeadProva( cLote,;
	cPrograma,;
	Substr(cUsuario,7,6),;
	@cArquivo )
	nLinha := 0
	While nLinha < Len(aCols)
		nLinha++
		If !aCols[nLinha][nUsado+1]
			Custo  := aCols[nLinha][1]
			ItemD	 := aCols[nLinha][2]
			ItemC  := aCols[nLinha][3]
			Valor  := xMoeda(aCols[nLinha][5],SE2->E2_MOEDA,1)
			If SE2->E2_MOEDA > 1
				//³ Carrega em VALOR o valor referente ao campo E2_VLCRUZ³
				//³ que ‚ o valor em REAIS.                              ³
				//³ Isto se a moeda do t¡tulo for maior que 1.           ³
				If ( cPaisLoc == "CHI" )
					Valor := Round( SE2->E2_VLCRUZ, MsDecimais(1) ) * aCols[nLinha][4] / 100
				Else
					Valor := SE2->E2_VLCRUZ * aCols[nLinha][4] / 100
				Endif
			Endif
			Debito := Iif(mv_par03==1,aCols[nLinha][6],"")
			Credito:= Iif(mv_par03==1,aCols[nLinha][7],"")
			VlrInStr := Valor

			//³ Prepara Lancamento Contabil                                      ³
			//Contabiliza pela variavel VALOR. Nao necessita de controle de flag.
			nTotal += DetProva( nHdlPrv,;
			cPadrao,;
			cPrograma,;
			cLote,;
			0 /*nLinha*/,;
			.F. /*lExecuta*/,;
			cPrograma /*cCriterio*/,;
			/*lRateio*/,;
			/*cChaveBusca*/,;
			/*aCT5*/,;
			/*lPosiciona*/,;
			/*@aFlagCTB*/,;
			/*aTabRecOri*/,;
			/*aDadosProva*/ )
		Endif
	Enddo // While nLinha < Len(aCols)

	Valor := 0
	VlrInStr := 0
	//³ Prepara Lancamento Contabil                                      ³
	If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
		If cPrograma == "FINA050"
			aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
		Else
			aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
		Endif
	Endif
	nTotal += DetProva( nHdlPrv,;
	cPadrao,;
	cPrograma,;
	cLote,;
	0 /*nLinha*/,;
	.T. /*lExecuta*/,;
	cPrograma /*cCriterio*/,;
	/*lRateio*/,;
	/*cChaveBusca*/,;
	/*aCT5*/,;
	/*lPosiciona*/,;
	@aFlagCTB,;
	/*aTabRecOri*/,;
	/*aDadosProva*/ )

	lDigita := IIF( cPrograma == "FINA050" , IIF(mv_par01==1,.T.,.F.) , Iif(mv_par02==1,.t.,.f.) )
	If cPrograma == "FINA050"
		lAglutina	:= Iif(mv_par07 == 1,.T.,.F.)
	Else
		lAglutina	:= .F.
	EndiF
	If  UsaSeqCor()
		aDiario := {}
		aDiario := {{"SE2",SE2->(recno()),SE2->E2_DIACTB,"E2_NODIA","E2_DIACTB"}}
	Else
		aDiario := {}
	EndIf
	//³ Envia para Lan‡amento Contabil                      ³
	RodaProva( nHdlPrv,;
	nTotal )
	cA100Incl( cArquivo,;
	nHdlPrv,;
	3 /*nOpcx*/,;
	cLote,;
	lDigita,;
	lAglutina,;
	/*cOnLine*/,;
	/*dData*/,;
	/*dReproc*/,;
	@aFlagCTB,;
	/*aDadosProva*/,;
	aDiario )
	aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento

	If !lUsaFlag
		If cPrograma == "FINA050"
			dbSelectArea("SE2")
			//³ Atualiza flag de Lan‡amento Cont bil       ³
			Reclock("SE2")
			Replace E2_LA With "S"
		Else
			dbSelectArea("SE5")
			//³ Atualiza flag de Lan‡amento Cont bil       ³
			aAreaAnt := GetArea()

			oModel :=  FWLoadModel('FINM030')//Mov. Bancarios Manual
			oModel:SetOperation( 4 ) //Alteração
			oModel:Activate()
			oSubFKA := oModel:GetModel( "FKADETAIL" )
			oSubFKA:SeekLine( 	{ {"FKA_IDORIG", SE5->E5_IDORIG } } )

			//Dados do movimento
			oSubFK5 := oModel:GetModel( "FK5DETAIL" )
			oSubFK5:SetValue( "FK5_LA", "S" )

			If oModel:VldData()
				oModel:CommitData()
				oModel:DeActivate()
			Else
				cLog := cValToChar(oModel:GetErrorMessage()[4]) + ' - '
				cLog += cValToChar(oModel:GetErrorMessage()[5]) + ' - '
				cLog += cValToChar(oModel:GetErrorMessage()[6])
				Help( ,,"M050VALID",,cLog, 1, 0 )
			Endif
			RestArea(aAreaAnt)
		Endif
	Endif
Endif

Return ( lResult ) // Function FA050MontC

/*/
±±³Fun‡…o	 ³Fa050Off	³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24/08/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Gera o arquivo de "Contra-Prova" p/ os rateios Financeiro   ³±±
/*/
Function Fa050Off(aCols,cPadrao,cLote,cArq,nContab,cPrograma,nHandle)

LOCAL nCont
LOCAL nTotal		:=0
LOCAL nHdlPrv		:=0
LOCAL nSomaAcols	:=0
LOCAL nLinha		:=0

FOR nCont := 1 TO Len(aCols)
	If !(aCols[nCont][nUsado+1])
		nSomaAcols++
	Endif
NEXT nCont

If nSomaAcols != 0
	nHdlPrv :=  Fa050Head(cLote,cArq,nContab,cPrograma)
	nLinha := 0
	While nLinha < Len(aCols)
		nLinha++
		If !aCols[nLinha][nUsado+1]
			Custo 	:= aCols[nLinha][1]
			ItemD		:= aCols[nLinha][2]
			ItemC		:= aCols[nLinha][3]
			Valor 	:= xMoeda(aCols[nLinha][5],SE2->E2_MOEDA,1)
			VlrInStr := Valor
			Debito	:= Iif(mv_par03==1,aCols[nLinha][6],"")
			Credito	:= Iif(mv_par03==1,aCols[nLinha][7],"")
			nTotal+=fa050det(nHdlPrv,cPadrao,.f.)
		Endif
	Enddo
	Valor	  := 0
	VlrInStr := 0
	nTotal+=fa050det(nHdlPrv,cPadrao,.t.)
	fa050Roda(nHdlPrv,nTotal)
	fClose( nHdlPrv )
Endif
Return

/*/
±±³Fun‡…o	 ³Fa050Head ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24/08/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava a linha de cabecalho dos rateios off-line -financeiro ³±±
/*/
Function fa050Head(cLote,cArq,nContab,cPrograma)

LOCAL cData
LOCAL nHdlPrv
LOCAL cOperador
LOCAL cProva
LOCAL cArquivo
Local cSet
Local nSaveSx8 := GetSx8Len()

cSet := Set(_SET_DATEFORMAT)
Set(_SET_DATEFORMAT,"dd/mm/yyyy")

cData 	:= Iif(cPrograma=="FINA050",DtoC(SE2->E2_EMISSAO),DtoC(SE5->E5_DATA))
cProva	:= GetMv("MV_PROVA")
cOperador:= SubStr(cUsuario,7,6)

If nContab == 1
	cArquivo := cProva+cArq+".#LA"
Else
	cArquivo := cProva+cArq+".LAN"
EndIf

cPrograma := SubStr(cPrograma+Space(8-Len(cPrograma)),1,8)
//³ Cria o arquivo de LOG para LA							  ³
nHdlPrv	:= MSFCREATE(cArquivo,0)
IF nHdlPrv > 0
	FWRITE(nHdlPrv,"00"+cData+cLote+cPrograma+cOperador+xFilial("SI2")+Space(278)+CHR(13)+CHR(10),312)
	While (GetSx8Len() > nSaveSx8 )
		ConfirmSX8()
	Enddo
	Commit
Else
	While (GetSx8Len() > nSaveSx8 )
		RollBackSX8()
	Enddo
	HELP(" ",1,"HDLNAOGERA")
EndIF

Set(_SET_DATEFORMAT,cSet)

Return nHdlPrv

/*/
±±³Fun‡…o	 ³Fa050Det	³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24/08/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava as linhas de detalhe dos rateios off-line -financeiro ³±±
/*/
Function Fa050Det(nHdlPrv,cPadrao,lExecuta)

LOCAL aContas[18]
LOCAL nTotal := 0
Local cSet, cHist, cHistorico, n

cSet := Set(_SET_DATEFORMAT)
Set(_SET_DATEFORMAT,"dd/mm/yyyy")

//³ Gravar o DETALHE do Arquivo gerado 					  ³
dbSelectArea("SI5")
dbSeek(cFilial+cPadrao)
While !Eof() .And. I5_FILIAL == cFilial .And. cPadrao==I5_CODIGO
	//³ Tipo do Lancamento 				 	³
	aContas[1]:=I5_DC

	aContas[2] :=TranslCta(I5_DEBITO, 20)
	aContas[3] :=TranslCta(I5_CREDITO,20)
	aContas[4] := 0

	//³ Vlr Moeda1 ³
	cValor1	:= Trim(I5_CPOVAL1)

	If lExecuta
		If Alltrim(Upper(cValor1)) == "VALOR" .or. "VLRINSTR" $ Upper(cValor1)
			dbSkip()
			Loop
		Endif
	Endif

	If !lExecuta
		If ! (Alltrim(Upper(cValor1)) == "VALOR" .or. "VLRINSTR" $ Upper(cValor1))
			dbSkip()
			Loop
		Endif
	Endif

	If !Empty(cValor1)
		aContas[4]:=&(cValor1)
	Endif

	//³ Moedas 	   ³
	aContas[5]	:= I5_MOEDAS

	//³ Historico 	   ³
	aContas[6]	:= TranslCta(I5_HISTORI,240)

	//³ Outras Moedas ³
	aContas[7] := 0
	aContas[8] := 0
	aContas[9] := 0
	aContas[10]:= 0
	aContas[17]:=TranslCta(I5_ITEMD,9)
	aContas[18]:=TranslCta(I5_ITEMC,9)

	//³ C.Custo Debito e Credito  ³
	aContas[11] := TranslCta(I5_CCD, 9)
	aContas[12] := TranslCta(I5_CCC, 9)

	//³ Cod/Seq Lanc Padrao		 	³
	aContas[13] :=	I5_CODIGO+I5_SEQUENC

	//³ Data de Vencimento 		 	³
	aContas[14] :=	TranslDta(I5_DTVENC)

	//³ Origem Lancamento			³
	aContas[15] := TranslCta(I5_ORIGEM,40)

	aContas[16] := I5_INTERCP

	If aContas[4] > 0
		//³ Escreve no Arquivo		   ³

		nTotal+=aContas[4]
		If Len(Alltrim(aContas[6])) > 40
			cHistorico := Alltrim(aContas[6])
			For n := 1 to Len(cHistorico) Step 40
				cHist := Substr(cHistorico,n,40)
				cHist := cHist + Space(40 - Len(cHist))
				If n = 1
					FWRITE( nHdlPrv,aContas[1]+aContas[2]+aContas[3]+;
					Str(aContas[4],16,2)+aContas[5]+cHist+;
					Str(aContas[7],16,2)+Str(aContas[8],16,2)+;
					Str(aContas[9],16,2)+Str(aContas[10],16,2)+;
					aContas[11]+aContas[12]+aContas[13]+aContas[14]+;
					aContas[15]+aContas[16]+Space(10)+aContas[17]+;
					aContas[18]+Space(42)+CHR(13)+CHR(10),312)
				Else
					aContas[1]  := "-"
					aContas[2]  := Space(20)
					aContas[3]  := Space(20)
					aContas[4]  := 0
					aContas[7]  := 0
					aContas[8]  := 0
					aContas[9]  := 0
					aContas[10] := 0
					aContas[11] := Space(9)
					aContas[12] := Space(9)
					aContas[13] := I5_CODIGO+I5_SEQUENC
					aContas[14] := TranslDta(I5_DTVENC)       //Interpreta data de vencimento
					aContas[15] := TranslCta(I5_ORIGEM,40)    //Interpreta a origem
					aContas[16] := Substr(I5_INTERCP,1,1)     //Inter Company
					aContas[17] := Space(9)
					aContas[18] := Space(9)

					FWRITE( nHdlPrv,aContas[1]+aContas[2]+aContas[3]+;
					Str(aContas[4],16,2)+aContas[5]+cHist+;
					Str(aContas[7],16,2)+Str(aContas[8],16,2)+;
					Str(aContas[9],16,2)+Str(aContas[10],16,2)+;
					aContas[11]+aContas[12]+aContas[13]+aContas[14]+;
					aContas[15]+aContas[16]+Space(10)+aContas[17]+;
					aContas[18]+Space(42)+CHR(13)+CHR(10),312)
				Endif
			Next
		Else
			FWRITE( nHdlPrv,aContas[1]+aContas[2]+aContas[3]+;
			Str(aContas[4],16,2)+aContas[5]+Substr(aContas[6],1,40)+;
			Str(aContas[7],16,2)+Str(aContas[8],16,2)+;
			Str(aContas[9],16,2)+Str(aContas[10],16,2)+;
			aContas[11]+aContas[12]+aContas[13]+aContas[14]+;
			aContas[15]+aContas[16]+Space(10)+aContas[17]+;
			aContas[18]+Space(42)+CHR(13)+CHR(10),312)
		Endif
		dbCommit()
	Endif
	dbSelectArea("SI5")
	dbSkip()
Enddo
Set(_SET_DATEFORMAT,cSet)
Return nTotal

/*/
±±³Fun‡…o	 ³Fa050Roda ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 28/08/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Gera o rodape dos rateios off-line -financeiro				  ³±±
/*/
Function Fa050Roda(nHdlPrv,nTotal)
//³ Gravar o TOTAL do Arquivo gerado						  ³
FWRITE(nHdlPrv,Str(nTotal,16,2)+Space(292)+"FF"+CHR(13)+CHR(10),312)
dbCommit()
Return

/*/
±±³Fun‡…o	 ³Fa050Carr ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 28/08/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Monta exclus„o do rateio.											  ³±±
/*/
Static Function fa050Carr(nUsado,cArqRat,cArquivo,nHdlPrv)

LOCAL cProva
LOCAL nHdlRat
LOCAL nTamArq
LOCAL xBuffer
LOCAL cRotina
LOCAL nBytes
LOCAL nTotal := 0
LOCAL cTipo
LOCAL cDebito
LOCAL cCredito
LOCAL cCCD
LOCAL cCCC
Local nLin := 0
Local cHistRat
Local cOrigem
Local lF050HST := ExistBlock("F050HST")
Local lF050ORI := ExistBlock("F050ORI")

cProva		:= GetMv("MV_PROVA")
cArqRat 		:=	cProva+cArqRat+".#LA"
IF (nHdlRat := Fopen(cArqRat)) < 0
	Return .f.
End

//³ Lˆ o cabe‡alho do arquivo 									³
nTamArq:=FSEEK(nHdlRat,0,2)
xBuffer:=Space( 312 )
FSEEK(nHdlRat,0,0)
FREAD(nHdlRat,@xBuffer,312)

cArquivo := Space(10)
//³ Nome do programa gerador dos lan‡amentos             ³
cRotina := SubStr(xBuffer,17,8)
nBytes  := 0
nTotal  := 0

//³ Inicializa Lancamento Contabil                                   ³
nHdlPrv := HeadProva( cLote,;
"FINA050" /*cPrograma*/,;
Substr(cUsuario,7,6),;
@cArquivo,;
.T. /*lCria*/ )

While nBytes < nTamArq

	xBuffer	:=Space(312)
	fRead(nHdlRat,@xBuffer,312)

	If Substr(xBuffer,309,2) == "FF"
		Exit
	EndIf

	nLin++
	cTipo	 	:= SubStr(xBuffer,1,1	)
	cDebito  := SubStr(xBuffer, 2,20)
	cCredito := SubStr(xBuffer,22,20)
	cCCD 	 	:= SubStr(xBuffer,167,9)
	cCCC 	 	:= SubStr(xBuffer,176,9)
	cItemD	:= Substr(xBuffer,251,9)
	cItemC	:= Substr(xBuffer,260,9)

	If cTipo $ "DXC"        // Inverte quando leu uma linha de detalhe
		cDebito  := SubStr(xBuffer,22,20)
		cCredito := SubStr(xBuffer, 2,20)
		cCCD	  	:= SubStr(xBuffer,176,9)
		cCCC	  	:= SubStr(xBuffer,167,9)
		cItemD	:= Substr(xBuffer,260,9)
		cItemC	:= Substr(xBuffer,251,9)
	Endif
	If cTipo == "D"
		cTipo := "C"
	Elseif cTipo == "C"
		cTipo := "D"
	Endif

	cHistRat 	:= Substr(xbuffer,063,040)
	cOrigem		:= Substr(xbuffer,200,040)

	If lF050HST
		cHistRat :=	ExecBlock("F050HST",.f.,.f.,{cHistRat})
		cHistRat := PAD(cHistRat,40)
	EndIF
	If lF050ORI
		cOrigem := 	ExecBlock("F050ORI",.f.,.f.,{cOrigem})
		cOrigem := PAD(cOrigem,40)
	EndIf

	xBuffer := 	cTipo+cDebito+cCredito+SubStr(xBuffer,42,21)+;
	Substr(cHistRat,1,40)+SubStr(xBuffer,103,64)+Cccd+Cccc+;
	Substr(xBuffer,185,15)+Substr(cOrigem,1,40)+Substr(xBuffer,240,1)+;
	cRotina+SubStr(xBuffer,249,2)+;
	cItemD+cItemC+Substr(xBuffer,269,42)+;
	CHR(13)+CHR(10)

	fWrite(nHdlPrv,xBuffer,312)
	nBytes+=312
Enddo

If nLin > 0
	Fwrite(nHdlPrv,xBuffer,312)
EndIf

Return .t.

/*/
±±³Fun‡…o	 ³fa050Moed ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 10/03/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se a moeda existe no SX3 								  ³±±
/*/
Function Fa050Moed()

LOCAL cAlias	:= Alias()
LOCAL nOrder	:= IndexOrd()
LOCAL nRec
LOCAL lRet 		:= .t.
LOCAL lMoedBco	:= SuperGetMv("MV_MOEDBCO",,.F.)

//³Verifica se a moeda existe no SX3												 ³
cMoeda := Alltrim(Str(m->e2_moeda))
dbSelectArea("SX3")
nRec := Recno()
dbSetOrder(2)
If !dbSeek("M2_MOEDA"+cMoeda)
	Help ( " ", 1, "SEMMOEDA" )
	lRet := .F.
EndIf

If !Empty(cBancoAdt)
	dbSelectArea("SA6")
	dbSetOrder(1)
	dbSeek(xFilial("SA6") + cBancoAdt + cAgenciaAdt + cNumCon)

	If !Empty(SA6->A6_MOEDA) .And. SA6->A6_MOEDA <> 1 .and. M->E2_TIPO == MVPAGANT .and. SA6->A6_MOEDA != M->E2_MOEDA .and. !lMoedBco
		Help ( " ", 1, "MOEDDIF" )
		lRet := .F.
	EndIf
EndIf

If cPaisLoc == "RUS"
	M->E2_TXMOEDA := RecMoeda(M->E2_EMISSAO,M->E2_MOEDA)
EndIf

dbGoto(nRec)
dbSelectArea(cAlias)
dbSetOrder(nOrder)

Return lRet

/*/
±±³Fun‡…o	 ³FA050Inverte³ Autor ³ Wagner Xavier       ³ Data ³ 07/11/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Marca e Desmarca Titulos, invertendo a marca‡†o existente  ³±±
/*/
Static Function Fa050Inverte(cMarca,oValor,oQtdTit,nValor,nQtdTit,oMark,nMoeda,aChaveLbn,cChaveLbn,lTodos,nRegSel)
LOCAL nReg 		:= __SUBS->(Recno())
Local nAscan
Local lAbreDlgCC := .F.

dbSelectArea("__SUBS")
If lTodos
	dbSeek(xFilial("SE2"))
Endif
While !lTodos .Or.;
!Eof() .and. xFilial("SE2") == E2_FILIAL

	If lTodos .Or. cChaveLbn == Nil
		cChaveLbn := "SUBS" + xFilial("SE2")+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
	Endif

	If (lTodos .And. LockByName(cChaveLbn,.T.,.F.)) .Or. !lTodos
		RecLock("__SUBS",.F.)
		IF E2_OK == cMarca
			__SUBS->E2_OK := "  "
			nValor -= Round(NoRound(xMoeda(E2_SALDO+E2_ACRESC-E2_DECRESC,E2_MOEDA,nMoeda,,3),3),2)
			nQtdTit--
			nAscan := Ascan(aChaveLbn, cChaveLbn )
			If nAscan > 0
				UnLockByName(aChaveLbn[nAscan],.T.,.F.) // Libera Lock
			Endif
		Else
			If Ascan(aChaveLbn, cChaveLbn) == 0
				Aadd(aChaveLbn,cChaveLbn)
			Endif
			__SUBS->E2_OK := cMarca
			nValor += Round(NoRound(xMoeda(E2_SALDO+E2_ACRESC-E2_DECRESC,E2_MOEDA,nMoeda,,3),3),2)
			nQtdTit++
			nRegSel := Recno()
		Endif
		__SUBS->(MsUnlock())

		If lF050NPROV
			ExecBlock("F050NPROV",.F.,.F.,{cChaveLbn})
		EndIf
		If cPaisLoc == "EQU"
			lAbreDlgCC := .F.
			If SE2->E2_TIPO <> "CC "
				SF1->(dbSetOrder(1))
				If SF1->(dbSeek(xFilial("SF1")+SE2->E2_NUM+SE2->E2_PREFIXO+SE2->E2_FORNECE+SE2->E2_LOJA))
					SE4->(dbSetOrder(1))
					If SE4->(dbSeek(xFilial("SE4")+SF1->F1_COND)) .and. AllTrim(SE4->E4_FORMA) == "CC"
						lAbreDlgCC := .T.
					EndIf
				EndIf
			Else
				lAbreDlgCC := .T.
			EndIf
			If !Empty(__SUBS->E2_OK) .and. lAbreDlgCC
				//Executar dialogo para obter os dados do Cartão de Crédito
				Fa050GetCC(.F.)
			EndIf
		EndIf
	Endif
	If !lTodos
		Exit
	Endif
	dbSkip()
Enddo

__SUBS->(dbGoto(nReg))
oValor:Refresh()
oQtdTit:Refresh()
oMark:oBrowse:Refresh(.t.)
Return Nil

//-------------------------------------------------------
/*/{Protheus.doc} F050Dsdobr
	Faz desdobramento em parcelas, do titulo em inclusao.

@author Claudio D. de Souza
@since 31/08/1998
@version P12
*/
//-------------------------------------------------------
Function F050Dsdobr()

Local nOpcDsd:= 0
Local cCondPgto:= Space(3), nParceDsd:= 0, cValorDsd := "T"
Local nPerioDsd:= 0
Local nOrdSE2 := SE2->(IndexOrd())
Local oDlg, oVlDsd
Local lCondPgto := .F.
Local lFina250		:= FwIsInCallStack("F050DELRTD")
Local lF05MONTDD := ExistBlock ("F05MONTDD")

//Verifico se permite rateios de desdobramento no mesmo titulo
If lRatDsd == NIL
	lRatDsd := IIF(GetMv("MV_RATDESD",,"2") == "1", .T., .F.)
Endif

aParcelas := {}
aParcacre := {}
aParcdecre:= {}
//caso seja executado esse PE, ele deve retornar:
// .T. para informar que já fez o tratamento necessário e a tela de desdobramento padrao NAO DEVE ser apresentada
// .F. para informar que nao fez o tratamento necessário e a tela de desdobramento padrao DEVE ser apresentada
If lF05MONTDD .and. ExecBlock("F05MONTDD",.F.,.F.)
	M->E2_MULTNAT := "2"
	Return .T.
EndIF

//Exclusao chamada a partir do cancelamento de desdobramento com rastreamento e calculo de impostos
If lFina250
	M->E2_DESDOBR := "N"
	Return .T.
Endif
//³Verifica se a campos obrigatorios foram preencidos							 ³
If Empty(m->e2_num) 		.or. Empty(m->e2_tipo)    .or. Empty(m->e2_naturez) .or.;
	Empty(m->e2_fornece)	.or. Empty(m->e2_loja)    .or. Empty(m->e2_emissao) .or.;
	Empty(m->e2_vencto) 	.or. Empty(m->e2_vencrea) .or. Empty(m->e2_valor)   .or.;
	Empty(m->e2_vlcruz)
	If !lF050Auto
		Help(" " , 1 , "FA050NODSD")
	Endif
	Return .F.
Endif
If m->e2_tipo $ MVPAGANT+"/"+MV_CPNEG+"/"+MVABATIM
	If !lF050Auto
		Help(" " , 1 , "FA050TPDSD")
	Endif
	Return .F.
Endif

If m->E2_RATEIO == "S" .And. !lRatDsd// Se nao rateia desdobramento
	If !lF050Auto
		Help(" " , 1 , "FA050NORAT")
	Endif
	Return .F.
Endif

If !lF050Auto

	nOpcDsd := 0
	While	nOpcDsd == 0

		DEFINE MSDIALOG oDlg FROM	0,0 TO 235,280 TITLE OemToAnsi(STR0057) PIXEL  //"Desdobramento"
		@ 004, 007 TO 105, 105 OF oDlg PIXEL
		@ 010, 014 SAY OemToAnsi(STR0058) SIZE 90, 7 OF oDlg PIXEL  //"Condi‡„o de Pagamento"
		@ 028, 014 SAY OemToAnsi(STR0059) SIZE 90, 7 OF oDlg PIXEL  //"Numero de Parcelas"
		@ 046, 014 SAY OemToAnsi(STR0060) SIZE 90, 7 OF oDlg PIXEL  //"Valor do Titulo (Total ou Parcela)"
		@ 064, 014 SAY OemToAnsi(STR0061) SIZE 90, 7 OF oDlg PIXEL  //"Periodo de Vencto. (em dias)"
		@ 082, 014 SAY OemToAnsi(STR0062) SIZE 90, 7 OF oDlg PIXEL  //"Historico"
		@ 018, 014 MSGET cCondPgto	F3 "SE4" Picture "!!!" SIZE 72, 08 OF oDlg PIXEL ;
		Valid (Empty (cCondPgto) .or. ExistCpo("SE4",cCondPgto)) .and. ;
		Fa290Cond(cCondPgto) HASBUTTON

		@ 036, 014 MSGET  nParceDsd 		  	Picture "9999" When IIf(Empty(cCondPgto),.T.,.F.);
		Valid f050ValPar(nParceDsd,nMaxParc) ;
		SIZE 80, 08 OF oDlg PIXEL
		@ 054, 014 MSCOMBOBOX oVlDsd VAR cValorDsd ITEMS {STR0069,STR0064} SIZE 80, 10 OF oDlg PIXEL ; //"TOTAL"###"PARCELA"
		When IIf(Empty(cCondPgto),.T.,.F.)
		@ 072, 014 MSGET nPerioDsd				Picture "999" When IIf(Empty(cCondPgto),.T.,.F.) ;
		Valid nPerioDsd > 0;
		SIZE 80, 08 OF oDlg PIXEL
		@ 090, 014 MSGET  cHistDsd			 	Picture "@S40";
		SIZE 80, 08 OF oDlg PIXEL

		DEFINE SBUTTON FROM 07, 110 TYPE 1 ACTION ;
		{||nOpcDsd:=1,IF(A050TudoOK(cCondPgto,nParceDsd,cValorDsd,nPerioDsd),oDlg:End(),nOpcDsd:=0)} ENABLE OF oDlg
		DEFINE SBUTTON FROM 23, 110 TYPE 2 ACTION {||nOpcDsd:=9 ,oDlg:End()} ENABLE OF oDlg

		ACTIVATE MSDIALOG oDlg CENTERED
	EndDo

Else  //Rotina Automatica
	nOpcDsd := 1
	aValidGet:= {}
	//Condicao de Pagamento
	IF (nT := ascan(aRotAuto,{|x| x[1]='AUTCDPGDSD'})) > 0
		Aadd(aValidGet,{'cCondPgto' ,aRotAuto[nT,2],'Empty (cCondPgto) .or. (ExistCpo("SE4",cCondPgto)) .and. SE4->E4_TIPO != "9"',.t.})
		lCondPgto := .T.
		cCondPgto := aRotauto[nT,2]
	Endif

	//Historico
	IF (nT := ascan(aRotauto,{|x| x[1]='AUTHISTDSD'})) > 0
		cHistDsd := aRotauto[nT,2]
		Aadd(aValidGet,{'cHistDsd' ,aRotauto[nT,2],'.T.',.t.})
	Endif

	If !lCondPgto

		//Numero de parcelas
		IF (nT := ascan(aRotauto,{|x| x[1]='AUTNPARDSD'})) > 0
			Aadd(aValidGet,{'nParceDsd' ,aRotauto[nT,2],'f050ValPar(nParceDsd,nMaxParc,.T.)',.t.})
			nParceDsd := aRotauto[nT,2]
		Endif

		//Total ou Parcela
		IF (nT := ascan(aRotauto,{|x| x[1]='AUTTOPADSD'})) > 0
			Aadd(aValidGet,{'cValorDsd' ,aRotauto[nT,2],'cValorDsd $ "T#P"',.t.})
			cValorDsd := aRotauto[nT,2]
		Endif

		//Periodo entre parcelas
		IF (nT := ascan(aRotauto,{|x| x[1]='AUTPERIDSD'})) > 0
			Aadd(aValidGet,{'nPerioDsd' ,aRotauto[nT,2],'nPerioDsd > 0',.t.})
			nPerioDsd := aRotauto[nT,2]
		Endif
	Endif

	If ! SE2->(MsVldGAuto(aValidGet)) // consiste os gets
		nOpcDsd := 2
	EndIf

Endif

cSE2TpDsd := cValorDsd

If nOpcDsd == 1
	nSavRec:=RecNo()
	dbSelectArea("SE2")
	Fa050Cond(cCondPgto,nParceDsd,cValorDsd,nPerioDsd)
	//Cancela Multiplas Naturezas se tiver Desdobramento
	If !lRatDsd
		M->E2_MULTNAT := "2"
	EndIF
Else
	Return .F.
Endif
dbSelectArea("SE2")
dbSetOrder(nOrdSE2)
Return .T.

/*/
±±³Fun‡…o	 ³F050Valpar  ³ Autor ³ Mauricio Pequim Jr  ³ Data ³ 31/08/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Faz verificacao do numero de parcelas do desdobramento.    ³±±
/*/
Function F050VALPAR(nParceDsd,nMaxParc,lAuto)

DEFAULT lAuto := .F.

If nParceDsd > nMaxParc .or. nParceDsd < 2
	If !lAuto
		If cPaisLoc == 'ARG'
			MSGINFO(OemToAnsi(STR0274) + Alltrim(Str(nMaxParc)) + OemToAnsi(STR0275),  OemToAnsi(STR0268)) // "El Número de Cuotas ha excedido el valor de "//" configurado en el parámetro MV_LIMCUOT "//"Régimen Especial Facilidades Pago"
		Else
			Help(" " , 1 , "FA050PCDSD")
		EndIf
	Endif
	Return .F.
Endif
Return .T.

/*
±±³Fun‡…o	 ³A050Cond 	³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 01/09/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Faz calculos do Desdobramento parcelas automaticas 		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ A050Cond(cCondicao)													  ³±±
*/
Function Fa050Cond(cCondDsd,nParceDsd,cValorDsd,nPerioDsd)
Local nValParc		:= 0		// Valor de cada parcela
Local nValParcAc	:= 0
Local nValParcDe	:= 0
Local nVlTotParc	:= 0  	// Valor do somatorio das parcelas
Local nVlTotAcre	:= 0
Local nVlTotDecr	:= 0
Local nDifer		:= 0
Local nDifacre		:= 0
Local nDifdecre	:= 0
Local nCond			:= 0
Local dDtVenc		:= IIF(Empty(cCondDsd),dDataBase,m->e2_emissao)
Local nValorDSD
Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local lPerPc1		:= .T.
Local nCondd		:= 0
Local nConda		:= 0

Local lPccBaixa  := SuperGetMv("MV_BX10925",.T.,"2") == "1"
Local lIRPFBaixa := .F.
Local lF50DTDSD := ExistBlock("F50DTDSD")
Local lF050PRPC := ExistBlock("F050PRPC")

Local lInssBX   :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"

// Verifica se é IRPF pela Baixa para guardar os títulos que devem ter retenção
lIRPFBaixa :=	IIf( cPaisLoc == "BRA", ;
				Posicione("SA2",1,xfilial("SA2") + m->(E2_FORNECE+E2_LOJA),"A2_CALCIRF") == "2", .F. ) .And. ;
 		        IIf(cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN", ;
 		        Posicione("SED",1,xfilial("SED") + m->E2_NATUREZ ,"ED_CALCIRF") = "S", .F.)

If nVlrMR == 0
	nValorDSD	:= m->e2_valor
	nValorDSD	+= If(!lIRPFBaixa,m->e2_irrf,0)
	nValorDSD	+= If(!lCalcIssBx,m->e2_iss,0)
	nValorDSD	+= If(!lInssBX,m->e2_inss,0)
	nValorDSD	+= If(cPaisLoc == "BRA",m->e2_sest,0)
	nValorDSD	+= If(!lPccBaixa, m->e2_cofins + m->e2_csll + m->e2_pis, 0)
Else
	nValorDSD	:= nVlrMR
EndIf

If !lInssBx
	IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
		nValorDsd -= m->e2_inss
	Endif
Endif

//Zera valor dos impostos para evitar problemas no desdobramento
m->e2_valor		:= nValorDSD
m->e2_vlcruz	:= Round( NoRound( xMoeda(m->e2_valor,m->e2_moeda,1,m->e2_emissao,MsDecimais(1)+1,m->e2_txmoeda),MsDecimais(1)+1),MsDecimais(1))
m->e2_irrf		:= 0
m->e2_iss		:= 0
m->e2_inss		:= 0
m->e2_sest		:= 0
m->e2_cofins	:= 0
m->e2_csll		:= 0
m->e2_pis		:= 0
m->e2_vretirf	:= 0
m->e2_vretpis	:= 0
m->e2_vretcof	:= 0
m->e2_vretcsl	:= 0
m->e2_vretins	:= 0
m->e2_pretins	:= " "

//³ Ponto de Entrada F50DTDSD                               	³
//³ Utilizado para manipulacao de data inicial para os calculos³
//³ de vencimento das parcelas do desdobramento.					³
IF lF50DTDSD
	dDtVenc := ExecBlock("F50DTDSD",.F.,.F.)
Endif

//³ Ponto de Entrada F050PRPC                                	³
//³ Utilizado para manipulacao da aplica‡Æo ou nao do periodo  ³
//³ interparcela sobre a a primeira parcela, dever  retornar   ³
//³ retornar .T.(aplica)  ou .F. (nÆo aplica). Exemplo:		   ³
//³ Tendo como data inicial para calculo 10/02/2002, periodo   ³
//³ interparcela de 10 dias, e retorno .T., a data de vencto   ³
//³ inicial ser  20/02/2002. Caso retorno seja .F., a data     ³
//³ de vencto da primeira parcela ser  10/02/2002. Aplic vel   ³
//³ apenas quando NÇO se utilizar condicao de pagamento para   ³
//³ calculo dos titulos a serem gerados.                       ³
IF lF050PRPC .and. Empty(cCondDsd)
	lPerPc1 := ExecBlock("F050PRPC",.F.,.F.)
Endif

//³ Caso a data retornada pelo PE acima seja menor que a data  ³
//³ de emissao do titulo gerador do desdobramento, utilizo o   ³
//³ padrao de inicializacao da data inicial para calculo do    ³
//³ vencimento das parcelas.												³
If dDtVenc < m->e2_emissao
	If !Empty(cCondDsd)
		dDtVenc := m->e2_emissao
	Else
		dDtVenc := dDataBase
	Endif
Endif

If !Empty(cCondDsd)
	aParcelas := Condicao (nValorDsd	,cCondDsd,,dDtVenc)
	aParcacre := Condicao (m->e2_acresc ,cCondDsd,,dDtVenc)
	aParcdecre:= Condicao (m->e2_decresc,cCondDsd,,dDtVenc)
	//³ Corrige possiveis diferencas entre o valor total e o    	³
	//³ apurado ap¢s a divisao das parcelas								³
	For nCond := 1 to Len (aParcelas)
		nVlTotParc += aParcelas [ nCond, 2]
	Next
	If nVlTotParc != nValorDsd
		nDifer := round(nValorDsd - nVlTotParc,2)
		aParcelas [ Len(aParcelas), 2 ] += nDifer
	Endif
	If Len(aParcacre)>0
		For nConda := 1 to Len (aParcacre)
			nVlTotAcre += aParcacre [ nConda, 2]
		Next
		If nVlTotAcre != m->e2_acresc
			nDifacre := round(m->e2_acresc - nVlTotAcre,2)
			aParcelas [ Len(aParcelas), 2 ] += nDifacre
		Endif
	Endif
	If Len(aParcdecre)>0
		For nCondd := 1 to Len (aParcdecre)
			nVlTotDecr += aParcdecre [ nCondd, 2]
		Next
		If nVlTotAcre != m->e2_decresc
			nDifdecre := round(m->e2_decresc - nVlTotDecr,2)
			aParcdecre [ Len(aParcdecre), 2 ] += nDifdecre
		Endif
	Endif
Else
	//³ Verifica se o valor do titulo que est  sendo desdobrado ‚ o³
	//³ total, e por consequencia, divide por numero de parcelas ou³
	//³ caso seja o valor da parcela, gera n parcelas do valor.    ³
	If Left(cValorDsd,1) == "T"
		nValParc 	:= Round(NoRound((nValorDsd / nParceDsd),3),2)
		nValParcAc	:= Round(NoRound((m->e2_acresc / nParceDsd),3),2)
		nValParcDe	:= Round(NoRound((m->e2_decresc / nParceDsd),3),2)
	Else
		nValParc	:= nValorDsd
		nValParcAc	:= m->e2_acresc
		nValParcDe	:= m->e2_decresc
	Endif
	For nCond := 1 To nParceDsd
		If (nCond == 1 .and. lPerPc1) .or. nCond > 1
			dDtVenc += nPerioDsd
		Endif
		dDtVencRea := DataValida(dDtVenc,.T.)
		AADD ( aParcelas, { dDtVenc , nValParc } )
		AADD ( aParcacre, { dDtVenc , nValParcAc } )
		AADD ( aParcdecre, { dDtVenc , nValParcDe } )
		nVlTotParc += aParcelas [nCond,2]
		nVlTotAcre += aParcacre [nCond,2]
		nVlTotDecr += aParcdecre [nCond,2]
	Next
	If Left(cValorDsd,1) == "T"
		nDifer		:= Round(nValorDsd - nVlTotParc,2)
		nDifacre	:= Round(m->e2_acresc - nVlTotAcre,2)
		nDifdecre	:= Round(m->e2_decrescr - nVlTotDecr,2)
		aParcelas [ Len(aParcelas), 2 ] += nDifer
		aParcacre [ Len(aParcacre), 2 ] += nDifacre
		aParcdecre [ Len(aParcdecre), 2 ] += nDifdecre
	Endif
Endif
Return .T.

/*
±±³Fun‡…o	 ³A050TudoOK³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 08/09/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se dados para desdobramento estao corretos.		  ³±±
*/
Static Function A050TudoOk(cCondPgto,nParceDsd,cValorDsd,nPerioDsd)
Local lOk := .T.
Local nTotalCto := 0
Local nMinRG3806 := SuperGetMV("MV_RG3806",.T.,0)
Local aTotParc := {}
Local dDtVenc		:= IIF(Empty(cCondPgto),dDataBase, M->E2_EMISSAO)

If Empty (cCondPgto)
	If nParceDsd < 2 .or. nParceDsd > nMaxParc .or.	Empty(cValorDsd).or.	nPerioDsd <= 0
		Help(" " , 1 , "FA050DADOS")
		lOk := .F.
	Endif
Else
	If dDtVenc < M->E2_EMISSAO
		dDtVenc := M->E2_EMISSAO
	Endif

	aTotParc := Condicao (M->E2_VALOR, cCondPgto, ,dDtVenc)

	If Len(aTotParc) > (nMaxParc + 1)
		Help(" " , 1 , "FA050DADOS")
		lOk := .F.
	EndIf
Endif

If lOk
	lOk := PcoVldLan("000002","03","FINA050")
Endif

If Empty (cCondPgto) .And. cPaisLoc == "ARG"
	If Left(cValorDsd,1) == "T"
		nTotalCto 	:= Round(NoRound((M->E2_VLCRUZ / nParceDsd),3),2)
	Else
		nTotalCto	:= M->E2_VLCRUZ
	EndIf
	If nTotalCto < nMinRG3806
		MSGINFO(Replace(STR0267, "#cValMin#", Alltrim(Str(nMinRG3806))), STR0268)
		lOK := .F.
	EndIf
EndIf

Return lOk

/*
±±³Fun‡…o	 ³F050Ajuda ³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 08/09/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Help para campos do desdobramento.                 		  ³±±
*/
Function F050Ajuda (nOpcHlp)

If nOpcHlp == 1    		// Condicao de Pagamento
	Help(" ",1,"CCONDPGTO")
Elseif nOpcHlp == 2   	// Numero de Parcelas
	Help(" ",1,"NPARCELAS")
Elseif nOpcHlp == 3   	// Tipo do Valor (Total / Parcela)
	Help(" ",1,"CVALORDSD")
Elseif nOpcHlp == 4   	// Periodo de vencto (em dias)
	Help(" ",1,"NPERIODSD")
ElseIf nOpcHlp == 5   		// Historico do desdobramento
	Help(" ",1,"CHISTDSD")
Endif
Return .T.

/*/
±±³Fun‡…o	 ³FA050iss	³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 07/11/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza o ISS do t¡tulo.								  ³±±
/*/
Function Fa050ISS()
LOCAL nValor
Local lContrRet := .T.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local lVerMinIss := .T.
Local cForMinISS 	:= GetNewPar("MV_FMINISS","1")
Local lF050AISS := ExistBlock("F050AISS")

If lAltera
	//³ Caso tenha contabilizado, nao posso alterar valores no titulo.     ³
	IF SE2->E2_LA = "S"
		Help(" ",1,"NAOVALOR")
		Return( .F. )
	EndIF
	If SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
		Help( " ",1,"FA040ADTO")
		Return( .F. )
	Endif
	If SE2->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"SES"+"/"+"INA"
		Help( " ",1,"F050IMPOST")
		Return( .F. )
	Endif
Endif

If m->e2_tipo $ MVPAGANT+"/"+MV_CPNEG .and. GetMv("MV_IMPADT") != "S"
	Help( " ",1,"FA040ADTO")
	Return( .F. )
Endif
If m->e2_tipo $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"SES"+"/"+"INA"
	Help( " ",1,"F050IMPOST")
	Return( .F. )
Endif

If nOldISS == m->e2_iss
	Return( .T. )
Else
	lAltValor := .T.
EndIf

//³Guarda valor anterior do ISS para reconstituir valor original  ³
//³apenas se for alteracao. Verifica tamb‚m se foi alterada a natu³
//³reza, pois essa alteracao causava problemas na reconstitui‡„o  ³
//³do valor original.                                             ³
If SE2->E2_ISS != 0 .and. m->e2_iss == 0 .and.;
	SE2->E2_NATUREZ == m->e2_naturez .and. lAltera
	nOldISS := SE2->E2_ISS
Endif

If lBtrISS
	If SE2->E2_BTRISS != 0 .and. m->e2_btriss == 0 .and.;
		SE2->E2_NATUREZ == m->e2_naturez .and. lAltera
		nOldBtrISS := SE2->E2_BTRISS
	Endif
EndIf

If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN" .And. ;
M->E2_FRETISS == "2" // Nao verificar minimo do ISS
	lVerMinIss := .F.
Endif

dbSelectArea("SED")
dbSeek(cFilial+m->e2_naturez)
If lVerMinIss .and.;
((cForMinISS == "1" .And. M->E2_ISS <= SuperGetMv("MV_VRETISS",.F., 0)) .Or. ;
(cForMinISS == "2" .And. M->E2_VALOR <= GetNewPar("MV_VBASISS",0)))
	M->E2_ISS := 0
EndIf

If (!lCalcIssBx) .OR. ( lCalcIssBx .AND. M->E2_TIPO $ MVPAGANT )
	nValor := M->E2_VALOR + nOldISS + nOldBtrISS
	M->E2_VALOR := nValor - M->E2_ISS - If(lBtrISS,M->E2_BTRISS,0)
	M->E2_VRETISS := M->E2_ISS
	If lBtrISS
		M->E2_VRETBIS := M->E2_BTRISS
	EndIf
Endif

//³ Inicializa o valor em cruzeiro como sugestao			³
nSavRec := SX3->(Recno())
cMascara:=PesqPict("SE2","E2_VLCRUZ",19,MsDecimais(1))
SX3->(DbGoto(nSavRec))
M->E2_VLCRUZ:=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))
M->E2_SALDO := m->e2_valor
nOldValor 	:= m->e2_valor
nOldSaldo 	:= m->e2_saldo
nOldISS	:= m->e2_iss
If lBtrISS
	nOldBtrISS := m->e2_btriss
EndIf
lRefresh := .T.

//Caso controle retencao (lei 10925) e seja pela baixa
If lContrRet .And. lPccBaixa .And. !(M->E2_TIPO $ MVPAGANT)
	FA050NAT2(.T.)
Endif

If lF050AISS
	ExecBlock("F050AISS",.F.,.F.)
EndIf

Return .t.

/*/
±±³Fun‡…o	 ³FA050CIDE ³ Autor ³ Patricia A. Salomao   ³ Data ³ 10/05/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza o CIDE do t¡tulo.						         		  ³±±
/*/
Function Fa050CIDE()

Local lContrRet := .T.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

If lAltera
	//³ Caso tenha contabilizado, nao posso alterar valores no titulo.     ³
	IF SE2->E2_LA = "S"
		Help(" ",1,"NAOVALOR")
		Return( .F. )
	EndIF
	If SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
		Help( " ",1,"FA040ADTO")
		Return( .F. )
	Endif
	If M->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"CID"+"/"+"INA"
		Help( " ",1,"F050IMPOST")
		Return( .F. )
	Endif
Endif

If m->e2_tipo $ MVPAGANT+"/"+MV_CPNEG
	Help( " ",1,"FA040ADTO")
	Return( .F. )
Endif
If m->e2_tipo $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"CID"+"/"+"INA"
	Help( " ",1,"F050IMPOST")
	Return( .F. )
Endif
If nOldCID == m->e2_cide
	Return( .T. )
EndIf

lFirstAlt := .F.

//³ Inicializa o valor em Real como sugestao			³
nSavRec := SX3->(Recno())
cMascara:=PesqPict("SE2","E2_VLCRUZ",19,MsDecimais(1))
SX3->(DbGoto(nSavRec))
M->E2_VLCRUZ:=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))
nOldValor 	:= m->e2_valor
nOldSaldo 	:= m->e2_saldo
nOldCID    := m->e2_cide
lRefresh 	:= .T.

//Caso controle retencao (lei 10925) e seja pela baixa
If lContrRet .And. lPccBaixa .And. !(M->E2_TIPO $ MVPAGANT)
	FA050NAT2(.T.)
Endif

Return .t.

/*/
±±³Fun‡…o	 ³FA050irr	³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 07/11/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza o IRR do t¡tulo.											  ³±±
/*/
Function Fa050IRR()

LOCAL nValor

Local lContrRet := .T.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"


// Controla IRPF na Baixa
Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)


// Carrega variavel de verificacao de consideracao de valor minimo de retencao de IR.
Local lAplMinIR := .F.

If lAltera
	//³ Caso tenha contabilizado, nao posso alterar valores no titulo.     ³
	IF SE2->E2_LA = "S"
		Help(" ",1,"NAOVALOR")
		Return( .F. )
	EndIF
	If SE2->E2_TIPO $ MVPAGANT
		Help( " ",1,"FA040ADTO")
		Return( .F. )
	Endif
	If SE2->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"SES"+"/"+"INA"
		Help( " ",1,"F050IMPOST")
		Return( .F. )
	Endif
Endif

If m->e2_tipo $ MVPAGANT+"/"+MV_CPNEG .and. GetMv("MV_IMPADT") != "S"
	Help( " ",1,"FA040ADTO")
	Return( .F. )
Endif
If m->e2_tipo $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"SES"+"/"+"INA"
	Help( " ",1,"F050IMPOST")
	Return( .F. )
Endif

If nOldIRR == m->e2_irrf
	Return( .T. )
Else
	lAltValor := .T.
EndIf

If ( SA2->A2_TIPO == "F" .and. SA2->A2_CALCIRF == "2" )
	If !( M->E2_IRRF == 0 )
		MsgAlert(OemToAnsi(STR0207),OemToAnsi(STR0026)) // Para Fornecedores - Pessoa Física com retenção na baixa de IRRF não é possível informar valores neste campo. Atencao
		Return ( .F. )
	EndIf
EndIf

//³Guarda valor anterior do IRRF para reconstituir valor original ³
//³apenas se for alteracao. Verifica tamb‚m se foi alterada a natu³
//³reza, pois essa alteracao causava problemas na reconstitui‡„o  ³
//³do valor original.                                             ³
If SE2->E2_IRRF != 0 .and. m->e2_irrf == 0 .and. ;
SE2->E2_NATUREZ == m->e2_naturez .and. lAltera
	nOldIRR := SE2->E2_IRRF
Endif

dbSelectArea("SED")
dbSeek(cFilial+m->e2_naturez)

// Verifica se o fornecedor trata o valor minimo de retencao.
// 1 - Não considera  2 - Considera o parâmetro MV_VLRETIR
If cPaisLoc == "BRA" .and. SA2->A2_MINIRF == "2"
	lAplMinIR := .T.
Endif

If lAplMinIR .And. (M->E2_IRRF <= GetMv("MV_VLRETIR")) .And. nOldIRR == 0
	M->E2_IRRF := 0
EndIf
nValor := m->e2_valor + Iif(lIRPFBaixa,0,nOldIRR)
m->e2_valor := nValor - m->e2_irrf
m->e2_saldo := m->e2_valor
If !lIRPFBaixa
	M->E2_VRETIRF := M->E2_IRRF
EndIf
//³ Atualiza valores na tela											³
//³ Inicializa o valor em Real como sugestao			³
nSavRec := SX3->(Recno())
cMascara:=PesqPict("SE2","E2_VLCRUZ",19,MsDecimais(1))
SX3->(DbGoto(nSavRec))
M->E2_VLCRUZ:=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))

nOldValor 	:= m->e2_valor
nOldSaldo 	:= m->e2_saldo
nOldIRR		:= m->e2_irrf
lRefresh 	:= .T.

//Caso controle retencao (lei 10925) e seja pela baixa
If lContrRet .And. lPccBaixa .And. !(M->E2_TIPO $ MVPAGANT)
	FA050NAT2(.T.)
Endif

Return .t.

/*/
±±³Fun‡…o	 ³FA050inss ³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 21/01/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza o INSS do t¡tulo.											  ³±±
/*/
Function Fa050INSS()

LOCAL nValor
Local lContrRet := .T.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local lFinVldIns  := Existblock("FinVldIns")
Local lInssBX :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
If lAltera
	//³ Caso tenha contabilizado, nao posso alterar valores no titulo.     ³
	IF SE2->E2_LA = "S"
		Help(" ",1,"NAOVALOR")
		Return( .F. )
	EndIF
	If SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
		Help( " ",1,"FA040ADTO")
		Return( .F. )
	Endif
	If M->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"INA"
		Help( " ",1,"F050IMPOST")
		Return( .F. )
	Endif
Endif

If m->e2_tipo $ MV_CPNEG
	Help( " ",1,"FA040ADTO")
	Return( .F. )
Endif
If m->e2_tipo $ MVPAGANT .and. GetMv("MV_IMPADT") != "S"
	Help( " ",1,"FA040ADTO")
	Return( .F. )
Endif
If m->e2_tipo $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"INA"
	Help( " ",1,"F050IMPOST")
	Return( .F. )
Endif

If nOldInss == m->e2_inss
	Return( .T. )
Else
	lAltValor := .T.
EndIf

If lInssBX
	Return( .T. )
Endif
//³Guarda valor anterior do INSS para reconstituir valor original ³
//³apenas se for alteracao. Verifica tamb‚m se foi alterada a natu³
//³reza, pois essa alteracao causava problemas na reconstitui‡„o  ³
//³do valor original.                                             ³
If SE2->E2_INSS != 0 .and. m->e2_inss == 0 .and. ;
	SE2->E2_NATUREZ == m->e2_naturez .and. lAltera
	nOldInss := IIF(lFirstAlt , SE2->E2_INSS , nVlAltInss )
Endif

// Se Vlr. for Baixo e nao for Pessoa Fisica, nao considera
If (M->E2_INSS < GetMv("MV_VLRETIN")) .AND. SA2->A2_TIPO <> "F" .AND. (IIF(lFinVldIns, Execblock("FinVldIns",.F.,.F., {} ), .T. )) .And. !lInssBX
	M->E2_INSS := 0
EndIf

dbSelectArea("SED")
dbSeek(cFilial+m->e2_naturez)

If !INCLUI .Or. M->E2_DESDOBR == "N" //Ajuste para que não recomponha o valor do título no desdobramento
	IF SED->ED_DEDINSS $ "1 "  //desconta o INSS do principal
		nValor := m->e2_valor + nOldInss
		m->e2_valor := nValor - m->e2_inss
	Endif
Endif

nVlaltInss := m->e2_inss
lFirstAlt := .F.
M->E2_VRETINS := M->E2_INSS
//³ Inicializa o valor em Real como sugestao			³
nSavRec := SX3->(Recno())
cMascara:=PesqPict("SE2","E2_VLCRUZ",19,MsDecimais(1))
SX3->(DbGoto(nSavRec))
M->E2_VLCRUZ:=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))
M->E2_SALDO := m->e2_valor
nOldValor 	:= m->e2_valor
nOldSaldo 	:= m->e2_saldo
nOldInss		:= m->e2_inss
lRefresh 	:= .T.

//Caso controle retencao (lei 10925) e seja pela baixa
If lContrRet .And. lPccBaixa .And. !(M->E2_TIPO $ MVPAGANT)
	FA050NAT2(.T.)
Endif

Return .t.

/*/
±±³Fun‡…o	 ³FA050SEST ³ Autor ³ Patricia A. Salomao   ³ Data ³ 10/05/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza o SEST do t¡tulo.						         		  ³±±
/*/
Function Fa050SEST()

LOCAL nValor

Local lContrRet := .T.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

If lAltera
	//³ Caso tenha contabilizado, nao posso alterar valores no titulo.     ³
	IF SE2->E2_LA = "S"
		Help(" ",1,"NAOVALOR")
		Return( .F. )
	EndIF
	If SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
		Help( " ",1,"FA040ADTO")
		Return( .F. )
	Endif
	If M->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"SES"+"/"+"INA"
		Help( " ",1,"F050IMPOST")
		Return( .F. )
	Endif
Endif

If m->e2_tipo $ MVPAGANT+"/"+MV_CPNEG
	Help( " ",1,"FA040ADTO")
	Return( .F. )
Endif
If m->e2_tipo $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"SES"+"/"+"INA"
	Help( " ",1,"F050IMPOST")
	Return( .F. )
Endif
If nOldSEST == m->e2_sest
	Return( .T. )
EndIf

//³Guarda valor anterior do SEST para reconstituir valor original ³
//³apenas se for alteracao. Verifica tamb‚m se foi alterada a natu³
//³reza, pois essa alteracao causava problemas na reconstitui‡„o  ³
//³do valor original.                                             ³
If SE2->E2_SEST != 0 .and. m->e2_sest == 0 .and. ;
SE2->E2_NATUREZ == m->e2_naturez .and. lAltera
	nOldSEST := IIF(lFirstAlt , SE2->E2_SEST , nVlAltSEST )
Endif

dbSelectArea("SED")
dbSeek(cFilial+m->e2_naturez)

nValor := m->e2_valor + nOldSEST
m->e2_valor := nValor - m->e2_sest
nVlaltSEST := m->e2_sest
lFirstAlt := .F.

//³ Inicializa o valor em Real como sugestao			³
nSavRec := SX3->(Recno())
cMascara:=PesqPict("SE2","E2_VLCRUZ",19,MsDecimais(1))
SX3->(DbGoto(nSavRec))
M->E2_VLCRUZ:=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))
nOldValor 	:= m->e2_valor
nOldSaldo 	:= m->e2_saldo
nOldSEST	:= m->e2_sest
lRefresh 	:= .T.

//Caso controle retencao (lei 10925) e seja pela baixa
If lContrRet .And. lPccBaixa .And. !(M->E2_TIPO $ MVPAGANT)
	FA050NAT2(.T.)
Endif

Return .t.

//-------------------------------------------------------------------
/*/{Protheus.doc}FA050Nat2
Calcula os impostos quando se muda o valor

@author Wagner Xavier
@since  28/04/92
/*/
//-------------------------------------------------------------------
Function FA050NAT2(lVlOnlyRet)

Local nx		 := 0
Local nValInss   := 0
Local nValSEST   := 0
Local nValFrete  := 0
Local nValIRRF   := 0
Local nPercIss   := 0
Local nLimInss   := GetMv("MV_LIMINSS",.F.,0)
Local nINSSRet   := 0 //--Valor do INSS retido no periodo
Local aAreaSE2   := {}
Local aAreaSED   := {}
Local lAplicaTP  := .T.
Local lRndVlIss  := SuperGetMv("MV_RNDISS",.F.,.F.)
Local nBaseIrrf  := 0
Local nValCIDE   := 0
Local nBaseDep   := GetMV("MV_TMSVDEP",,0)
Local nValDep    := 0
Local nBasePCC   := 0
Local lOk       := .T.
Local lF050FCTC := ExistBlock('F050FCTC')

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)

//Base IRPF na baixa
Local lBaseIRPF	 := F050BIRPF()
Local lCpBaseIR	:= cPaisLoc == "BRA"

// Carrega variavel de verificacao de consideracao de valor minimo de retencao de IR.
Local lAplMinIR := .F.
Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
//-- Optante pelo simples
Local lSimples := cPaisLoc == "BRA" .and. SA2->A2_CALCIRF == "3"

//-- Empresa Individual
Local lEmprInd := cPaisLoc == "BRA" .and. SA2->A2_CALCIRF == "4"

Local lVerMinIss 	:= .T.
Local cForMinISS 	:= GetNewPar("MV_FMINISS","1")
Local lAplVlMin   := .T.
Local lCpoVlMin   := .T.
Local lPaBruto		:= GetNewPar("MV_PABRUTO","2") == "1"  //Indica se o PA terá o valor dos impostos descontados do seu valor
Local cTipUso     := IIf(nModulo==43,"1","2")
Local nIrfInss    := 0
Local cQuery      := ""
Local cAliasQry 	:= ""

//Verifica se os campos utilizados para o imposto CIDE.
Local lCIDE  := cPaisLoc == "BRA"
Local nCalcInss	:= 0
Local nINSSTot 	:= 0

Local cTipCTC    := Padr( SuperGetMv("MV_TPTCTC",.T.,""), Len( SE2->E2_TIPO ) )    // Tipo Contrato de Carreteiro
Local cVenctoPF  := SuperGetMv("MV_ACMIRPF",.T.,"2")  //1 = Emissao    2= Vencimento Real	3=Data Contabilizacao
Local cAglImPJ	 := SuperGetMv("MV_AGLIMPJ",.T.,"1")
Local lVretIrf   := .T.
Local nLoop      := 0
Local aFilial	 := {}
Local aCliFor	 := {}
Local cArqTmp	 := ""
Local lDelTrbIR := .T.
Local lIrpfCAr	:= cPaisLoc == "BRA"
Local lBaseDif	:= cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN"
Local lBaseCar	:= cPaisLoc == "BRA"
Local lFina050	:= FUNNAME()=="FINA050"
Local lDedIns	:= (SuperGetMv("MV_INSIRF",.F.,"2") == "1")

Local nBaseIss	:= 0
Local nBaseIns	:= 0

//Base de imposto Variavel
Local lBaseImp	:= F050BSIMP(2) 	//Verifica a existência dos campos e o calculo de impostos
Local lCpoValor	:= .F.
Local cField	:= readvar()
Local lF050GRVL	:= ExistBlock("F050GRVL") // ponto de entrada para resgatar o valor E2_VALOR antes que o sistema efetue qualquer calculo de imposto (EIC)
Local lValFre   := .F.
Local lFinVldIns := Existblock("FinVldIns")
Local lEasyFin	:= GetNewPar("MV_EASYFIN","N")=="S"
Local lRefImp	:= SuperGetMv('MV_REFIMP',,.F.)  //-- Usado pelo TMS com Operadora de Frota
Local lTmsOper	:= SuperGetMv('MV_VSREPOM',,'1')  == '2' .And. SuperGetMv('MV_TMSOPDG',,'1')  == '2'
Local lAltVcto	:= "E2_VENCREA" $ Upper(AllTrim(ReadVar())) .and. M->E2_VALOR == 0 // Altera valor somente em determinado momento
//Variavel indica se irá provisionar os impostos de INSS e ISS na inclusão da PA, deduzindo-os do valor de adiantamento.
Local lPrImPA := !lPaBruto .And. (SuperGetMv("MV_PAPRIME",.T.,"2") == "1")

//--- Tratamento Gestao Corporativa
Local lGestao   := Iif( lFWCodFil, FWSizeFilial() > 2, .F. )	// Indica se usa Gestao Corporativa
//
Local cFilFwSE2 := IIF( lGestao , FwFilial("SE2") , xFilial("SE2") )
Local cFilFwSA2 := IIF( lGestao , FwFilial("SA2") , xFilial("SA2") )
Local nVlMinImp := GetNewPar("MV_VL10925",5000)
Local nCalcIr	:=	0
Local lInssBx   :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"  // Controla INSS na Baixa
Local lAcmPJ 	:= SuperGetMv("MV_INSACPJ",.T.,"2") == "1"  //1 = Acumula    2= Não acumula
Local nParciais	:=	0
Local nMinINS1  := SuperGetMv("MV_MININSS",.F.,0)
Local nMinINS2  := SuperGetMv("MV_VLRETIN",.F.,0)
Local lInsPub   :=	SuperGetMv("MV_INSPUB",,.F.) .And. nMinINS1 == 0 .And.;
					nLimInss == 0 .And. nMinINS2 == 0 //Inss Baixa com empresa publica. Neste caso os valores do inss não tem valor minimo ou maximo de retencao.
Local lJaDescIr := .F.
Local aPCC		:= Array(4)
Local lEmpPub   :=  IsEmpPub()
Local nVencto 	:= SuperGetMv("MV_VCPCCP",.T.,1)
Local nVlMPub	:= SuperGetMv("MV_VLMPUB",.T.,10)
Local dRef		:= dDatabase
Local lSumIR    := .F.
Local nValIrOld := 0
Local cChaveSA2 := ""
Local aAreaSA2	:= {}
Local lAplMinP := .F.
Local nTotIss	:= 0
Local nVRetISS	:= 0
Local nTotBasISS := 0
Local lDedIss	:= SuperGetMv("MV_DEDISS", .F., "1") == "2"
Local cDbMs  := UPPER(TcGetDb())
Local lF050PISS := ExistBlock("F050PISS")
Local lF050INBR := ExistBlock("F050INBR")
Local nBasM2Irf := 0
Local lRndSest  := SuperGetMv("MV_RNDSEST",.F.,.F.)
Local lDsdobra	:= If(FindFunction("PrinDesdobr"), PrinDesdobr(), M->E2_DESDOBR == "S" )
Local aISSCPOM	:= {}	// 1pos - UF, 2pos - Municipio, 3pos - Aliquota, 4pos - Vlr.Min
Local cFunname	:= FUNNAME()

//Variaveis declaradas para uso da F080TotMes(), que varre o SE5 buscando os titulos que estao pendente recolhimento (pis, cofins e csll)
Private nPis        := 0
Private nCofins     := 0
Private nCsll       := 0
Private nValPgto    := 0
Private nIrrf       := 0
Private nOldValPgto := 0
//Republica Dominicana
Private nImpost01	:= 0
Private nImpost02   := 0
Private aImpostos  	:= {}
Private nPos        := 0
Default lVlOnlyRet 	:= .F.

aPCC[1] := .F.

If lRefImp .And. lTmsOper .And. (FwIsInCallStack('TMSQUITAC') .Or. FwIsInCallStack('TMA250SE2'))
	lVlOnlyRet := .T.
EndIf

IF lCpoValor .AND. lF050GRVL
	ExecBlock("F050GRVL",.F.,.F.)
Endif

If Type("lF050Auto")=="U"
	If cFunname == "FINA450" .and. Type("lF080Auto")<>"U"
		lF050Auto:=.T.
		If Type("lAltera")=="U"
			lAltera := .T.
		EndIf
	Else
		lF050Auto:=.F.
	EndIf
EndIf

//Evitar o recálculo dos impostos ao alterar somente o vencimento do título que retem impostos somente na emissão
If lAltera .And. M->E2_VALOR == nOldValor .And. cField $ "M->E2_VALOR|M->E2_VENCREA|M->E2_VENCTO" .And.;
	cFunname $ "FINA050|FINA750" .And. (!lPCCBaixa .Or. M->E2_CSLL + M->E2_COFINS + M->E2_PIS == 0) .And.;
	(!lIRPFBaixa .Or. M->E2_IRRF == 0 ) .And. (!lInssBX .Or. M->E2_INSS == 0 ) .And. (!lCalcIssBx .Or. M->E2_ISS == 0)
	Return .T.
EndIf

If FwIsInCallStack("FINA631") .And. SuperGetMv("MV_IMPTRAN",.F.,"1") == "2"
	nX := Ascan(aAutoCab, {|e| AllTrim(e[1]) == "E2_VALOR"})
	M->E2_VALOR := aAutoCab[nX][2]
	nX := Ascan(aAutoCab, {|e| AllTrim(e[1]) == "E2_VLCRUZ"})
	M->E2_VLCRUZ := aAutoCab[nX][2]
	nX := Ascan(aAutoCab, {|e| AllTrim(e[1]) == "E2_SALDO"})
	M->E2_SALDO := aAutoCab[nX][2]
EndIf

If lEasyFin .And. Type( "n050ValBru" ) == "N" .And. !lVlOnlyRet
	If M->E2_MOEDA == 1
		n050ValBru := M->E2_VALOR            // Variavel criada pelo módulo SIGAEIC, com a função de agregar o valor bruto do título
	Else
		If Empty(M->E2_TXMOEDA)
			n050ValBru := M->E2_VALOR * RecMoeda(M->E2_EMISSAO, M->E2_MOEDA)
		Else
			n050ValBru := M->E2_VALOR * M->E2_TXMOEDA
		EndIf
	EndIf
EndIf

If lAltera .and. (cField <> "M->E2_VENCREA")
	//Caso tenha contabilizado, nao posso alterar valores no titulo
	IF SE2->E2_LA = "S"
		Help(" ",1,"NAOVALOR")
		Return( .F. )
	EndIF
	If SE2->E2_TIPO $ MVPAGANT
		Help( " ",1,"FA040ADTO")
		Return( .F. )
	Endif
	If SE2->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"SES"+"/"+"INA"
		Help( " ",1,"F050IMPOST")
		Return( .F. )
	Endif
	If cPaisLoc $ "DOM|COS"
		If 	SE2->E2_TIPO $ MVABATIM
			Help( " ",1,"F050IMPOST")
			Return( .F. )
		EndIf
		If 	SUBSTR(SE2->E2_ORIGEM,1,4) <> "FINA"
			Help( " ",1,"F050IMPOST")
			Return( .F. )
		Endif
	EndIf
Endif

//Forcar o posicionamento do fornecedor, que pode entrar na rotina desposicionado
dbSelectArea("SA2")
cChaveSA2 := xFilial("SA2") + M->(E2_FORNECE + E2_LOJA)

If lF050Auto
	cChaveSA2 := xFilial("SA2") + M->E2_FORNECE + SPACE(TamSx3("E2_FORNECE")[1] - LEN(M->E2_FORNECE)) + M->E2_LOJA + SPACE(TamSx3("E2_LOJA")[1] - LEN(M->E2_LOJA))
EndIf

SA2->(dbSeek(cChaveSA2))

lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)

// Verifica se o fornecedor trata o valor minimo de retencao. 1 - Não considera  2 - Considera o parâmetro MV_VLRETIR
If cPaisLoc == "BRA" .and. SA2->A2_MINIRF == "2"
	lAplMinIR := .T.
Endif

If cField == "M->E2_VALOR"
	nValBruto := M->E2_VALOR
	nValDig := M->E2_VALOR
	lCpoValor := .T.
EndIf

//Alteração de campos que podem influenciar no calculo da base de impostos (baixa)
If cField $ "M->E2_MOEDA|M->E2_TXMOEDA" .and. lIRPFBaixa
	lCpoValor := .T.
Endif

If !(cField $ "M->E2_IRRF|M->E2_TXMOEDA|M->E2_INSS|M->E2_SEST|") .And. (M->E2_VALOR <> nValDig)
	M->E2_VALOR := nValDig
Endif

If SA2->A2_MINPUB == "2"
	lAplMinP := .T.
EndIF

If cField == "M->E2_MOEDA" .And. M->E2_MOEDA < 2
	M->E2_TXMOEDA := 0
EndIf

//motor de retençoes
If lTemMR
	F050VldImp(.F.)
EndIf

dbSelectArea("SED")

If !dbSeek(cFilial + M->E2_NATUREZ)
	Return( .T. )
EndIf

If cField == "M->E2_CODISS"
	If SED->ED_CALCISS <> "S"
		Return( .T. )
	ElseIf !( M->E2_TIPO $ MVPAGANT ) .and. M->E2_VALOR < nValDig
		//Efetuo a soma dos impostos novamente para não serem descontadas em duplicidade abaixo
		M->E2_VALOR += Iif(!lIrfMR .And. lIRPFBaixa, 0, M->E2_IRRF) + Iif(!lInsMR .And. lInssBx, 0, M->E2_INSS ) + Iif(!lIssMR .And. lCalcIssBx, 0, M->E2_ISS)
	EndIf
EndIf

lIRProg := IIf(cPaisLoc == "BRA",IIf(!Empty(SA2->A2_IRPROG),SA2->A2_IRPROG,"2"),"2")

If (!lF050Auto .And. ( nOldValor == m->e2_valor ) ) .and. ProcName(1) != "F050CALCRT"
	If !lPCCBaixa .And. !M->E2_TIPO $ MVPAGANT .AND. !("M->E2_FRETISS" $ Readvar()) .And. (!lIRPFBaixa .and. !lBaseImp)
		//Caso a chamada tenha sido feita pela rotina Fa050Subst, nao sair
		If Select("__SUBS") == 0
			Return( .T. )
		Endif
	ElseIf  M->E2_TIPO $ MVPAGANT  //Se for PA (geracao de tx's pela emissao), compoe o valor novamente.
		// Caso a funcao Fa050Nat2 tenha sido chamada a partir da alteracao dos campos de Irrf (.T.), Inss e Iss,
		// Fazemos os recalculos dos impostos da lei 10925  sem e fazer a recarga dos valores destes campos.
		If !lVlOnlyRet
			If !lSestMR
				m->e2_valor := m->e2_valor +  m->e2_sest
			EndIf

			// Tratamento Moeda Estrangeira
			If M->E2_MOEDA == 1
				m->e2_valor += If( !lIrfMR .and. !lIRPFBaixa ,m->e2_irrf , 0)
				m->e2_valor += If( !lIssMR .and. !lCalcIssBx ,m->e2_iss  , 0)
				m->e2_valor += If( !lInsMR .and. !lInssBX ,m->e2_inss  , 0)
			Else
				m->e2_valor += If( !lIrfMR .and. !lIRPFBaixa ,Round(xMoeda(m->e2_irrf,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,nOldTxMoeda),MsDecimais(1)) , 0)
				m->e2_valor += If( !lIssMR .and. !lCalcIssBx ,Round(xMoeda(m->e2_iss,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,nOldTxMoeda),MsDecimais(1)) , 0)
				m->e2_valor += If( !lInsMR .and. !lInssBX ,Round(xMoeda(m->e2_inss,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,nOldTxMoeda),MsDecimais(1)) , 0)

				// PCC
				If !lPccMR
					nOldpis		:= Round(xMoeda(nOldpis,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,nOldTxMoeda),MsDecimais(1))
					nOldCofins	:= Round(xMoeda(nOldCofins,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,nOldTxMoeda),MsDecimais(1))
					nOldCsll	:= Round(xMoeda(nOldCsll,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,nOldTxMoeda),MsDecimais(1))
				Endif
			EndIf

			If !lPccBaixa .or. (lPccBaixa .and. M->E2_TIPO $ MVPAGANT)
				If !lPccMR
					//Caso seja chamado da alteracao
					If lAltera
						//Se reteve PIS - Somo ao valor do titulo
						If M->E2_PRETPIS == ' '
							M->E2_VALOR += nOldpis
						Endif

						//Se reteve COFINS - Somo ao valor do titulo
						If M->E2_PRETCOF == ' '
							M->E2_VALOR += nOldCofins
						Endif

						//Se reteve CSLL - Somo ao valor do titulo
						If M->E2_PRETCSL == ' '
							M->E2_VALOR += nOldCsll
						Endif

						If M->E2_VALOR <> M->E2_BASEPIS
							M->E2_SALDO += (nOldPis + nOldCofins + nOldCsll)
						Endif
					Else //Inclusao
						If nOldValor <> M->E2_VALOR
							M->E2_VALOR += nOldpis + nOldCofins + nOldCsll
						EndIf
					Endif
				EndIf
			Endif
		Else
			If M->E2_TIPO $ MVPAGANT .and. !lPaBruto
				If !lIrfMR
					m->e2_valor += m->e2_irrf
				EndIf
				If !lIssMR .And. !lCalcIssBx
					m->e2_valor += m->e2_iss
				EndIf
				If !lIssMR .and. lBtrISS
					m->e2_valor += m->e2_btriss
				Endif
				If !lInsMR .And. !lInssBx
					m->e2_valor += m->e2_inss
				EndIf
			Endif
		Endif
	Endif
EndIf

//Caso seja um titulo originador de desdobramento.
If lDsdobra
	Return( .T. )
Endif

If lRefImp .And. lTmsOper .And. (FwIsInCallStack('TMSQUITAC') .Or. FwIsInCallStack('TMA250SE2'))
	lBaseImp := .F.
EndIf

//Base Impostos diferenciada
If lBaseImp .and. !lF050Auto
	//Para os casos onde foi alterada a natureza e a nova natureza passa a calcular impostos Alimento a base de impostos
	If M->E2_BASEIRF == 0 .or. lCpoValor
	//Alimento a base de impostos
		If !lIrfMR .And. (M->E2_BASEIRF == 0 .or. lCpoValor)
			If lIrpfCAr .and. SED->ED_IRRFCAR=='S' .and. lBaseCar .and. SED->ED_BASEIRC > 0
				M->E2_BASEIRF :=	If(nVlrMR > 0, nVlrMR, M->E2_VALOR) * (SED->ED_BASEIRC/100)
			Elseif !lIRPFBaixa .and. lBaseDif .and. SED->ED_BASEIRF > 0
				M->E2_BASEIRF :=	If(nVlrMR > 0, nVlrMR, M->E2_VALOR) * (SED->ED_BASEIRF/100)
			Else
				M->E2_BASEIRF :=	If(nVlrMR > 0, nVlrMR, M->E2_VALOR)
			Endif
		Endif
	Endif
	If !lPccMR
		If M->E2_BASEPIS == 0 .or. lCpoValor
			If !(!lPccBaixa .And. lAltera .And. M->E2_BASEPIS > M->E2_VALOR .And. M->E2_VALOR <= nVlMinImp)
				M->E2_BASEPIS :=	If(nVlrMR > 0, nVlrMR, M->E2_VALOR)
			Endif
		Endif

		If M->E2_BASECOF == 0 .or. lCpoValor
			If !(!lPccBaixa .And. lAltera .And. M->E2_BASECOF > M->E2_VALOR .And. M->E2_VALOR <= nVlMinImp)
				M->E2_BASECOF :=	If(nVlrMR > 0, nVlrMR, M->E2_VALOR)
			Endif
		Endif

		If M->E2_BASECSL == 0 .or. lCpoValor
			If !(!lPccBaixa .And. lAltera .And. M->E2_BASECSL > M->E2_VALOR .And. M->E2_VALOR <= nVlMinImp)
				M->E2_BASECSL :=	If(nVlrMR > 0, nVlrMR, M->E2_VALOR)
			Endif
		Endif
	EndIf

	If M->E2_BASEISS == 0 .or. lCpoValor .or. (cField == "M->E2_BASEISS" .and. !IsInCallStack('PLSA470'))
		M->E2_BASEISS :=	M->E2_VALOR
	Endif

	If !lIssMR .And. (M->E2_BASEISS == 0 .or. lCpoValor .or. (cField == "M->E2_BASEISS" .and. !IsInCallStack('PLSA470')))
		M->E2_BASEISS :=	If(nVlrMR > 0, nVlrMR, M->E2_VALOR)
	Endif

	If !lInsMR .And. (M->E2_BASEINS == 0 .or. lCpoValor)
		M->E2_BASEINS :=	If(nVlrMR > 0, nVlrMR, M->E2_VALOR)
	Endif

	nBaseIrrf   := M->E2_BASEIRF
	nBasePCC	:= M->E2_BASEPIS
	nBaseIns	:= M->E2_BASEINS
	nBaseIss    := M->E2_BASEISS

	If nBasePCC > 0
		M->E2_BASECOF := nBasePCC
		M->E2_BASECSL := nBasePCC
	Endif

	If !lPccMR .And. M->E2_BASEPIS > 0
		If nVlrMR > 0
			nBasePCC := IIF ((nVlrMR <= nVlMinImp), nVlrMR, M->E2_BASEPIS)
		Else
			nBasePCC := IIF ((M->E2_VALOR <= nVlMinImp), M->E2_VALOR, M->E2_BASEPIS)
		EndIf
	Endif

	If !lInsMR .And. M->E2_BASEINS > 0
		nBaseIns		:= M->E2_BASEINS
	Endif

	If !lIssMR .And. M->E2_BASEISS > 0
		nBaseIss		:= M->E2_BASEISS
	Endif
ElseIf lF050Auto// Busca base diferencia quando calculo for por ExecAuto, para manter integridade do valor(M->E2_VALOR)
	nX := Ascan(aAutoCab, {|e| AllTrim(e[1]) == "E2_VALOR"})
	If nX > 0
		M->E2_VALOR := aAutoCab[nX][2]
	Endif
	nX := Ascan(aAutoCab, {|e| AllTrim(e[1]) == "E2_BASEIRF"})
	If nX > 0
		nBaseIrrf := aAutoCab[nX][2]
	Else
	 	If lIrpfCAr .and. SED->ED_IRRFCAR=='S' .and. lBaseCar .and. SED->ED_BASEIRC > 0
			M->E2_BASEIRF :=	M->E2_VALOR * (SED->ED_BASEIRC/100)
		Elseif !lIRPFBaixa .and. lBaseDif .and. SED->ED_BASEIRF > 0
			M->E2_BASEIRF :=	M->E2_VALOR * (SED->ED_BASEIRF/100)
		Else
			M->E2_BASEIRF :=	M->E2_VALOR
		Endif
		nBaseIrrf := M->E2_BASEIRF
	Endif
	nX := Ascan(aAutoCab, {|e| AllTrim(e[1]) == "E2_BASEPIS"})
	If nX > 0
		nBasePCC := aAutoCab[nX][2]
		M->E2_BASEPIS := nBasePCC
	Else
		M->E2_BASEPIS :=	M->E2_VALOR
		nBasePCC := M->E2_VALOR
	Endif
	nX := Ascan(aAutoCab, {|e| AllTrim(e[1]) == "E2_BASECOF"})
	If nX > 0
		nBasePCC := aAutoCab[nX][2]
		M->E2_BASECOF := nBasePCC
	Else
		M->E2_BASECOF :=	M->E2_VALOR
		nBasePCC := M->E2_VALOR
	Endif
	nX := Ascan(aAutoCab, {|e| AllTrim(e[1]) == "E2_BASECSL"})
	If nX > 0
		nBasePCC := aAutoCab[nX][2]
		M->E2_BASECSL := nBasePCC
	Else
		M->E2_BASECSL :=	M->E2_VALOR
		nBasePCC := M->E2_VALOR
	Endif
	nX := Ascan(aAutoCab, {|e| AllTrim(e[1]) == "E2_BASEISS"})
	If nX > 0
		nBaseIss := aAutoCab[nX][2]
	Else
		M->E2_BASEISS :=	M->E2_VALOR
		nBaseIss := M->E2_VALOR
	Endif
	nX := Ascan(aAutoCab, {|e| AllTrim(e[1]) == "E2_BASEINS"})
	If nX > 0
		nBaseIns := aAutoCab[nX][2]
	Else
		M->E2_BASEINS :=	M->E2_VALOR
		nBaseIns := M->E2_VALOR
	Endif
Endif

//Verificar ou nao o limite de 5000 para Pis cofins Csll
// 1 = Verifica o valor minimo de retencao
// 2 = Nao verifica o valor minimo de retencao
If lCpoVlMin .and. M->E2_APLVLMN == "2"
	lAplVlMin := .F.
Endif

// Caso a funcao Fa050Nat2 tenha sido chamada a partir da alteracao dos campos de Irrf (.T.), Inss e Iss,
// Fazemos os recalculos dos impostos da lei 10925  sem e fazer a recarga dos valores destes campos.
If !lVlOnlyRet

	//³ Verifica se Natureza pede calculo do ISS (FORNECEDOR NŽO RECOLHE) ³
	//³ e se n†o ‚ titulo Provisorio ou Adiantamento ou Abatimento 		 ³
	If SA2->A2_RECISS == "S" .OR. ;
		m->e2_tipo $ MVABATIM+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA +"/"+"SES"+"/"+MV_CPNEG+"/"+"INA" .or. ;
		(m->e2_tipo $ MVPAGANT .and. GetMv("MV_IMPADT") != "S") .or. ;
		(!lCalcIssBx .and. m->e2_tipo $ MVPAGANT .and. SA2->A2_RECISS == "S")

		If !lIssMR
			If lRndVlIss
				m->e2_valor += Round(m->e2_iss + If(lBtrISS,m->e2_btriss,0),2)
			Else
				m->e2_valor += NoRound(m->e2_iss + If(lBtrISS,m->e2_btriss,0),2)
			Endif

			If m->e2_tipo == MVPAGANT .and.lPrImPA
				If SED->ED_CALCISS == "S" .and. SA2->A2_RECISS != "S" .AND. !lCalcIssBx
					nPercIss := GetMV("MV_ALIQISS")
					If lRndVlIss
						m->e2_PRISS := Round(((nBaseIss) * nPercIss / 100),2)
					Else
						m->e2_PRISS := NoRound(((nBaseIss) * nPercIss / 100),2)
					EndIf
				EndIf
			EndIf

			m->e2_iss := 0
			nOldISS	  := 0
			If lBtrISS	// Bitributacao
				aISSCPOM := ISSCPOM("T",SA2->(A2_COD+A2_LOJA),M->E2_CODSERV)
				If !Empty(aISSCPOM)
					If lRndVlIss
						m->e2_btriss := Round(((nBaseIss) * aISSCPOM[3] / 100),2)
					Else
						m->e2_btriss := NoRound(((nBaseIss) * aISSCPOM[3] / 100),2)
					EndIf
				Else
					If lBtrISS
						m->e2_btriss:= 0
						nOldBtrISS 	:= 0
					EndIf
				EndIf
			EndIf
		Endif
	Else
		If SED->ED_CALCISS == "S" .and. SA2->A2_RECISS != "S"
			If !lIssMR
				nPercIss := GetMV("MV_ALIQISS")

				// Obtem a aliquota de ISS da tabela FIM - Multiplos Vinculos de ISS
				If cPaisLoc == "BRA"
					If !Empty( M->E2_CODISS )
						DbSelectArea( "FIM" )
						FIM->( DbSetOrder( 1 ) )
						If FIM->( DbSeek( xFilial( "FIM" ) + M->E2_CODISS ) )
							nPercIss := FIM->FIM_ALQISS
						EndIf
					EndIf
				EndIf

				If lF050PISS
					nPercIss := ExecBlock("F050PISS",.F.,.F.)
				Endif

				If Alltrim(SE2->E2_ORIGEM) == "MATA100" // D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_COD+D1_ITEM
					nPercIss := Posicione("SD1", 1,;
					xFilial("SD1") + SE2->E2_NUM + SE2->E2_PREFIXO + SE2->E2_FORNECE + SE2->E2_LOJA , "D1_ALIQISS" )
				EndIf

				If SA2->A2_RECISS == "N"
					nBaseIss := Round(xMoeda(nBaseIss, M->E2_MOEDA, 1, M->E2_EMISSAO, MsDecimais(1)+1, M->E2_TXMOEDA), MsDecimais(1))

					If lRndVlIss
						m->e2_iss := Round(((nBaseIss) * nPercIss / 100),2)
					Else
						m->e2_iss := NoRound(((nBaseIss) * nPercIss / 100),2)
					EndIf
					If lBtrISS	// Bitributacao
						aISSCPOM := ISSCPOM("T",SA2->(A2_COD+A2_LOJA),M->E2_CODSERV)
						If !Empty(aISSCPOM)
							If lRndVlIss
								m->e2_btriss := Round(((nBaseIss) * aISSCPOM[3] / 100),2)
							Else
								m->e2_btriss := NoRound(((nBaseIss) * aISSCPOM[3] / 100),2)
							EndIf
						EndIf
					EndIf
				Else
					If lBtrISS	// Bitributacao
						aISSCPOM := ISSCPOM("T",SA2->(A2_COD+A2_LOJA),M->E2_CODSERV)
						If !Empty(aISSCPOM)
							If lRndVlIss
								m->e2_btriss := Round(((nBaseIss) * aISSCPOM[3] / 100),2)
							Else
								m->e2_btriss := NoRound(((nBaseIss) * aISSCPOM[3] / 100),2)
							EndIf
						EndIf
					EndIf
				EndIf

				If lPrImPA .and. !lCalcIssBx  .and. M->E2_TIPO $ MVPAGANT
					M->E2_PRISS := m->e2_iss
					m->e2_iss := 0
				nOldISS	 := 0
				If lBtrISS
					m->e2_btriss := 0
					nOldBtrISS 	 := 0
				EndIf
				Elseif lPrImPA .and. !lCalcIssBx
					m->e2_valor += M->E2_PRISS
					M->E2_PRISS := 0
				EndIf

				//-- Ajusta o ISS qdo a chamada for efetuada atraves do contrato de carreteiro.
				If Left(FunName(),7) == 'TMSA250' .Or. Left(FunName(),7) == 'TMSA251'
					If Type("cNumCTC") <> "U"
						TMA250ISS()
					EndIf
					//Verifica se a rota e municipal, se nao for nao gera titulo de ISS, zerando o campo
					If cTipUso == "1" .And. Type("cFilVge") <> "U" .And. Type("cNumVge") <> "U"
						DTQ->(DbSetOrder(2))
						If DTQ->(MsSeek(xFilial("DTQ")+cFilVge+cNumVge))
							DA8->(DbSetOrder(1))
							If DA8->(MsSeek(xFilial("DA8")+DTQ->DTQ_ROTA)) .And. cPaisLoc == "BRA"
								If DA8->DA8_ROTMUN == StrZero(2,Len(DA8->DA8_ROTMUN)) //Rota Municipal = Nao
									m->e2_iss := 0
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		Endif
	EndIf

	If !lIssMR .and. !lCalcIssBx

		If cPaisLoc == "BRA" .And. M->E2_FRETISS == "2" // Nao verificar minimo do ISS
			lVerMinIss := .F.
		Endif

		If lDedIss .And. lVerMinIss
			SomaTitISS("SE2",M->E2_FORNECE,M->E2_LOJA,M->E2_VENCREA,@nTotISS,@nVRetISS,@nTotBasISS,nBaseISS)
		EndIf

		If lVerMinIss .and.;
			((cForMinISS == "1" .And. Iif(lDedIss, M->E2_ISS + nTotIss, M->E2_ISS) <= SuperGetMv("MV_VRETISS",.F., 0)) .Or. ;
			(cForMinISS == "2" .And. nBaseIss <= GetNewPar("MV_VBASISS",0)))
			M->E2_VRETISS := M->E2_ISS
			M->E2_ISS := 0
		ELSEIF !EMPTY(nBaseISS) .and. !EMPTY(M->E2_ISS)
			M->E2_VRETISS := M->E2_ISS
		EndIf
	Endif

	If !lInsMR

		If lBtrISS .and. lVerMinIss .and. !Empty(aISSCPOM) .and. Upper(AllTrim(aISSCPOM[2])) == Upper(AllTrim(SM0->M0_CIDENT))
			nTotISS  := 0
			nVRetISS := 0
			SomaTitISS("SE2",M->E2_FORNECE,M->E2_LOJA,M->E2_VENCREA,@nTotISS,@nVRetISS,@nTotBasISS,nBaseISS,,lBtrISS)
			If M->E2_BTRISS+nTotIss <= aISSCPOM[4]
				M->E2_VRETBIS := M->E2_BTRISS
				M->E2_BTRISS := 0
			EndIf
		EndIf

		// Verifica se Natureza pede calculo do INSS (RECOLHE INSS P/ FORNEC) e se n†o ‚ titulo Provisorio ou Adiantamento ou Abatimento
		If m->e2_tipo $ MVPAGANT+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVTAXA+"/"+MV_CPNEG+"/"+MVABATIM+"/"+"SES"+"/"+"INA" .or. ;
			(m->e2_tipo $ MVPAGANT .and. GetMv("MV_IMPADT") == "S")
			If SED->ED_DEDINSS $ "1 " .And. (M->E2_INSS == 0 .OR. M->E2_INSS == (M->E2_BASEINS * SED->ED_PERCINS) )
				m->e2_valor += NoRound(m->e2_inss,2)
			Endif
			m->e2_inss  := 0
			nOldInss    := 0
			m->e2_valor += Iif(lRndSest,Round(m->e2_sest,2),NoRound(m->e2_sest,2))
			m->e2_sest  := 0
			nOldSEST    := 0
			If m->e2_tipo == MVPAGANT .And. !lInsPub
				If SED->ED_CALCINS == "S" .and. SA2->A2_RECINSS == "S"
					nIrfInss := 0

					If !Empty(SED->ED_BASEINS)
						nBaseIns := NoRound((M->E2_VALOR * (SED->ED_BASEINS/100)),2)
						M->E2_BASEINS:= nBaseIns
					ElseIf nBaseIns == 0
						nBaseIns := M->E2_VALOR
					EndIf

					If !lInssBx .And.lPrImPA
						If SA2->A2_TIPO == "F" //Para pessoa fisica verifico o limite de deducao no mes
							nValInss := FCalcInsPF(nBaseIns, @nCalcInss,@nINSSTot)
						Else
							nValInss := FCalcInsPJ(nBaseIns, @nCalcInss,@nINSSTot)
						Endif
					Else
						nValInss	:=	FCaInssBxCP(nBaseIns,lIRPFBaixa,lCalcIssBx,lPCCBaixa)
					Endif
					If cPaisLoc == "BRA" .and. SED->ED_RINSSPA == "1" .And. !lInssBx .And. lPrImPa//retem o valor no INSS em titulo tipo INA
						M->E2_INSS		:= Max(nINSSTot,nValInss)
						M->E2_PRINSS	:= 0
						M->E2_VRETINS := nCalcInss
						//-- Valor do titulo nao pode ser menor que o valor do INSS
						If M->E2_VALOR < M->E2_INSS
							M->E2_INSS  := M->E2_VALOR - 0.01
						EndIf
						IF lF050INBR //³ Ponto de entrada para calculo de INSS com base reduzida ³
							M->E2_INSS := ExecBlock("F050INBR",.f.,.f.,M->E2_VALOR)
							nVCalINS := M->E2_INSS
							nBCalINS := nBaseIns
						Endif
					Else
						If m->e2_tipo == MVPAGANT .and. lPrImPA
							M->E2_PRINSS := Max(nINSSTot,nValInss)
						EndIf
					EndIf

					If lInssBx //Inss Baixa
						nParciais	:= M->E2_VALOR - M->E2_SALDO
						M->E2_INSS		:=	nValInss
						M->E2_PRINSS	:= 0

						If ((nValInss > 0 .And. !lAcmPJ) .Or. (lAcmPJ)) .And. SA2->A2_TIPO == "J"
							M->E2_BASEINS:= nBaseIns
							If nParciais > 0 .And. M->E2_VRETINS > 0
								M->E2_VRETINS := M->E2_VRETINS + nVretInss
							Else
								M->E2_VRETINS	:= nVretInss
							Endif
							If M->E2_INSS > 0 .And. lAcmPJ .And. M->E2_INSS < nValInss
								M->E2_INSS	:=	nValInss
							Endif
						ElseIf SA2->A2_TIPO == "F"
							M->E2_BASEINS:= nBaseIns

							If nLimInss > 0 //Caso empresa publica que utiliza os parâmetros de controle de valores do INSS retido zerados.
								lOk	:=	nParciais > 0 .And. M->E2_VRETINS > 0 .And. M->E2_VRETINS < nLimInss
							Else
								lOk	:=	nParciais > 0 .And. M->E2_VRETINS > 0
							Endif

							If lOk
								M->E2_VRETINS := M->E2_VRETINS + nVretInss
							Else
								M->E2_VRETINS:= nVretInss
							Endif
							If nValInss == nLimInss .And. M->E2_INSS > nLimInss
								M->E2_INSS	:=	nValInss
							Endif
						Endif

						If nValInss == 0 .And. lInssBx .And. ((SA2->A2_TIPO == "J" .And. lAcmPJ) .Or. (SA2->A2_TIPO == "F"))
							M->E2_PRETINS	:= "1"
						Endif

						If nValInss > 0 .And. lInssBx .And. SA2->A2_TIPO == "F"
							M->E2_PRETINS	:= " "
						Endif
					Endif
					nInss	:= nValInss
					nVCalINS := nValInss
					nBCalINS := nBaseIns
				EndIf
			EndIf
		Else
			If SED->ED_CALCINS == "S" .and. SA2->A2_RECINSS == "S"
				nIrfInss := 0
				If !Empty(SED->ED_BASEINS)
					nBaseIns := NoRound((M->E2_VALOR * (SED->ED_BASEINS/100)),2)
					E2_BASEINS:= nBaseIns
				ElseIf nBaseIns == 0
					nBaseIns := M->E2_VALOR
				EndIf
				nBaseIns := xMoeda(nBaseIns,M->E2_MOEDA,1,M->E2_EMISSAO,3,M->E2_TXMOEDA)
				If SA2->A2_TIPO == "F" //Para pessoa fisica verifico o limite de deducao no mes
					nValInss := FCalcInsPF(nBaseIns, @nCalcInss,@nINSSTot)
				Else
					nValInss := FCalcInsPJ(nBaseIns, @nCalcInss,@nINSSTot)
				Endif

				M->E2_INSS := Max(nINSSTot,nValInss)
				M->E2_VRETINS := nCalcInss

				//-- Valor do titulo nao pode ser menor que o valor do INSS
				If M->E2_VALOR < M->E2_INSS
					M->E2_INSS  := M->E2_VALOR - 0.01
				EndIf
				nVCalINS := M->E2_INSS
				nBCalINS := nBaseIns
				//³ Ponto de entrada para calculo de INSS com base reduzida      ³
				IF lF050INBR
					M->E2_INSS := ExecBlock("F050INBR",.f.,.f.,M->E2_VALOR)
					nVCalINS := M->E2_INSS
					nBCalINS := nBaseIns
				Endif
			Endif
		Endif

		If Left(FunName(),7) <> 'TMSA250' .And. !lInssBx
			// Tratamento de Dispensa de Ret. de Inss. caso nao seja Pessoa Fisica
			If ( M->E2_INSS < GetMv("MV_VLRETIN") ) .And. SA2->A2_TIPO <> "F" .AND. (IIF(lFinVldIns, Execblock("FinVldIns",.F.,.F., {} ), .T. ))
				M->E2_INSS:= 0
				nOldInss  := 0
			EndIf
		EndIf
		If M->E2_INSS == 0 .And. lInssBx .And. ((SA2->A2_TIPO == "J" .And. lAcmPJ) .Or. (SA2->A2_TIPO == "F"))
			M->E2_PRETINS	:= "1"
		Endif
		If M->E2_INSS > 0 .And. lInssBx .And. SA2->A2_TIPO == "F"
			M->E2_PRETINS	:= " "
		Endif
		//SEST
		If SED->ED_CALCSES == 'S' .And. SA2->A2_RECSEST == "1"
			If !Empty(SED->ED_BASESES)
				nValSEST := Iif(lRndSest,Round((m->e2_valor * (SED->ED_BASESES/100)),2),NoRound((m->e2_valor * (SED->ED_BASESES/100)),2))
			Else
				nValSEST := M->E2_VALOR
			EndIf
			m->e2_sest := Iif(lRndSest,Round((nValSEST * (SED->ED_PERCSES/100)),2),NoRound((nValSEST * (SED->ED_PERCSES/100)),2))
			nValSEST := m->e2_sest
		Endif
	Endif

	//CIDE
	If lCIDE .And. !lCidMR
		If SED->ED_CALCCID == 'S' .And. SA2->A2_RECCIDE == "1"
			If !Empty(SED->ED_BASECID)
				nValCIDE := Round((m->e2_valor * (SED->ED_BASECID/100)),2)
			Else
				nValCIDE := M->E2_VALOR
			EndIf

			nValCIDE := xMoeda(nValCIDE, M->E2_MOEDA, 1, M->E2_EMISSAO, 3, M->E2_TXMOEDA)
			m->e2_cide := Round((nValCIDE * (SED->ED_PERCCID/100)),2)
			nValCIDE := m->e2_cide
		Endif
	EndIf

	If !lIrfMR
		//³ Verifica se Natureza pede calculo do IRRF e se n†o ‚ ³
		//³ titulo Provisorio ou Adiantamento ou Abatimento      ³
		If SED->ED_CALCIRF == "N" .or. m->e2_tipo $ MVABATIM+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA +"/"+"SES"+"/"+MV_CPNEG+"/"+"INA" .or. ;
			(m->e2_tipo $ MVPAGANT .and. GetMv("MV_IMPADT") != "S")
			m->e2_valor += NoRound(m->e2_irrf,2)
			m->e2_irrf	:= 0
			nOldIrr		:= 0
		Else
			//³Caso o titulo de carreteiro seja incluido pelo modulo Financeiro e no cadastro de fornecedor esteja   ³
			//³configurado para executar calculo de IRRF na baixa do titulo, o mesmo sera executado no fonte FINA241 ³
			If SED->ED_IRRFCAR == "S" .And. IIf(nModulo != 43,!lIRPFBaixa,.T.)
				//Verifico a combinacao de filiais (SM0) e lojas de fornecedores a serem considerados
				//na montagem da base do IRRF
				If cAglImPJ != "1"
					aRet := FLOJASIRRF("2")
					aFilial := aClone(aRet[1])
					aCliFor := aClone(aRet[2])
					cArqTMP := aRet[3]
				Endif
				//³ Verifica se Pessoa Fisica ou Juridica, para fins de calculo do irrf                                    	 ³
				If lF050ATP
					lAplicaTP := ExecBlock("F050ATP",.F.,.F.)
				Endif
				//-- Se o parametro MV_TPTCTC nao estiver preenchido
				If Empty(cTipCTC)
					cTipCTC := Padr( "C" + cFilAnt, Len( SE2->E2_TIPO ) ) // Tipo Contrato de Carreteiro
				EndIf
				If (SA2->A2_TIPO == "F" .OR. (SA2->A2_TIPO == "J" .AND. lIRProg == "1")) .AND. !lEmprInd .AND. lAplicaTP

					//--Regra para calculo do imposto de renda - Pessoa Fisica:

					//--Devem ser somados -TODOS- os titulos que com data de vencimento
					//--no mes corrente.
					//--Apos isto, deve-se aplicar a reducao de base de calculo do IR (Se houver) e
					//--deduzir o valor acumulado de INSS retido.
					//--Em seguida, verificar em qual faixa da tabela progressiva do IRRF se enquadra o
					//--valor obtido.
					//--Aplicar a aliquota do imposto, deduzir o valor referente a faixa
					//--da tabela progressiva e abater os impostos retidos (IRRF) anteriores.

					//--Exemplo:

					//--Tabela Progressiva do IRRF (Exemplo):
					//--  Ate(R$)   Aliq.    Val. Deduzir
					//-- 1.434,59	  0,0	         0,00
					//-- 2.150,00	  7,5	       107,59
					//-- 2.866,70	 15,0	       268,84
					//-- 3.582,00	 22,5	       483,84
					//-- 9.999,99	 27,5	       662,94

					//-- Titulo c/       Valor          Base     Valor
					//-- Vencto. em:     Titulo      Calculo      IRRF
					//--    01/08/09   1.000,00     1.000,00      0,00 (Alcancou a 1.a Faixa)
					//--    15/08/09   2.000,00     3.000,00    191,16 (Alcancou a 4.a Faixa) Formula: ((3000 * 22.5)/100)-483.84)
					//--    31/08/09   2.000,00     5.000,00    520,90 (Alcancou a 5.a Faixa) Formula: ((5000 * 27,5)/100)-(662,94+191,16)
					//--    31/08/09   1.000,00     6.000,00    275,00 (Alcancou a 5.a Faixa) Formula: ((6000 * 27,5)/100)-(662,94+191,16+520,90)

					//-- Se houver reducao de base de calculo (40% de reducao):
					//-- Titulo c/       Valor         Valor        Base     Valor
					//-- Vencto. em:     Titulo    Acumulado     Calculo      IRRF
					//--    01/08/09   1.000,00     1.000,00      400,00       0,00 (Alcancou a 1.a Faixa)
					//--    15/08/09   2.000,00     3.000,00    1.600,00      12,41 (Alcancou a 2.a Faixa) Formula: ((1600 * 7,5)/100)-107,59)
					//--    31/08/09   2.000,00     5.000,00    2.000,00      30,00 (Alcancou a 2.a Faixa) Formula: ((2000 * 7,5)/100)-(107,59+12,41)
					//--    31/08/09   1.000,00     6.000,00    2.400,00      48,75 (Alcancou a 3.a Faixa) Fomrula: ((2400 * 15)/100)-(268,84+12,41+30)

					//--Obtem os titulos com vencimento no periodo:
					cAliasQry := GetNextAlias()
					cQuery := "SELECT SE2.E2_FILIAL, SE2.E2_PREFIXO, SE2.E2_NUM, SE2.E2_PARCELA, "
					cQuery += "       SE2.E2_TIPO, SE2.E2_FORNECE, SE2.E2_LOJA, SE2.E2_IRRF, "
					cQuery += "       SE2.E2_INSS, SE2.E2_VENCREA, SE2.E2_VALOR, SE2.E2_BAIXA, "
					cQuery += "       SE2.E2_FATURA, SE2.E2_SEST, SE2.E2_BASEIRF, SE2.E2_ORIGEM, SE2.E2_NATUREZ,SE2.E2_ISS "

					IF lVRetIrf
						cQuery += "  ,SE2.E2_VRETIRF "
					Endif

					If lBtrISS
						cQuery += " ,SE2.E2_BTRISS "
					EndIf

					cQuery += "FROM " + RetSQLTab('SE2')

					cQuery += "JOIN " + RetSQLTab('SED')
					cQuery += "  ON  SED.ED_FILIAL  = '" + xFilial('SED') + "' AND "
					cQuery += "      SED.ED_CODIGO  = SE2.E2_NATUREZ AND "
					cQuery += "      SED.ED_CALCIRF = 'S' AND "
					If !lFina050
				   		cQuery += "      SED.ED_IRRFCAR = 'S' AND "
				 	Endif
					cQuery += "      SED.D_E_L_E_T_ = ' ' "

					cQuery += " WHERE "

					If lVretIrf
						//Se verifica base apenas na filial corrente e fornecedor corrente
						If cAglImPJ == "1" .Or. Empty( cFilFwSE2 )
							cQuery += "SE2.E2_FILIAL = '"+ xFilial("SE2") + "' AND "

							If cAglImPJ == "1" 				//Verificar apenas fornecedor corrente
								cQuery += "SE2.E2_FORNECE = '"+ SA2->A2_COD +"' AND "
								cQuery += "SE2.E2_LOJA = '"+ SA2->A2_LOJA +"' AND "
							Else									//Verificar determinados fornecedores (raiz do CNPJ)
								If "MSSQL" $ cDbMs
									cQuery += " (E2_FORNECE+E2_LOJA IN (SELECT CODIGO+LOJA FROM " + cArqTMP + ")) AND "
								Else
									cQuery += " (E2_FORNECE||E2_LOJA IN (SELECT CODIGO||LOJA FROM " + cArqTMP + ")) AND "
								Endif
							Endif

						ElseIf Len(aFilial) > 0  //Mais de uma filial SM0

							If Empty( cFilFwSA2 )  //Se cadastro de Clientes compartilhado
								cQuery += "SE2.E2_FILIAL IN ( "
								For nLoop := 1 to Len(aFilial)
									cQuery += "'"  + aFilial[nLoop] + "',"
								Next
								//Retiro a ultima virgula
								cQuery := Left( cQuery, Len( cQuery ) - 1 )
								cQuery += ") AND "

								//Verificar determinados fornecedores (raiz do CNPJ)
								If "MSSQL" $ cDbMs
									cQuery += " (E2_FORNECE+E2_LOJA IN (SELECT CODIGO+LOJA FROM "+cArqTMP+")) AND "
								Else
									cQuery += " (E2_FORNECE||E2_LOJA IN (SELECT CODIGO||LOJA FROM "+cArqTMP+")) AND "
								Endif
							Else							//Se cadastro de Clientes EXCLUSIVO
								If "MSSQL" $ cDbMs
									cQuery += " (E2_FILIAL+E2_FORNECE+E2_LOJA IN (SELECT FILIALX+CODIGO+LOJA FROM "+cArqTMP+")) AND "
								Else
									cQuery += " (E2_FILIAL||E2_FORNECE||E2_LOJA IN (SELECT FILIALX||CODIGO||LOJA FROM "+cArqTMP+")) AND "
								Endif
							Endif
						Endif
					Else
						cQuery += "SE2.E2_FILIAL = '"+ xFilial("SE2") + "' AND "
						cQuery += "SE2.E2_FORNECE= '"+ SA2->A2_COD +"' AND "
						cQuery += "SE2.E2_LOJA =   '"+ SA2->A2_LOJA +"' AND "
					Endif

					// Para Pessoa fisica totaliza os titulos emitidos no mes
					If cVenctoPF == "2"
						cQuery += "      SE2.E2_VENCREA  BETWEEN '" + Dtos(FirstDay(M->E2_VENCREA)) + "' AND '" + Dtos(LastDay(M->E2_VENCREA))+ "' AND "
					ElseIf cVenctoPF == "1"
						cQuery += "      SE2.E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(M->E2_EMISSAO)) + "' AND '" + Dtos(LastDay(M->E2_EMISSAO))+ "' AND "
					ElseIf cVenctoPF == "3"
						cQuery += "      SE2.E2_EMIS1  BETWEEN '" + Dtos(FirstDay(dDataBase)) + "' AND '" + Dtos(LastDay(dDataBase))+ "' AND "
					Endif
					cQuery += " 	SE2.E2_TIPO NOT IN " + FormatIn(MV_CPNEG +"|"+ MVPAGANT +"|"+ MVISS +"|"+ MVTAXA +"|"+ MVTXA +"|"+ MVINSS +"|"+ 'SES' +"|"+ 'CID' + "|"+ 'INA', "|") + " AND "
					cQuery += "     SE2.E2_FATURA NOT IN('NOTFAT') AND "
					cQuery += "     SE2.D_E_L_E_T_ = ' ' "

			  		cQuery := ChangeQuery(cQuery)

					//--Processa a query e adequa os campos
			  		DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)
					TcSetField(cAliasQry,"E2_IRRF","N",TamSX3("E2_IRRF")[1],TamSX3("E2_IRRF")[2])
					TcSetField(cAliasQry,"E2_INSS","N",TamSX3("E2_INSS")[1],TamSX3("E2_INSS")[2])
					TcSetField(cAliasQry,"E2_VALOR","N",TamSX3("E2_VALOR")[1],TamSX3("E2_VALOR")[2])
					TcSetField(cAliasQry,"E2_VENCREA","D",TamSX3("E2_VENCREA")[1],TamSX3("E2_VENCREA")[2])

					//--Confronta os titulos obtidos com os contratos:
					If !(cAliasQry)->( Eof() )
						While !(cAliasQry)->( Eof() )
							If !lAltera .or. (lAltera .and. SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA)<>(cAliasQry)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA))
								If (cAliasQry)->E2_TIPO == cTipCTC
									//--Titulo vinculado ao contrato. Obtem
									//--o valor para base de calculo no DTY
									DTY->(DbSetOrder(1) )
									If DTY->( DbSeek( xFilial('DTY') + (cAliasQry)->E2_NUM ) )
										lValFre   := .F. 			//supor que nValFrete nao sera encontrado dentro do while.
										While !DTY->( Eof() ) .And. DTY->(DTY_FILIAL + DTY_NUMCTC) == xFilial('DTY') + (cAliasQry)->E2_NUM
											If DTY->(DTY_CODFOR+DTY_LOJFOR) == (cAliasQry)->(E2_FORNECE+E2_LOJA)
												//--Ponto de Entrada para desprezar contratos
												//--a serem acumulados para base de calculo do IRRF
												If lF050FCTC
								   					lOk := ExecBlock('F050FCTC',.F.,.F.,{DTY->DTY_FILORI,DTY->DTY_VIAGEM})
													If ValType(lOk) <> "L"
														lOk := .T.
													EndIf

													//--Desconsidera o Contrato
													If !lOk
														DTY->(dbSkip())
								   						Loop
													EndIf
												EndIf
												nValFrete += DTY->DTY_VALFRE
												lValFre   := .T.			// nValFrete encontrado dentro do While
											EndIf
											DTY->( DbSkip() )
										EndDo
										//-- Se nValFrete nao encontrado, recompor o valor de nValFrete para que nao fique em branco...
										//-- ja que nINSSRet sera somado independentemente disso, podendo causar nValFrete negativo
										If !lValFre
											nValFrete += (cAliasQry)->E2_VALOR + (cAliasQry)->E2_IRRF + (cAliasQry)->E2_INSS +;
												(cAliasQry)->E2_ISS + If(lBtrISS,(cAliasQry)->E2_BTRISS,0) + (cAliasQry)->E2_SEST //Recompoe o valor
										Endif
									Else
										//--Caso nao seja encontrato o contrato, significa que o titulo
										//--foi incluido manualmente ou nao esta amarrado a um contrato:
										nValFrete += (cAliasQry)->E2_VALOR + (cAliasQry)->E2_IRRF + (cAliasQry)->E2_INSS +;
											(cAliasQry)->E2_ISS + If(lBtrISS,(cAliasQry)->E2_BTRISS,0) + (cAliasQry)->E2_SEST //Recompoe o valor
						   			EndIf
								Else
									//--Titulo gerado a partir de outra origem, exemplo:
									//--Pedagio, Adiantamentos, inclusao manual, etc...
									If lFina050 .AND. "FINA" $ (cAliasQry)->E2_ORIGEM
								  	 	nValFrete += (cAliasQry)->E2_BASEIRF
								   	Else
										nValFrete += (cAliasQry)->E2_VALOR + (cAliasQry)->E2_IRRF + (cAliasQry)->E2_INSS +;
									   		(cAliasQry)->E2_ISS + If(lBtrISS,(cAliasQry)->E2_BTRISS,0) + (cAliasQry)->E2_SEST //Recompoe o valor
								    Endif
					   			EndIf
							Else
								//--Titulo gerado a partir de outra origem, exemplo:
								//--Pedagio, Adiantamentos, inclusao manual, etc...
								If lFina050 .AND.  "FINA" $ (cAliasQry)->E2_ORIGEM
							  	 	nValFrete += (cAliasQry)->E2_BASEIRF
							   	Else
									nValFrete += (cAliasQry)->E2_VALOR + (cAliasQry)->E2_IRRF + (cAliasQry)->E2_INSS +;
										(cAliasQry)->E2_ISS + If(lBtrISS,(cAliasQry)->E2_BTRISS,0) + (cAliasQry)->E2_SEST //Recompoe o valor
	                            Endif
							EndIf

							If(cAliasQry)->E2_PREFIXO		!= M->E2_PREFIXO .OR.; //Valida se esta alterando contas a pagar																																																										//JFSB
							  (cAliasQry)->E2_NUM 			!= M->E2_NUM .OR.;
							  (cAliasQry)->E2_TIPO			!= M->E2_TIPO
								nValIRRF  += (cAliasQry)->E2_IRRF
							EndIf

							If lFina050
								aAreaSED := SED->(GetArea())
								dbSelectArea("SED")
								dbSeek(XFILIAL("SED")+(cAliasQry)->E2_NATUREZ)

								 If !lDedIns .and. SED-> ED_IRRFCAR== "S"
				    				nINSSRet+= (cAliasQry)->E2_INSS
					   			 Elseif lDedIns
					  				nINSSRet += (cAliasQry)->E2_INSS
					   			 Endif
					   			 RestArea(aAreaSED)
							Else
								nINSSRet  += (cAliasQry)->E2_INSS
							Endif
							(cAliasQry)->( DbSkip() )
						EndDo
					EndIf
					(cAliasQry)->(DbCloseArea())

					//Fecha arquivo temporario
					If cAglImPJ != "1" .and. lDelTrbIR
						If InTransact()
							StartJob( "DELTRBIR" , GetEnvServer() , .T. , SM0->M0_CODIGO, IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL ),.T.,ThreadID(),cArqTmp)
						Else
							DELTRBIR(SM0->M0_CODIGO, IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL ),.F.,0,cArqTmp)
						Endif
					Endif

					dbSelectArea("SE2")

					//--Agrega o valor do titulo que
					//--esta sendo gerado no momento:
					If lFina050 .and. lBaseImp .and. lBaseCar .and. SED->ED_BASEIRC > 0
						nValFrete += ((M->E2_VALOR * SED->ED_BASEIRC) / 100)
					ElseIf !lValfre
				   		nValFrete  += M->E2_VALOR
	                Endif
					//³ Aplica a reducao de base de calculo (Se houver)      ³
					If lBaseCar .and. SED->ED_BASEIRC > 0 .and. !lFina050
						nValFrete := ((nValFrete * SED->ED_BASEIRC) / 100)
					EndIf

					//³ Deduz o INSS do IRRF (Carreteiro)                    ³

					//--Verifica se o valor do INSS ultrapassou o valor limite.
					nINSSRet += M->E2_INSS
					If nLimInss > 0 .And. nINSSRet > nLimInss
						nINSSRet := nLimInss
					EndIf
					
					If lDedIns
						nValFrete := nValFrete - nINSSRet
					EndIf

					//³ Deduz os Dependentes                                 ³
					nValDep := nBaseDep * SA2->A2_NUMDEP
					nValFrete -= nValDep

					If !lAltVcto .AND. !(ALLTRIM(M->E2_ORIGEM) == "FINA290" .AND. (Alltrim(M->E2_FATURA) == "NOTFAT"))
						M->E2_IRRF := NoRound(FA050TabIR(nValFrete) - nValIRRF,2)
					EndIf

					IF lF050CIRF
						M->E2_IRRF := ExecBlock("F050CIRF",.f.,.f.,nBaseIrrf)
					Endif

				Else
					If !GetNewPar("MV_RNDIRF",.F.)
						m->e2_irrf := NoRound(((m->e2_valor*Iif(AllTrim(Str(m->e2_moeda,2))$"01",1,RecMoeda(m->e2_emissao,m->e2_moeda))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100)-nValIRRF,2)
					Else
						m->e2_irrf := Round(((m->e2_valor*Iif(AllTrim(Str(m->e2_moeda,2))$"01",1,RecMoeda(m->e2_emissao,m->e2_moeda))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100)-nValIRRF,2)
					Endif
				EndIf

				//-- Valor do titulo nao pode ser menor que o valor do IRRF
				If m->e2_valor < m->e2_irrf
					m->e2_irrf  := m->e2_valor - 0.01
				EndIf

				// Verifica se o fornecedor trata o valor minimo de retencao.
				If lAplMinIR .And. (M->E2_IRRF <= GetMv("MV_VLRETIR"))// Se Vlr. for Baixo nao considera
					M->E2_IRRF := 0
				EndIf
			Else
				//Base reduzida de impostos
				//Caso nao existra tratamento, a base sera o valor
				If !lBaseImp
					nBaseIrrf := m->e2_valor
				Endif

				nCalcIr	:=	0

				//Se controla base reduzida de IRRF
				//Se % base maior que 0
				//Se Fornecedor for pessoa fisica
				If lIRPFBaixa

					m->e2_irrf := 0

					//Verificar Base de IRPF
					If lBaseIRPF
						M->E2_BASEIRF := Round(NoRound( xMoeda(nBaseIrrf,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1, M->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
						If lBaseDif .and. SED->ED_BASEIRF > 0
							M->E2_BASEIRF := M->E2_BASEIRF * (SED->ED_BASEIRF/100)
						Endif
					ElseIf lCpBaseIR .and. M->E2_BASEIRF > 0 .and. SA2->A2_TIPO == "F"
						M->E2_BASEIRF := 0
					Endif
				Endif
				//³ Verifica se Pessoa Fisica ou Juridica, para fins de  ³
				//³ calculo do irrf                                    	³
				If lF050ATP
					lAplicaTP := ExecBlock("F050ATP",.F.,.F.)
				Endif
				IF (SA2->A2_TIPO == "F" .OR. (SA2->A2_TIPO == "J" .AND. lIRProg == "1")) .AND. lAplicaTP .AND. !Empty(SA2->A2_CALCIRF)
					If lIRPFBaixa
						If M->E2_TIPO $ MVPAGANT
							//³Busca base de cálculo para o  IRPF caso não tenha sido calculada
							aCalcIRPF := F241BsIRPF(,"SE2",M->E2_VALOR,,M->E2_FORNECE,M->E2_LOJA)

							//³Calcula IRPF e deduz os valores retidos anteriormente³
							If lPrImPA .and. M->E2_TIPO $ MVPAGANT
								aCalcIRPF[1]-= IIF(lDedIns .And. SA2->A2_TIPO != "J", nValInss , 0 )
							EndIf

							M->E2_IRRF := Fa050TabIR(aCalcIRPF[1]) - aCalcIRPF[2]
							M->E2_IRRF := IIF(M->E2_IRRF <= GetMv("MV_VLRETIR",,0),0,M->E2_IRRF)

							If M->E2_TIPO $ MVPAGANT .And. lVretIrf
								M->E2_VRETIRF := M->E2_IRRF
								nVCalIRF := M->E2_IRRF
								nBCalIRF := aCalcIRPF[1]
							EndIf
						EndIf
					Else
						If !lAltVcto .AND. !(ALLTRIM(M->E2_ORIGEM) $ "FINA290#FINA290M"  .AND. (Alltrim(M->E2_FATURA) == "NOTFAT"))
							nCalcIr := FCalcIr(nBaseIrrf,"F",.T.)
							If (nCalcIr == 0 .or. (nCalcIr > 0 .and. Recmoeda(M->E2_EMISSAO,M->E2_MOEDA)>0) ).And. M->E2_IRRF >0 .And. !(m->e2_tipo $ MVPAGANT) .And. M->E2_MOEDA > 1 .And. !lIRPFBaixa  .And. M->E2_TXMOEDA ==0 .And. cField <> "M->E2_TXMOEDA"
								M->E2_VALOR	:=	M->E2_VALOR + M->E2_IRRF
							Endif

							If nCalcIr > 0 .And. (M->E2_IRRF == 0 .or. (M->E2_IRRF > 0 .and. lCpoValor) ).And. !(m->e2_tipo $ MVPAGANT) .And. M->E2_MOEDA > 1 .And. !lIRPFBaixa
								M->E2_VALOR	:=	M->E2_VALOR - (nCalcIr/M->E2_TXMOEDA)
								lJaDescIr := .T.
							Endif
							If M->E2_MOEDA == 1 .And. cField == "M->E2_MOEDA" .And. M->E2_IRRF > 0 .And. nCalcIr > 0 .And. !(m->e2_tipo $ MVPAGANT) .And. !lIRPFBaixa
								M->E2_VALOR += nCalcIr
								M->E2_TXMOEDA := 0
							EndIf
							nValIrOld := M->E2_IRRF
							lSumIR := M->E2_IRRF == nCalcIr
							M->E2_IRRF := nCalcIr
						EndIf
					EndIf
				ElseIf !lSimples
					If lIRPFBaixa
						aAreaSA2 := SA2->(GetArea())

						nBasM2Irf := If(M->E2_TIPO $ MVPAGANT .And. lVretIrf, M->E2_VALOR, nBaseIrrf)

						If !lAltera .And. M->E2_MOEDA > 1
							nBasM2Irf := xMoeda(nBaseIrrf, M->E2_MOEDA, 1, M->E2_EMISSAO, MsDecimais(1)+1, M->E2_TXMOEDA)
							M->E2_BASEIRF := nBasM2Irf
						EndIf

						If M->E2_TIPO $ MVPAGANT .And. lVretIrf
							M->E2_IRRF := FCalcIRBx(nBasM2Irf, SA2->A2_TIPO)
							M->E2_VRETIRF := M->E2_IRRF
						Else
							M->E2_BASEIRF := nBasM2Irf
							M->E2_IRRF := FClcIRPJ(nBasM2Irf,.T.,.T.)
						EndIf

						RestArea(aAreaSA2)
					ElseIf !(ALLTRIM(M->E2_ORIGEM) == "FINA290" .AND. (Alltrim(M->E2_FATURA) == "NOTFAT")) .and. SA2->A2_CALCIRF <> " "

						nCalcIr	:=	FCalcIr(nBaseIrrf,"J",.T.)

						If nCalcIr > 0 .And. (M->E2_IRRF == 0 .or. (M->E2_IRRF > 0 .and.  (!lAltTxMoeda .And. lCpoValor ))) .And. !(m->e2_tipo $ MVPAGANT) .And. M->E2_MOEDA > 1 .And. !lIRPFBaixa .And. M->E2_TXMOEDA > 1
							M->E2_VALOR	:=	M->E2_VALOR - (xMoeda(nCalcIr,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA) )
							lJaDescIr := .T.
						Endif

						lSumIR := M->E2_IRRF == nCalcIr
						If nCalcIr == 0 
							nIrrfAnt := M->E2_IRRF
						EndIf
						M->E2_IRRF := nCalcIr
					EndIf

				EndIf

				IF lF050CIRF
					M->E2_IRRF := ExecBlock("F050CIRF",.f.,.f.,nBaseIrrf)
				Endif

				//³ Verifica se Pessoa Fisica ou Juridica, para fins de  ³
				//³ calculo do irrf, considerando o calculo do CIDE.     ³
				IF lCIDE
					IF (SA2->A2_TIPO == "F" .OR. SA2->A2_TIPO == "J") .AND. SED->ED_CALCCID == "S" .AND. SA2->A2_RECCIDE == "1"
						m->e2_irrf := Round(((m->e2_valor * Iif(AllTrim(Str(m->e2_moeda,2)) $ "01", 1, If(M->E2_MOEDA > 1 .And. M->E2_TXMOEDA > 0, M->E2_TXMOEDA,;
									RecMoeda(m->e2_emissao,m->e2_moeda)))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100)-nValIRRF,2)
					Endif
				EndIf
			EndIf
		EndIf
	EndIf
Endif

If FWisincallstack("FA050ISS") .and. lVlOnlyRet
	lVlOnlyRet := .F.
Endif

//Nao calculo impostos para alguns tipos de titulos
If m->e2_tipo $ MVABATIM+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA +"/"+"SES"+"/"+MV_CPNEG+"/"+"INA" .or. ;
(AllTrim(M->E2_ORIGEM) $ "FINA290#FINA290M"  .AND. (Alltrim(M->E2_FATURA) == "NOTFAT"))

	m->e2_pis := 0
	m->e2_cofins := 0
	m->e2_csll := 0
	nOldPis	 := 0
	nOldCofins	 := 0
	nOldCsll	  := 0
ElseIf cPaisLoc == "BRA"
	//Caso não tenha o tratamento de base diferenciada para os impostos,
	//Verifica a utilizacao da base de impostos (imformada) ou o valor do titulo.
	If !lBaseImp .AND. M->E2_TIPO $ MVPAGANT
		If !lPccMR
			If !Empty(M->E2_BASEPIS)
				nBasePCC := M->E2_BASEPIS
			Else
				nBasePCC := If(nVlrMR > 0, nVlrMR, M->E2_VALOR)
			Endif
	 	EndIf
	 Else
		// Caso a funcao Fa050Nat2 tenha sido chamada a partir da alteracao dos campos de Irrf (.T.), Inss e Iss,
		// Fazemos os recalculos dos impostos da lei 10925  sem e fazer a recarga dos valores destes campos.
		If !lVlOnlyRet
			If !lPccMR .And. M->E2_BASEPIS > 0 .AND. M->E2_BASEPIS <> M->E2_VALOR
				nBasePCC := IIF ((M->E2_VALOR <= nVlMinImp),M->E2_VALOR,M->E2_BASEPIS)
			Else
				If M->E2_VALOR <> SE2->E2_VALOR .And. lAltera .And. M->E2_VALOR <= nVlMinImp
					If !lPccMR .And. (lPccBaixa .Or. (!lPccBaixa .And. nBasePCC <> M->E2_BASEPIS))
						nBasePCC := If(nVlrMR > 0, nVlrMR, SE2->E2_VALOR)
					Endif
				ElseIf !lF050Auto	// A base do pcc já foi obtida pela ExecAuto
					nBasePCC := If(nVlrMR > 0, nVlrMR, m->e2_valor)
			  Endif
			Endif
		Else
			If lBtrISS
				nBasePCC := m->e2_valor + m->e2_irrf + If(!lCalcIssBx,m->e2_iss+m->e2_btriss,0) + If(!lInssBX,m->e2_inss,0)
			Else
				nBasePCC := m->e2_valor + m->e2_irrf + If(!lCalcIssBx,m->e2_iss,0) + If(!lInssBX,m->e2_inss,0)
			EndIf
		Endif
	Endif

	If !lPccMR

		If  ( READVAR() <> 'M->E2_MOEDA').And. M->E2_VALOR + IF(!lIRPFBaixa .And. M->E2_MOEDA != 1, xMoeda(M->E2_IRRF,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 0) <> M->E2_BASEPIS .And. !lPCCBaixa .And. !lAltera
			If M->E2_MOEDA == 1 
				m->e2_valor += (m->e2_pis + m->e2_cofins + m->e2_csll)
			Else
				M->E2_VALOR += (xMoeda(m->e2_pis + m->e2_cofins + m->e2_csll,1,M->E2_MOEDA,M->E2_EMISSAO,3,,nOldTxMoeda) )
			EndIf
		Endif

		If M->E2_VALOR <> M->E2_BASEPIS .And. !lPCCBaixa .And. lAltera .And. (Month(M->E2_VENCREA) <> Month(dVencReaAnt)) .And.;
				nBasePcc == M->E2_BASEPIS .And. M->E2_LA <> "S" .And. M->E2_BASEPIS <= nVlMinImp .And. M->E2_VALOR < nBasePcc
			m->e2_valor += (m->e2_pis + m->e2_cofins + m->e2_csll)
		Endif
	EndIf

	If !lIrfMR  .And. !lIRPFBaixa .And. M->E2_VALOR <> M->E2_BASEIRF   
		If  ("M->E2_TXMOEDA" $ cField .And. lAltTxMoeda .And. !lAltValor ) .Or. "M->E2_BASEPIS" $ cField 
			If !(lIRPFBaixa .And. M->E2_TIPO $ MVPAGANT) 
				//If !lAplMinIR .Or.( lAplMinIR .And. xMoeda(M->E2_IRRF,1,M->E2_MOEDA,M->E2_EMISSAO,3,,M->E2_TXMOEDA)  > GetMv("MV_VLRETIR"))
				If !lAplMinIR .Or.( lAplMinIR .And.(M->E2_IRRF > GetMv("MV_VLRETIR")))
				  	If M->E2_MOEDA == 1
				  		M->E2_VALOR += M->E2_IRRF
				  	Else
				  		M->E2_VALOR += (xMoeda(M->E2_IRRF,1,M->E2_MOEDA,M->E2_EMISSAO,3,,M->E2_TXMOEDA) )
				  	EndIf
				Else
					M->E2_VALOR += (xMoeda(nIrrfAnt,1,M->E2_MOEDA,M->E2_EMISSAO,3,,nOldTxMoeda) )
					nIrrfAnt	:= 0 
				EndIf				
			EndIf
		EndIf		
	EndIf
	
	If !lInsMR .and. !lInssBX .And. M->E2_VALOR <> M->E2_BASEINS .And.  cField $ "M->E2_TXMOEDA" .And. M->E2_MOEDA > 1 .And. M->E2_TXMOEDA > 1
		If  cField $ "M->E2_TXMOEDA" .And. lAltTxMoeda .And. !lAltValor
			M->E2_VALOR += (xMoeda(M->E2_INSS,1,M->E2_MOEDA,M->E2_EMISSAO,3,,M->E2_TXMOEDA) )
		EndIf
	Endif
	
	If !lIssMR  .And. !lCalcIssBx .And. M->E2_VALOR <> M->E2_BASEPIS .And. cField $ "M->E2_BASEPIS/M->E2_TXMOEDA"
		If M->E2_MOEDA > 1
			M->E2_VALOR += (xMoeda(M->E2_ISS,1,M->E2_MOEDA,M->E2_EMISSAO,3,,M->E2_TXMOEDA) ) + If(lBtrISS,xMoeda(M->E2_BTRISS,1,M->E2_MOEDA,M->E2_EMISSAO,3,,M->E2_TXMOEDA),0) 
		Else 
			M->E2_VALOR += M->E2_ISS + If(lBtrISS,M->E2_BTRISS,0)
		EndIf
	EndIf

	If M->E2_EMISSAO < dLastPCC .Or. lEmpPub
		//PIS
		//³ se natureza pede calculo do PIS      ³
		If !lPccMR
			If SED->ED_CALCPIS == "S"  .and. SA2->A2_RECPIS == "2"
				If ! GetNewPar("MV_RNDPIS",.F.)
					m->e2_pis := NoRound((nBasePCC * (SED->ED_PERCPIS / 100)),2)
				Else
					m->e2_pis := Round((nBasePCC * (SED->ED_PERCPIS / 100)),2)
				Endif
			Else
				m->e2_pis := 0
				nOldPis	 := 0
			EndIf

			nPisCalc := m->e2_pis
			nPisBaseC := nBasePCC

			// COFINS
			//³ se natureza pede calculo do COFINS	  ³
			If SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI == "2"
				If ! GetNewPar("MV_RNDCOF",.F.)
					m->e2_cofins := NoRound((nBasePCC * (SED->ED_PERCCOF / 100)),2)
				Else
					m->e2_cofins := Round((nBasePCC * (SED->ED_PERCCOF / 100)),2)
				Endif
			Else
				m->e2_cofins := 0
				nOldCofins	 := 0
			EndIf

			nCofCalc := m->e2_cofins
			nCofBaseC := nBasePCC

			// CSLL
			//³ se natureza pede calculo do CSLL ³
			If SED->ED_CALCCSL == "S"  .and. SA2->A2_RECCSLL == "2"
				If ! GetNewPar("MV_RNDCSL",.F.)
					m->e2_csll := NoRound((nBasePCC * (SED->ED_PERCCSL / 100)),2)
				Else
					m->e2_csll := Round((nBasePCC * (SED->ED_PERCCSL / 100)),2)
				Endif
			Else
				m->e2_csll := 0
				nOldCsll	  := 0
			Endif

			nCslCalc := m->e2_csll
			nCslBaseC := nBasePCC
		EndIf
	Else
		If !lPccMR
			If nVencto == 2
				dRef := M->E2_VENCREA
			ElseIf nVencto == 1 .OR. EMPTY(nVencto)
				dRef := M->E2_EMISSAO
			ElseIf nVencto == 3
                dRef := dDataEmis1
			Endif

			aPCC := newMinPcc(dRef, xMoeda(M->E2_BASEPIS,M->E2_MOEDA,1,M->E2_EMISSAO,3,M->E2_TXMOEDA) ,M->E2_NATUREZ,"P",M->(E2_FORNECE + E2_LOJA))
			nOldPis	 := m->e2_pis := nPis := aPCC[2]
			nOldCofins	 := m->e2_cofins := nCofins := aPCC[3]
			nOldCsll	 := m->e2_csll := nCsll := aPCC[4]

			If M->E2_TIPO $ MVPAGANT .Or. !lPccBaixa
				M->E2_VRETPIS := nVlRetPis := nPis
				M->E2_VRETCOF := nVlRetCof := nCofins
				M->E2_VRETCSL := nVlRetCsl := nCsll
			Else
				M->E2_VRETPIS := nVlRetPis := 0
				M->E2_VRETCOF := nVlRetCof := 0
				M->E2_VRETCSL := nVlRetCsl := 0
			EndIf
		EndIf
	EndIf

	//Verificar os minimos de retencao do Pis, Cofins e Csll
	If !lPccBaixa .and. lAplVlMin //Caso nao seja pela baixa, verifica valor do titulos.
		If !lPccMR .And. (M->E2_EMISSAO < dLastPcc .Or. lEmpPub)
			If !lAltera .And. nBasePCC > GetNewPar("MV_VL10925",5000)
				aAreaSE2 := SE2->(GetArea())
				aRecSE2 := FImpExcTit("SE2",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
				For nX := 1 to Len(aRecSE2)
					SE2->(MSGoto(aRecSE2[nX]))
					m->e2_pis    += SE2->E2_PIS
					m->e2_cofins += SE2->E2_COFINS
					m->e2_csll   += SE2->E2_CSLL
				Next
				RestArea(aAreaSE2)
			EndIf
			FVerMinImp(nBasePcc)
		EndIf

	ElseIF M->E2_TIPO $ MVPAGANT  //Verifico se eh PA para calcular tx's na emissao
		nValPgto := nBasePCC

		//Atualiza o valor do titulo antes de calcular as retencoes pendentes.
		If !(lIRPFBaixa .And. M->E2_TIPO $ MVPAGANT)
			nVlAltSEST 	:= m->e2_sest
			M->E2_VALOR := M->E2_VALOR - Round(xMoeda(M->E2_IRRF + If(!lCalcIssBx, M->E2_ISS + If(lBtrISS, M->E2_BTRISS, 0), 0) +;
				If(!lPrImPA, If(!lInssBX, M->E2_INSS, 0), 0) + nValSEST,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
		Endif

		If !lIssMR .And. lInssBx .And. lPrImPA
			m->e2_valor -= m->e2_inss
		EndIf

		If !lPccMR .And. (M->E2_EMISSAO < dLastPcc  .Or. lEmpPub)
			//Grava campos da memoria (SE2), com conteudo das variaveis privates carregadas pela F080TotMes().
			//Efetua varredura no SE5 para buscar titulos que ainda estejam pendentes retencao por valor insuficiente.
			F080TotMes(M->E2_EMISSAO,.T.,.T.)

			M->E2_PIS     := nPis
			M->E2_COFINS  := nCofins
			M->E2_CSLL    := nCsll
			M->E2_VRETPIS := nVlRetPis
			M->E2_VRETCOF := nVlRetCof
			M->E2_VRETCSL := nVlRetCsl
		EndIf
	Endif
EndIf

nVlAltInss 	:= If(!lInsMR .And. !lInssBx,m->e2_inss,0)
nVlAltSEST 	:= m->e2_sest

lFirstAlt	:= .F.

// Caso a funcao Fa050Nat2 tenha sido chamada a partir da alteracao dos campos de Irrf (.T.), Inss e Iss,
// Fazemos os recalculos dos impostos da lei 10925  sem e fazer a recarga dos valores destes campos.
If !lVlOnlyRet .and. !lAltVcto .And. cPaisLoc == "BRA"
	// Se existir os campos de impostos a pagar, PIS, COFINS, CSLL - MP 135
	If !lPCCBaixa
		If !lIssMR
			If lBtrISS
				m->e2_valor -= xMoeda(If(!lCalcIssBx,m->e2_iss+m->e2_btriss,0),1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA)
			Else
				m->e2_valor -= xMoeda(If(!lCalcIssBx,m->e2_iss,0),1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA)
			EndIf
		EndIf

		If !lInsMR
			m->e2_valor -= Iif(M->E2_MOEDA == 1,If(!lInssBx,m->e2_inss,0), xMoeda(If(!lInssBx,m->e2_inss,0),1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA) )
		EndIf
		m->e2_valor -= nValSEST

		If lAltera
			If !lPccMR
				If (SE2->E2_VALOR <>  M->E2_VALOR)
					If !(M->E2_VALOR == M->E2_BASEPIS - (Iif(M->E2_MOEDA == 1,(m->e2_pis + m->e2_cofins + m->e2_csll), xMoeda((m->e2_pis + m->e2_cofins + m->e2_csll),1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA) )))
						m->e2_valor -= Iif(M->E2_MOEDA == 1,(m->e2_pis + m->e2_cofins + m->e2_csll), xMoeda((m->e2_pis + m->e2_cofins + m->e2_csll),1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA) )
					Endif
				Elseif M->E2_VALOR == M->E2_BASEPIS
					If !(M->E2_VALOR == M->E2_BASEPIS - (Iif(M->E2_MOEDA == 1,(m->e2_pis + m->e2_cofins + m->e2_csll), xMoeda((m->e2_pis + m->e2_cofins + m->e2_csll),1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA) )))
						m->e2_valor -= Iif(M->E2_MOEDA == 1,(m->e2_pis + m->e2_cofins + m->e2_csll), xMoeda((m->e2_pis + m->e2_cofins + m->e2_csll),1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA) )
					 Endif
					 If M->E2_SALDO == M->E2_BASEPIS
				 		m->e2_saldo -= Iif(M->E2_MOEDA == 1,(m->e2_pis + m->e2_cofins + m->e2_csll), xMoeda((m->e2_pis + m->e2_cofins + m->e2_csll),1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA) )
					 Endif
				Endif
			Endif
		ElseIf !lPccMR
			If M->E2_MOEDA == 1
				M->E2_VALOR -= (M->E2_PIS+M->E2_COFINS+M->E2_CSLL)
			Else
				M->E2_VALOR -= Round(xMoeda(M->E2_PIS,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
				M->E2_VALOR -= Round(xMoeda(M->E2_COFINS,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
				M->E2_VALOR -= Round(xMoeda(M->E2_CSLL,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
			EndIf
		Endif

		If !lJaDescIr
			If !lIrfMR .And. !lIRPFBaixa
				If M->E2_MOEDA == 1
					M->E2_VALOR -= m->e2_irrf
				ElseIf cField == "M->E2_MOEDA" .And. M->E2_MOEDA > 1 .And. lSumIR .And. nCalcIr > 0
					M->E2_VALOR -= xMoeda(If(Empty(m->e2_irrf), nCalcIr, m->e2_irrf), 1, M->E2_MOEDA, M->E2_EMISSAO, 3,1, M->E2_TXMOEDA)
				Else
					M->E2_VALOR -= IIF(nValIrOld > 0, nValIrOld, xMoeda(m->e2_irrf,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA))
				EndIf
			EndIf
		EndIf

		If !lIssMR .And. M->E2_TIPO $ MVPAGANT .And. lCalcIssBx //Caso ISS seja na emissao nesta ponto da rotina ele jah foi descontado.
			m->e2_valor := m->e2_valor - m->e2_iss
		Endif

		If !lIrfMR .And. M->E2_TIPO $ MVPAGANT .And. lIRPFBaixa //Caso IR seja na emissao nesta ponto da rotina ele jah foi descontado.
			m->e2_valor := m->e2_valor - m->e2_irrf
		Endif

		If lPrImPA
			If !lInsMR
				m->e2_valor := m->e2_valor - Iif(M->E2_MOEDA == 1,M->E2_PRINSS, xMoeda(M->E2_PRINSS,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA) )
			EndIf
			If !lIssMR .And. !lCalcIssBx
				m->e2_valor := m->e2_valor - M->E2_PRISS
			EndIf
		EndIf
	Else
		If M->E2_TIPO $ MVPAGANT .And. !lInsPub
			m->e2_valor := m->e2_valor - Iif(M->E2_MOEDA == 1,(Iif(!lInssBX,m->e2_inss,0) + nValSEST), xMoeda((Iif(!lInssBX,m->e2_inss,0) + nValSEST),1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA) )
			If !(lEmpPub .And. lIRPFBaixa .And. lAplMinP .And. M->(E2_PIS+E2_COFINS+E2_CSLL+E2_IRRF) < nVlMPub)
				If !lPccMR
					If M->E2_MOEDA == 1
						M->E2_VALOR -= (M->E2_PIS+M->E2_COFINS+M->E2_CSLL)
					Else
						M->E2_VALOR -= Round(xMoeda(M->E2_PIS,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
						M->E2_VALOR -= Round(xMoeda(M->E2_COFINS,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
						M->E2_VALOR -= Round(xMoeda(M->E2_CSLL,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
					EndIf

					If !lIrfMR .And. lIRPFBaixa  //Caso IR na emissao neste momento ele vem descontado na variavel E2_VALOR.
						M->E2_VALOR := M->E2_VALOR - Iif(M->E2_MOEDA == 1, M->E2_IRRF, Round(xMoeda(M->E2_IRRF,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA),2))
					Endif
				Endif
			EndIf

			If lPrImPA
				If !lInsMR
					m->e2_valor := m->e2_valor - Iif(M->E2_MOEDA == 1,M->E2_PRINSS, xMoeda(M->E2_PRINSS,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA) )
				EndIf
				If !lIssMR .And. !lCalcIssBx
					M->E2_VALOR := M->E2_VALOR - Iif(M->E2_MOEDA == 1, M->E2_PRISS, Round(xMoeda(M->E2_PRISS,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA),2))
				EndIf
			EndIf

			If !lIssMR .And. ((!lCalcIssBx .And. lIRPFBaixa) .Or. lCalcIssBx)//Casos em que o ISS deve ser descontado na variavel E2_VALOR.
				m->e2_valor := m->e2_valor - m->e2_iss - If(lBtrISS, m->e2_btriss, 0)
			Endif
		Else
			If cPaisLoc== "BRA"

				If _nImpMR == 0
					m->e2_valor := Iif(M->E2_MOEDA > 1, M->E2_VALOR, IIF(nBaseIss==0,IIF(nBaseIns==0,nBaseIrrf,nBaseIns),nBaseIss))
				Endif

				If !lIssMR .and. !lCalcIssBx
					m->e2_valor -= ROUND(xMoeda(m->e2_iss + If(lBtrISS, m->e2_btriss, 0),1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(M->E2_MOEDA)+1,,M->E2_TXMOEDA),MsDecimais(M->E2_MOEDA))
				Endif

				If !lInsMR .and. !lInssBX
					m->e2_valor -= ROUND(xMoeda(m->e2_inss,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(M->E2_MOEDA)+1,,M->E2_TXMOEDA),MsDecimais(M->E2_MOEDA))
				Endif

				If !lIrfMR .and. !lIRPFBaixa .And. !lJaDescIr
					m->e2_valor -= xMoeda(m->e2_irrf,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(M->E2_MOEDA)+1,,M->E2_TXMOEDA)
				EndIf

				m->e2_valor -= nValSEST

				If cPaisLoc <> "BRA" .And. ReadVar() == "M->E2_VALOR" .And. M->E2_VALOR == 0
					If nValBruto > 0
						M->E2_VALOR := nValBruto
					EndIf
				EndIf

				If !lInsMR
					If lPrImPA
						m->e2_valor := m->e2_valor - Iif(M->E2_MOEDA == 1,M->E2_PRINSS, xMoeda(M->E2_PRINSS,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA) )
						If !lCalcIssBx
							m->e2_valor := m->e2_valor - M->E2_PRISS
						EndIf
					Endif
				EndIf
			EndIf
		Endif
	Endif
	//Restitui os impostos para PA BRUTO
	If (m->e2_tipo $ MVPAGANT .and. lPaBruto) .and. (!lInsPub .or. (lInsPub .and. ReadVar() <> "M->E2_VALOR"))
		If !lPccMR
			m->e2_valor := m->e2_valor + Iif(M->E2_MOEDA == 1,(m->e2_pis + m->e2_cofins + m->e2_csll), xMoeda((m->e2_pis + m->e2_cofins + m->e2_csll),1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA) )
		EndIf
		If !lIrfMR
			m->e2_valor := m->e2_valor + Iif(M->E2_MOEDA == 1,m->e2_irrf, xMoeda(m->e2_irrf,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA) )
		EndIf
		If !lIssMR
			m->e2_valor := m->e2_valor + Iif(M->E2_MOEDA == 1,If(lBtrISS,m->e2_iss+m->e2_btriss,m->e2_iss), xMoeda(If(lBtrISS,m->e2_iss+m->e2_btriss,m->e2_iss),1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA) )
		EndIf
	Endif

	If !lIrfMR .And. m->e2_valor < 0
		m->e2_irrf  += m->e2_valor - 0.01
		m->e2_valor := 0.01
	EndIf

	//Verifica se havera retencao do INSS
	If !lInssBx
		If !lInsMR .And. SED->ED_DEDINSS == "2"  //Nao desconta o Inss do principal
			m->e2_valor += Iif(M->E2_MOEDA == 1,Iif(!lInssBx,m->e2_inss,0), xMoeda(Iif(!lInssBx,m->e2_inss,0),1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA) )
		Endif
	Endif
Endif
//³ Calculo das Retenções - Republica Dominicana	  ³
If 	cPaisLoc $ "DOM|COS"
	Help(" ",1,"FA050FRM",,"Tabela 'FRM', 'FRN' ou 'CCR' não faz parte do Dicionário de Dados") //"Tabela 'FRM', 'FRN' ou 'CCR' não faz parte do Dicionário de Dados"
EndIf
//³ Inicializa o valor em Real como sugestao					³
nSavRec := SX3->(Recno())
cMascara:=PesqPict("SE2","E2_VLCRUZ",19,MsDecimais(1))
SX3->(DbGoto(nSavRec))
M->E2_VLCRUZ:=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))

m->e2_saldo := m->e2_valor
nOldValor	:= m->e2_valor
nOldSaldo 	:= m->e2_saldo
nOldIRR		:= m->e2_irrf
nOldISS		:= m->e2_iss
If lBtrISS
	nOldBtrISS	:= m->e2_btriss
EndIf
nOldInss	:= m->e2_inss
nOldSEST	:= m->e2_sest
nOldPis		:= m->e2_pis
nOldCofins	:= m->e2_cofins
nOldCsll	:= m->e2_csll
nOldValorPg := nOldValor
lRefresh 	:= .T.

Return .t.

/*
±±³Fun‡…o	 ³F050PesInd³ Autor ³ Bruno Sobieski Chavez ³ Data ³ 08/09/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Pesquisa para IndRegua (quando na funçao que chama aRotina |±±
±±³       	 ³ nao e possivel enviar parametros).						  ³±±
*/
Function FA050PesInd
AxPesqInd(cIndice,cIndexArg)
Return

/*/
±±³Fun‡…o	 ³FA050AxInc³ Autor ³ Mauricio Pequim Jr	³ Data ³ 04/08/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Fun‡Æo para complementacao da inclusao de C.Pagar		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ FA050AxInc(ExpC1) 										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo									  ³±±
/*/
Function FA050AxInc(cAlias)
Local lRet := .T.
Local aSaveArea	:= GetArea()
Local nSavRec
Local nSavRecA2
Local cArquivo
Local cPadrao
Local lDigita
Local lPadrao	:= .F.
Local nTotal	:=0
Local nHdlPrv	:=0
Local cArq
Local nIndex 	:= IndexOrd()
Local nValSaldo	:= 0
Local lHeader	:= .F.
Local lDesdobr 	:= .F.
Local nMoedSE2 	:= SE2->E2_MOEDA
Local cSeq
Local lF050Inc 	:= (ExistBlock("F050INC"))
Local cOrdPago
Local cBancoCx
Local nRecCtb	:= 0
Local aParc 	:= {}
Local aTps		:= {}
Local nX 		:= 0
Local aRecnos 	:= {}
Local nLoop 	:= 0
Local nSobra 	:= 0
Local nValorTit := 0
Local nRetOriPIS:= 0
Local nRetOriCOF:= 0
Local nRetOriCSL:= 0
Local nVlMinImp := GetNewPar("MV_VL10925",5000)
Local nFatorRed := 0
Local lRetParc	:= .T.
Local lRestValImp := .F.
Local lContrRet := .T.

Local nInss 	:= SE2->E2_INSS
Local cPrefOri  := SE2->E2_PREFIXO
Local cNumOri   := SE2->E2_NUM
Local cParcOri  := SE2->E2_PARCELA
Local cTipoOri  := SE2->E2_TIPO
Local cCfOri    := SE2->E2_FORNECE
Local cLojaOri  := SE2->E2_LOJA
Local nDiferImp := 0
Local lDigitado := .F.
Local lPccBxPA  := .F.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

//1-Cria NCC/NDF referente a diferenca de impostos entre emitidos (SE2) e retidos (SE5)
//2-Nao Cria NCC/NDF, ou seja, controla a diferenca num proximo titulo
//3-Nao Controla
Local cNccRet		:= SuperGetMv("MV_NCCRET",.F.,"1")
Local lIRPFBaixa 	:= .F.
Local nCalcPis 		:= 0
Local nCalcCof 		:= 0
Local nCalcCsl 		:= 0
Local nVlPrinc
Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local lSetAuto		:= .F.
Local lSetHelp		:= .F.
Local cProcPCO		:= "000021"
Local cItemPCO		:= "01"
Local cRecPag 		:= "P"
Local aFlagCTB 		:= {}
Local lUsaFlag		:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
Local lCtMovPa		:= SuperGetMv("MV_CTMOVPA",.T.,"1") == "2" // Indica se a Contabilizacao do LP513 ocorrer pelo Titulo(SE2) ou Mov.Bancario(SE5) do Pagamento Antecipado. 1="SE2" / 2="SE5"
Local nRecSE2		:= 0
Local lSisAltPIS	:= .F.
Local lSisAltCOF	:= .F.
Local lSisAltCSL 	:= .F.
Local aDiario	 	:= {}
Local lEnd			:= .F.
Local lAtuSldNat 	:= .T.
Local lEmpPub    	:=  IsEmpPub()
Local nVlMPub		:= SuperGetMv("MV_VLMPUB" ,.T.,10)
Local lAplMinP := .F.
Local lCopy  		:= FwIsInCallStack("FINA631")
Local lEmprest  	:= FwIsInCallStack("FINA171") .and. (AllTrim(SE2->E2_PREFIXO) == "EMP" .and. AllTrim(SE2->E2_TIPO) == "PR" .and. AllTrim(SE2->E2_NATUREZ) == "EMPRESTIMO")

//Importacao via MILE
Local lMile   := FwIsInCallStack("CFG600LMdl") .Or. FwIsInCallStack("FWMILEIMPORT") .Or. FwIsInCallStack("FWMILEEXPORT")
Local cFilAux := ""
//Base de imposto Variavel
Local lBaseImp	 	:= F050BSIMP(2)	//Verifica a existência dos campos
Local lFA050CT		:= Existblock("FA050CT")

// Ignora recalculo de impostos
Local lRefImp		:= SuperGetMv('MV_REFIMP',,.F.)    //-- Usado pelo TMS com Operadora de Frota
Local lTmsOper		:= SuperGetMv('MV_VSREPOM',,'1')  == '2' .And. SuperGetMv('MV_TMSOPDG',,'1')  == '2'

//Controle de Desdobramento
Local lNRastDSD 	:= SuperGetMV("MV_NRASDSD",.T.,.F.)

Local oMBrowse 		:= GetObjBrow()
Local lInssBx 		:= SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
Local nMinINS1 		:= SuperGetMv("MV_MININSS",.F.,0)
Local nLimInss 		:= SuperGetMv("MV_LIMINSS",.F.,0)
Local nMinINS2 		:= SuperGetMv("MV_VLRETIN",.F.,0)
Local lInsPub 		:= SuperGetMv("MV_INSPUB",,.F.) .And. nMinINS1 == 0 .And.;
nLimInss == 0 .And. nMinINS2 == 0 //Inss Baixa com empresa publica. Neste caso os valores do inss não tem valor minimo ou maximo de retencao.
Local cGeraDirf 	:= SE2->E2_DIRF
Local cCodRetIr 	:= SE2->E2_CODRET
Local aAreaSE2 		:= SE2->(GetArea())
Local aAreaSA2 		:= SA2->(GetArea())
Local aAreaSE5 		:= SE5->(GetArea())
Local lSpbInUse 	:= SpbInUse()
Local cModSpb		:= "1"
//Nova estrutura SE5
Local oModel
Local oSubFK2
Local oSubFKA
Local cLog := ""
Local aAreaAnt
Local lFA050GRV := ExistBlock("FA050GRV")
Local lFA050FIN := ExistBlock("FA050FIN")

Local lIntPFS   := SuperGetMV("MV_JURXFIN",,.F.) // Integração SIGAPFS x SIGAFIN

//Motor de Retenções.
Local aMotRet := AClone(aVetImp)
Local nRecTitPai := 0
Local cPret := ""

Default lPccMR := .F.
Default lIrfMR := .F.
Default lInsMR := .F.
Default lIssMR := .F.
Default lCidMR := .F.
Default lSestMR := .F.
Default lOutImpMR := .F.

//restaura valor inicial da variav static
aVetImp := {}

If SE2->E2_EMISSAO >= dLastPcc .and. !lEmpPub
	nVlMinImp := 0
EndIf

If lSpbInUse
	cModSpb := IIf(Empty(SE2->E2_MODSPB), "1",SE2->E2_MODSPB)
Endif
If lRefImp .And. lTmsOper .And. (FwIsInCallStack('TMSQUITAC') .Or. FwIsInCallStack('TMA250SE2'))
	lBaseImp := .F.
EndIf

If Type("lAltValor") <> "L"
	lAltValor := .F.
ElseIf !lAltValor
	lAltValor := (Type("nOldValorPg") == "N" .And. STR(nOldValorPg,17,2) != STR(M->E2_VALOR,17,2))
Endif

If !lInsMR .And. !lInssBx
	IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
		nInss := 0
	Endif
Endif

If Type("aColsSev") != "A"
	aColsSev := {}
Endif
If Type("aColsSev") != "A"
	aHeaderSev := {}
Endif

cBancoCx:=GetMv("MV_CARTEIR")

If M->E2_TIPO == MVPAGANT
	IF !(E2_ACRESC = 0 .and. E2_DECRESC = 0)
		help("", 1, "F050PAAD",, STR0320, 1, 0)  // "Títulos do tipo PA não podem ter valores de acréscimo ou decréscimo."
		lRet := .F.
	EndIf
EndIf

If lRet
	If lMile .And. Type("M->E2_FILIAL") # Nil
		cFilAux := cFilAnt
		cFilAnt := M->E2_FILIAL
	EndIf

	dbSelectArea("SA2")
	DbSetOrder(1)
	dbSeek(xFilial("SA2")+SE2->E2_FORNECE+SE2->E2_LOJA)

	nSavRecA2 := RecNo()
	lIRProg := IIf(cPaisLoc == "BRA",IIf(!Empty(SA2->A2_IRPROG),SA2->A2_IRPROG,"2"),"2")

	lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)

	lEmpPub := (lEmpPub .and. lIRPFBaixa)
	If SA2->A2_MINPUB == "2"
		lAplMinP := .T.
	EndIf
	dbSelectArea(cAlias)
	RecLock(cAlias)
	// Grava filial do titulo com base no arq txt
	If lMile .And. Type("M->E2_FILIAL") # Nil
		SE2->E2_FILIAL := cFilAnt
	EndIf
	SE2->E2_NOMFOR	 := SA2->A2_NREDUZ
	SE2->E2_EMIS1	 := dDataEmis1
	SE2->E2_VENCORI := E2_VENCTO
	SE2->E2_SALDO	 := E2_VALOR
	SE2->E2_BAIXA	 := CtoD("  /  /  ")
	SE2->E2_NUMBCO  := cChequeAdt
	SE2->E2_ORIGEM  := If(Empty(SE2->E2_ORIGEM),"FINA050",SE2->E2_ORIGEM)
	SE2->E2_LA		 := Iif(cPaisLoc $ "ARG|ANG|COL|MEX" .And. Alltrim(SE2->E2_TIPO) == "PA","S",Iif (lCopy .and. !Empty(M->E2_LA),"S",Iif(Type("lF050Auto") == "L" .And. lF050Auto .and. M->E2_LA == "S","S"," " )))
	SE2->E2_SDACRES := E2_ACRESC
	SE2->E2_SDDECRE := E2_DECRESC
	IF cPaisLoc=="EUA" .and. SE2->(FieldPos("E2_SLPLAID")) > 0//Para uso de integracion con PLAID
		SE2->E2_SLPLAID	 := SE2->E2_VALOR
		SE2->E2_BCOPAG	 := SA2->A2_BANCO
	ENDIF

	If SE2->E2_TIPO $ MVABATIM // Grava titulo pai no abatimento
		SE2->E2_TITPAI := cTitPaiAB
	EndIf

	If !lIssMR .And. lCalcIssBx
		SE2->E2_TRETISS := "2"
	Endif
	SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)

	//Final da gravacao do titulo principal
	FKCOMMIT()
	nSavRec	:= RecNo()

	If lF050Inc
		ExecBlock("F050INC",.F.,.F.)
	EndIf

	//Chamada de funcao para tratamento da Average
	If lIntegracao
		FI400VALFIN()
	EndIf
	//³ Rotina de complemento de grava‡„o de t¡tulo a pagar ³
	//³ ser  utilizada apenas se o titulo NŽO for desdobra- ³
	//³ bramento. Caso seja um desdobramento, somar  o valor³
	//³ das parcelas par atualizar o saldo do fornecedor.   ³
	nValSaldo := 0

	If ( cPaisLoc == "BRA" )
		If lPccMR
			If M->E2_TIPO $ MVPAGANT .And. M->(E2_PIS+E2_COFINS+E2_CSLL) > 0
				RecLock("SE2",.F.)
				If M->E2_PIS > 0
					SE2->E2_VRETPIS := SE2->E2_PIS
				EndIf
				If M->E2_COFINS > 0
					SE2->E2_VRETCOF := SE2->E2_COFINS
				EndIf
				If M->E2_CSLL > 0
					SE2->E2_VRETCSL := SE2->E2_CSLL
				EndIf
				MsUnlock()
			EndIf
		Else
			If M->E2_TIPO $ MVPAGANT+"/"+MV_CRNEG .And. lPccBaixa //Se for PA e for pela Baixa (pis, cofins e csll), verifica valores digitados manualmente
				//PIS digitado manualmente
				If M->E2_PIS > 0
					RecLock("SE2",.F.)
					nVlRetPis     := SE2->E2_PIS
					SE2->E2_VRETPIS := nVlRetPis
					MsUnlock()
					lDigitado := .T.
				EndIf
				//COFINS digitado manualmente
				If M->E2_COFINS > 0
					RecLock("SE2",.F.)
					nVlRetCof     := SE2->E2_COFINS
					SE2->E2_VRETCOF := nVlRetCof
					MsUnlock()
					lDigitado := .T.
				EndIf
				//CSLL digitado manualmente
				If M->E2_CSLL > 0
					RecLock("SE2",.F.)
					nVlRetCsl     := SE2->E2_CSLL
					SE2->E2_VRETCSL := nVlRetCsl
					MsUnlock()
					lDigitado := .T.
				EndIf
			Else
				//PIS digitado manualmente
				If (SED->ED_CALCPIS == "N" .OR. SA2->A2_RECPIS == "1" .OR. lAltValor) .and. M->E2_PIS > 0
					nVlRetPis := M->E2_PIS
					lDigitado := .T.
				EndIf
				//COFINS digitado manualmente
				If (SED->ED_CALCCOF == "N" .OR. SA2->A2_RECCOFI == "1" .OR. lAltValor) .and. M->E2_COFINS > 0
					nVlRetCof := M->E2_COFINS
					lDigitado := .T.
				EndIf
				//CSLL digitado manualmente
				If (SED->ED_CALCCSL == "N" .OR. SA2->A2_RECCSLL == "1" .OR. lAltValor) .and. M->E2_CSLL > 0
					nVlRetCsl := M->E2_CSLL
					lDigitado := .T.
				EndIf
			Endif
		EndIf
	Else
		nVlRetPis := 0
		nVlRetCof := 0
		nVlRetCsl := 0
	EndIf

	//Se o titulo eh um PA forca a geracao dos tx's na emissao
	If SE2->E2_TIPO $ MVPAGANT
		lPccBxPA := .T.
	EndIf

	//Alteracao na posicao do tratamento de desdobramento, para que caso o usuario cancele o desdobramento, o titulo receba o
	//tratamento de um titulo sem desdobramento
	//FNC : 00000028610/2009
	If SE2->E2_DESDOBR == "S"
		lDesdobr := .T.
		lRatDes  := .T.
		nRecSe2 := SE2->(RECNO())
		//realiza a gravacao do model do titulo desdobrado
		If cPaisLoc=="BRA"
			Fa986grava("SE2","FINA050")
		EndIf
		Processa({|| GeraParcSe2(cAlias,@lEnd,@nHdlPrv,@nTotal,@cArquivo,nSavRecA2,nSavRec,lUsaFlag,@aFlagCTB)})
		SE2->(DbGoTo(nRecSe2))
		lHeader := nHdlPrv > 0
		If lEnd
			lDesdobr := .F.
		EndIf
	EndIf

	//³ Atualiza dados complementares do titulo    ³
	If SE2->E2_DESDOBR == "N"
		If !lPccMR
			If lContrRet .and. !lDigitado .and. !lPccBaixa

				//Controle de base de impostos
				If lBaseImp .And. SE2->E2_BASEPIS > 0
					nValorTit := SE2->E2_BASEPIS
				Else
					nValorTit := SE2->(E2_VALOR+E2_PIS+E2_COFINS+E2_CSLL+Iif(lIRPFBaixa,0,E2_IRRF)+Iif(lInssBx,0,E2_INSS)+E2_ISS)+;
					Iif(cPaisLoc == 'BRA', SE2->E2_SEST, 0)
				Endif

				Do Case
					Case cModRetPIS == "1"
						If aDadosRet[ 1 ] + nValorTit	> nVlMinImp
							lRetParc := .T.
							//³ Guarda os valores originais                           ³
							nRetOriPIS := nVlRetPis
							nRetOriCOF := nVlRetCOF
							nRetOriCSL := nVlRetCSL

							If cNCCRet == "2" .And. aDadosImp[1] <> aDadosRet[2]
								nVlRetPis += aDadosImp[1]
							EndIf

							If cNCCRet == "2" .And. aDadosImp[2] <> aDadosRet[3]
								nVlRetCof += aDadosImp[2]
							EndIf

							If cNCCRet == "2" .And. aDadosImp[3] <> aDadosRet[4]
								nVlRetCsl += aDadosImp[3]
							EndIf

							nVlRetPIS := aDadosRet[ 2 ] + nVlRetPis
							nVlRetCOF := aDadosRet[ 3 ] + nVlRetCOF
							nVlRetCSL := aDadosRet[ 4 ] + nVlRetCSL

							nTotARet := nVlRetPIS + nVlRetCOF + nVlRetCSL

							nValorTit := SE2->(E2_VALOR+E2_PIS+E2_COFINS+E2_CSLL)

							nSobra := nValorTit - nTotARet

							If nSobra < 0

								nFatorRed := 1 - ( Abs( nSobra ) / nTotARet )

								nVlRetPIS  := NoRound( nVlRetPIS * nFatorRed, 2 )
								nVlRetCOF  := NoRound( nVlRetCOF * nFatorRed, 2 )

								nVlRetCSL := nValorTit - ( nVlRetPIS + nVlRetCOF ) - 0.01

								//Gero NCC com a diferenca
								nDiFerImp := nTotARet - (nVlRetPIS + nVlRetCOF + nVlRetCSL)
								If cNccRet == "1"
									ADupCredRt(nDiferImp,"501",SE2->E2_MOEDA,.T.)
								Endif

							EndIf

							lRestValImp := .T.

							//³ Grava os novos valores de retencao para este registro ³
							RecLock( "SE2", .F. )
							SE2->E2_PIS		:= nVlRetPIS
							SE2->E2_COFINS	:= nVlRetCOF
							SE2->E2_CSLL	:= nVlRetCSL
							MsUnlock()
							nSavRec 		:= SE2->( Recno() )

							//³ Exclui a Marca de "pendente recolhimento" dos demais registros   ³
							If aDadosRet[1] > 0
								aRecnos := aClone( aDadosRet[ 5 ] )

								cPrefOri  := SE2->E2_PREFIXO
								cNumOri   := SE2->E2_NUM
								cParcOri  := SE2->E2_PARCELA
								cTipoOri  := SE2->E2_TIPO
								cCfOri    := SE2->E2_FORNECE
								cLojaOri  := SE2->E2_LOJA

								For nLoop := 1 to Len( aRecnos )

									SE2->( dbGoto( aRecnos[ nLoop ] ) )

									RecLock("SE2", .F. )

									SE2->E2_PRETPIS := "2"
									SE2->E2_PRETCOF := "2"
									SE2->E2_PRETCSL := "2"

									SE2->( MsUnlock() )

									If nSavRec <> aRecnos[ nLoop ]
										dbSelectArea("SFQ")
										RecLock("SFQ",.T.)
										SFQ->FQ_FILIAL  := xFilial("SFQ")
										SFQ->FQ_ENTORI  := "SE2"
										SFQ->FQ_PREFORI := cPrefOri
										SFQ->FQ_NUMORI  := cNumOri
										SFQ->FQ_PARCORI := cParcOri
										SFQ->FQ_TIPOORI := cTipoOri
										SFQ->FQ_CFORI   := cCfOri
										SFQ->FQ_LOJAORI := cLojaOri

										SFQ->FQ_ENTDES  := "SE2"
										SFQ->FQ_PREFDES := SE2->E2_PREFIXO
										SFQ->FQ_NUMDES  := SE2->E2_NUM
										SFQ->FQ_PARCDES := SE2->E2_PARCELA
										SFQ->FQ_TIPODES := SE2->E2_TIPO
										SFQ->FQ_CFDES   := SE2->E2_FORNECE
										SFQ->FQ_LOJADES := SE2->E2_LOJA
										MsUnlock()
									Endif
								Next nLoop
							EndIf
							//³ Retorna do ponteiro do SE2 para a parcela         ³
							SE2->( MsGoto( nSavRec ) )
							Reclock("SE2", .F. )

						Else
							//³ Grava a Marca de "pendente recolhimento" dos demais registros    ³
							nRetOriPIS := nVlRetPis
							nRetOriCOF := nVlRetCOF
							nRetOriCSL := nVlRetCSL
							If nRetOriPIS + nRetOriCof + nRetOriCsl > 0
								Reclock("SE2", .F. )
								SE2->E2_PRETPIS := "1"
								SE2->E2_PRETCOF := "1"
								SE2->E2_PRETCSL := "1"
								SE2->( MsUnlock() )
							EndIf
							lRetParc := .F.
							lRestValImp := .T.
						EndIf

					Case cModRetPIS == "2"
						//³ Efetua a retencao                                                 ³
						nSavRec := SE2->( Recno() )

						//³ Exclui a Marca de "pendente recolhimento" dos demais registros   ³
						If aDadosRet[1] > 0
							aRecnos := aClone( aDadosRet[ 5 ] )

							cPrefOri  := SE2->E2_PREFIXO
							cNumOri   := SE2->E2_NUM
							cParcOri  := SE2->E2_PARCELA
							cTipoOri  := SE2->E2_TIPO
							cCfOri    := SE2->E2_FORNECE
							cLojaOri  := SE2->E2_LOJA

							For nLoop := 1 to Len( aRecnos )

								SE2->( dbGoto( aRecnos[ nLoop ] ) )

								RecLock("SE2", .F. )

								SE2->E2_PRETPIS := "2"
								SE2->E2_PRETCOF := "2"
								SE2->E2_PRETCSL := "2"

								SE2->( MsUnlock() )

								If nSavRec <> aRecnos[ nLoop ]
									dbSelectArea("SFQ")
									RecLock("SFQ",.T.)
									SFQ->FQ_FILIAL  := xFilial("SFQ")
									SFQ->FQ_ENTORI  := "SE2"
									SFQ->FQ_PREFORI := cPrefOri
									SFQ->FQ_NUMORI  := cNumOri
									SFQ->FQ_PARCORI := cParcOri
									SFQ->FQ_TIPOORI := cTipoOri
									SFQ->FQ_CFORI   := cCfOri
									SFQ->FQ_LOJAORI := cLojaOri

									SFQ->FQ_ENTDES  := "SE2"
									SFQ->FQ_PREFDES := SE2->E2_PREFIXO
									SFQ->FQ_NUMDES  := SE2->E2_NUM
									SFQ->FQ_PARCDES := SE2->E2_PARCELA
									SFQ->FQ_TIPODES := SE2->E2_TIPO
									SFQ->FQ_CFDES   := SE2->E2_FORNECE
									SFQ->FQ_LOJADES := SE2->E2_LOJA
									MsUnlock()
								EndIf
							Next nLoop
						EndIf
						//³ Retorna do ponteiro do SE1 para a parcela         ³
						SE2->( MsGoto( nSavRec ) )
						Reclock("SE2", .F. )

						lRetParc := .T.
					Case cModRetPIS == "3"
						//³ Grava a Marca de "pendente recolhimento" dos demais registros    ³
						nRetOriPIS := nVlRetPis
						nRetOriCOF := nVlRetCOF
						nRetOriCSL := nVlRetCSL
						If nRetOriPIS + nRetOriCof + nRetOriCsl > 0
							Reclock("SE2", .F. )
							SE2->E2_PRETPIS := "1"
							SE2->E2_PRETCOF := "1"
							SE2->E2_PRETCSL := "1"
							SE2->( MsUnlock() )
						EndIf
						lRetParc := .F.
						lRestValImp := .T.
				EndCase
			ElseIf lContrRet .and. lPccBaixa .and. !lPccBxPa
				Reclock("SE2", .F. )
				SE2->E2_PRETPIS := "1"
				SE2->E2_PRETCOF := "1"
				SE2->E2_PRETCSL := "1"
				SE2->( MsUnlock() )
			ElseIf lContrRet .and. lDigitado .and. !lPccBaixa
				//³ Restauro o valor principal do titulo						 ³
				//Controle de base de impostos
				If lBaseImp
					nVlPrinc := SE2->E2_BASEPIS
				Else
					nVlPrinc := M->E2_VALOR + nVlRetPis + nVlRetCOF + nVlRetCSL + M->E2_ISS + M->E2_IRRF + M->E2_INSS
				EndIf

				//PIS
				If SED->ED_CALCPIS == "S" .and. SA2->A2_RECPIS == "2"
					If ! GetNewPar("MV_RNDPIS",.F.)
						nCalcPis := NoRound((nVlPrinc * (SED->ED_PERCPIS / 100)),2)
					Else
						nCalcPis := Round((nVlPrinc * (SED->ED_PERCPIS / 100)),2)
					Endif
				EndIf

				// COFINS
				If SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI == "2"
					If ! GetNewPar("MV_RNDCOF",.F.)
						nCalcCof := NoRound((nVlPrinc * (SED->ED_PERCCOF / 100)),2)
					Else
						nCalcCof := Round((nVlPrinc * (SED->ED_PERCCOF / 100)),2)
					EndIf
				EndIf

				// CSLL
				If SED->ED_CALCCSL == "S" .and. SA2->A2_RECCSLL == "2"
					If ! GetNewPar("MV_RNDCSL",.F.)
						nCalcCsl := NoRound((nVlPrinc * (SED->ED_PERCCSL / 100)),2)
					Else
						nCalcCsl := Round((nVlPrinc * (SED->ED_PERCCSL / 100)),2)
					EndIf
				EndIf

				//³ Guarda os valores originais                           ³
				nRetOriPIS := nCalcPis
				nRetOriCOF := nCalcCof
				nRetOriCSL := nCalcCsl

				//³ Exclui a Marca de "pendente recolhimento" dos demais registros   ³
				If aDadosRet[1] > 0
					aRecnos := aClone( aDadosRet[ 5 ] )

					cPrefOri  := SE2->E2_PREFIXO
					cNumOri   := SE2->E2_NUM
					cParcOri  := SE2->E2_PARCELA
					cTipoOri  := SE2->E2_TIPO
					cCfOri    := SE2->E2_FORNECE
					cLojaOri  := SE2->E2_LOJA

					For nLoop := 1 to Len( aRecnos )

						SE2->( dbGoto( aRecnos[ nLoop ] ) )

						RecLock("SE2",.F.)

						SE2->E2_PRETPIS := "2"
						SE2->E2_PRETCOF := "2"
						SE2->E2_PRETCSL := "2"

						SE2->( MsUnlock() )

						If nSavRec <> aRecnos[ nLoop ]
							dbSelectArea("SFQ")
							RecLock("SFQ",.T.)
							SFQ->FQ_FILIAL  := xFilial("SFQ")
							SFQ->FQ_ENTORI  := "SE2"
							SFQ->FQ_PREFORI := cPrefOri
							SFQ->FQ_NUMORI  := cNumOri
							SFQ->FQ_PARCORI := cParcOri
							SFQ->FQ_TIPOORI := cTipoOri
							SFQ->FQ_CFORI   := cCfOri
							SFQ->FQ_LOJAORI := cLojaOri

							SFQ->FQ_ENTDES  := "SE2"
							SFQ->FQ_PREFDES := SE2->E2_PREFIXO
							SFQ->FQ_NUMDES  := SE2->E2_NUM
							SFQ->FQ_PARCDES := SE2->E2_PARCELA
							SFQ->FQ_TIPODES := SE2->E2_TIPO
							SFQ->FQ_CFDES   := SE2->E2_FORNECE
							SFQ->FQ_LOJADES := SE2->E2_LOJA
							MsUnlock()
						EndIf
					Next nLoop
				EndIf
				lRestValImp := .T.
				lAltValor   := .F.
				//³ Retorna do ponteiro do SE2 para a parcela         ³
				SE2->( MsGoto( nSavRec ) )
				RecLock("SE2",.F.)
			Else
				lRetParc := .T.
			EndIf
			If nRetOriPIS <> nVlRetPIS .and. !lPccBaixa
				lSisAltPIS := .T.
			EndIf

			If nRetOriCOF <> nVlRetCOF .and. !lPccBaixa
				lSisAltCOF := .T.
			EndIf

			If nRetOriCSL <> nVlRetCSL .and. !lPccBaixa
				lSisAltCSL := .T.
			EndIf
		EndIf

		SA2->(DbSeek(cFilial+SE2->E2_FORNECE+SE2->E2_LOJA))

		If !lEmprest
			//Gravar titulos de PCC
			a050DupPag(SE2->E2_ORIGEM,,,,lRetParc,,,,.T.,,,aMotRet,lPccMR,lIrfMR,lInsMR,lIssMR,lCidMR,lSestMR)
		Else
			//realiza a gravacao do model do titulo emprestimo
			If cPaisLoc=="BRA"
				Fa986grava("SE2","FINA050")
			EndIf
		EndIf
		If 	cPaisLoc $ "DOM|COS"  .And. !lF050Auto
			//Geração das Retenções de Impostos - Republica Dominicana
			//Function fa050CalcRet(cCarteira, cFatoGerador) //1-Contas a Pagar ou 3-Ambos e Fato Gerador 1-Emissao.
			fa050CalcRet("'1|3'", "2", SE2->E2_NATUREZ, SE2->E2_VALOR, SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_FORNECE)
		EndIf
		If lPccMR .Or. lIrfMR
			Reclock("SE2", .F.)
			If lPccMR
				If lPccBxMR
					SE2->E2_PRETPIS := "1"
					SE2->E2_PRETCOF := "1"
					SE2->E2_PRETCSL := "1"
				ElseIf Len(aMotRet) > 0
					If nX := Ascan(aMotRet, {|x| AllTrim(x[8]) == "PIS"})
						cPret := ""
						If aMotRet[nX,5] == 0
							cPret := "1"
						EndIf
						SE2->E2_PRETPIS := cPret
					EndIf
					If nX := Ascan(aMotRet, {|x| AllTrim(x[8]) == "COF"})
						cPret := ""
						If aMotRet[nX,5] == 0
							cPret := "1"
						EndIf
						SE2->E2_PRETCOF := cPret
					EndIf
					If nX := Ascan(aMotRet, {|x| AllTrim(x[8]) == "CSL"})
						cPret := ""
						If aMotRet[nX,5] == 0
							cPret := "1"
						EndIf
						SE2->E2_PRETCSL := cPret
					EndIf
				EndIf
			EndIf
			If lIrfMR
				If lIrfBxMR
					SE2->E2_PRETPIS := "1"
				ElseIf Len(aMotRet) > 0
					If nX := Ascan(aMotRet, {|x| AllTrim(x[8]) == "IRF"})
						cPret := ""
						If aMotRet[nX,5] == 0
							cPret := "1"
						EndIf
						SE2->E2_PRETIRF := cPret
					EndIf
				EndIf
			EndIf
			SE2->( MsUnlock() )
		EndIf
		nValSaldo 	:= SE2->E2_VALOR
		nMoedSE2 	:= SE2->E2_MOEDA
	EndIf
	If !lInsMR .And. lInssBx .And. cPaisLoc = "BRA" .And. SE2->E2_TIPO $ MVPAGANT .And. !lInsPub //Inss Baixa
		If nInss > 0.00
			cGeraDirf := SE2->E2_DIRF
			cCodRetIr := SE2->E2_CODRET

			aAreaSE2 := SE2->(GetArea())
			aAreaSA2 := SA2->(GetArea())

			//Grava titulos do imposto INSS na tabela SE2 e na tabela SFQ.
			FGrvINSS(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,"","",1,SED->(Recno()),SE2->(Recno()),SE2->E2_EMISSAO,dDataBase,SE2->E2_VENCREA,nInss,.F.,{},{},;
			cGeraDirf,cCodRetIr,lSpbInUse,cModSpb)

			SE2->(RestArea(aAreaSE2))
			SA2->(RestArea(aAreaSA2))

		Endif
	Endif

	//³ Atualiza Saldos do Fornecedor          	  ³
	If !lDesdobr
		dbSelectArea("SA2")
		dbGoto(nSavRecA2)
		SE2->(dbGoTo(nSavRec))
		If SE2->E2_TIPO $ MVABATIM
			Reclock("SA2" )
			SA2->A2_SALDUP -= SE2->E2_VLCRUZ
			SA2->A2_SALDUPM-= Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,nMoeda,SE2->E2_EMISSAO,3),3),2)
		EndIf
	Else
		//³ Atualiza datas de primeira e ultima compra ³
		SA2->(dbGoto(nSavRecA2))
		SE2->(dbGoTo(nSavRec))
		RecLock("SA2", .F. )
		SA2->A2_PRICOM  := Iif( SE2->E2_EMISSAO < SA2->A2_PRICOM .Or. Empty(SA2->A2_PRICOM), SE2->E2_EMISSAO, SA2->A2_PRICOM )
		SA2->A2_ULTCOM  := Iif( SA2->A2_ULTCOM  < SE2->E2_EMISSAO, SE2->E2_EMISSAO, SA2->A2_ULTCOM )
		SA2->( MsUnlock() )
	Endif
	//³ Ponto de entrada do FA050GRV, serve p/ tratar dados ³
	//³ ap¢s estarem gravados.                              ³
	IF lFA050GRV
		ExecBlock("FA050GRV",.f.,.f.)
	EndIf

	// Valores acessórios
	If cPaisLoc == "BRA"
		lVincVA := (Valtype(mv_par11) == "N" .AND. !Empty(mv_par11) .And. mv_par11 == 1)
		If !lDesdobr .And. ( lVincVA .Or. aVAAuto != NIL ) .And. __lFAPodeTVA .And. FAPodeTVA(SE2->E2_TIPO, /*cNatureza*/,.F.,"P")
			If lF050Auto
				If (aVAAuto != NIL)
					If !Fa050VA(.T.)
						lRet := .F.
					Endif
				Endif
			Else
				Fa050VA(.F.)
			Endif
		Endif
	Endif
Endif

If lRet
	//³ Rotina de contabiliza‡„o do titulo 					  ³
	dbSelectArea("SE2")
	dbGoto( nSavRec )

	// Verifica se esta utilizando multiplas naturezas
	If MV_MULNATP .And. SE2->E2_MULTNAT == "1"   .And. !SE2->E2_DESDOBR $ "1S"
		// Se o parametro que permite a exibicao da tela para digitacao
		// do rateio estiver ativo, concatena a rotina de digitacao de multiplas naturezas (MultNat2)
		If Type("lF050Auto") == "L" .And. lF050Auto .AND. SuperGetMv("MV_RATAUTO",,.F.)
			// Grava as multiplas naturezas (SEV e SEZ)
			MultNat(	"SE2" /*cAlias*/,;
			@nHdlPrv /*@nHdlPrv*/,;
			@nTotal /*@nTotal*/,;
			@cArquivo /*@cArquivo*/,;
			( mv_par04 == 1 ) /*lContabiliza*/,;
			/*nOpc*/,;
			If(	/*lExpr*/	mv_par06 == 1,;
			/*T*/	SE2->(	If( lIRPFBaixa, 0, E2_IRRF ) + If( !lCalcIssBx, E2_ISS, 0 ) +;
			E2_RETENC + E2_SEST +;
			If( lPccBaixa, 0, E2_PIS + E2_COFINS + E2_CSLL ) ) + nInss,;
			/*F*/	0 ) /*nImpostos*/,;
			mv_par10 = 2 .And. mv_par06 = 2 /*lRatImpostos*/,;
			/*aColsM*/,;
			/*aHeaderM*/,;
			/*aRegs*/,;
			/*lGrava*/,;
			/*lMostraTela*/,;
			/*lRotAuto*/,;
			lUsaFlag /*lUsaFlag*/,;
			@aFlagCTB /*@aFlagCTB*/ ) // Chama a rotina para distribuir o valor entre as naturezas
		Else
			If lf050auto .and. aRatEvEz <> Nil
				MultiAuto(@aColsSev,@aHeaderSev,"SE2","SEV")
			Endif
			If !GrvSevSez(cAlias,aColsSev,aHeaderSev,,;
				If(mv_par06 == 1,If(lIRPFBaixa,0,M->E2_IRRF)+If(!lCalcIssBx,M->E2_ISS,0)+nInss+IIF(lPccBaixa,0,M->E2_PIS+M->E2_COFINS+M->E2_CSLL)+;
				M->E2_RETENC+M->E2_SEST,0),(mv_par10 == 2 .And. mv_par06 = 2),"FINA050",mv_par04==1,@nHdlPrv,@nTotal,@cArquivo)

				lRet := .F.
			Endif
		Endif
		lHeader := nHdlPrv > 0
	Else
		If lAtuSldNat .And. !lDesdobr  .And. SE2->E2_FLUXO == 'S'
			AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, If(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"3","2"), "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM,"-","+"),,FunName(),"SE2",SE2->(Recno()),3)
		Endif
	Endif
Endif

If lRet
	//³PONTO DE ENTRADA - Apos gravar SEV e SEZ e antes de gravar lcto contabil³
	If lFA050CT
		ExecBlock("FA050CT",.F.,.F.)
	EndIf

	//³ Atualizacao dos dados do Modulo SIGAPMS    ³
	lPrimeiro := .F. //Wilson em 06/06/2011
	If IntePMS()
		PmsWriteFI(1,"SE2")
	Endif
	STRLCTPAD := " "
	cPadrao:=IIF(SE2->E2_RATEIO=="N","510","511")
	IF !E2_TIPO $ MVPROVIS .or. mv_par02 == 1
		If !lDesdobr   // Caso n„o seja titulo gerado por desdobramento
			IF E2_TIPO $ MVPAGANT .and. cPadrao <> "511"
				//³ O PA sera contabilizado com o Lanc Padrao da orden de pago.|
				//| (Localizacoes Argentina).                                  |
				cPadrao:=IIf(cPaisLoc $ "ARG|ANG|MEX|COL","ZZZZZ","513") //que nao faza o lancamento se e Um PA em argentina
				STRLCTPAD := cBancoAdt+"/"+cAgenciaAdt+"/"+cNumCon+"/"+cChequeAdt
			Endif
			lPadrao := VerPadrao(cPadrao)
            // VALIDA CONTABILIZAÇÃO DE PAGAMENTO ANTECIPADO
            If lCtMovPa .And. cPadrao == "513" // Nao contabilizar inclusao de PA sem Cheque e Movimento bancario.
                If MV_PAR05 == 2 .And. MV_PAR09 == 2
                    lPadrao := .F.
                EndIf
            EndIf
		EndIf

		// Adiciona o recno no array para a contabilização
		If  UsaSeqCor()
			aadd(aDiario, {"SE2", SE2->(recno()) , SE2->E2_DIACTB , "E2_NODIA","E2_DIACTB"} )
		Else
			aDiario := {}
		Endif

		IF ((lPadrao .Or. lDesdobr) .and. SE2->E2_LA != "S") .or. (SE2->E2_LA == "S" .and. lDesdobr)
			//³ Deve sempre mostrar a tela de rateio					  ³
			//³ Caso o titulo tenha sua origem num desdobramento    ³
			//³ n„o haver  possibilidade de Rateio.                 ³
			If cPadrao == "511" .And. !lDesdobr .And. !lRatDes
				If !CtbInUse()
					cArq := fa050rate( cPadrao , "FINA050","I",@nHdlPrv,@cArquivo)
					If !Empty(cArq)
						RecLock("SE2")
						Replace E2_ARQRAT 	With cArq
					EndIf
				Else
					// Contabiliza o rateio
					cSeq := Fa050GerLc( cPadrao,cLote, "FINA050", 3, @nHdlPrv, @nTotal, NIL, cProcPCO, cItemPCO, cRecPag )
					If !Empty(cSeq)
						RecLock("SE2")
						Replace E2_ARQRAT		With cSeq
					EndIf
				EndIf
			ElseIf mv_par04 == 1  // Contabiliza On-Line
				//³ Se houve desdobramento, n„o rodo o HeadProva nem o  ³
				//³ DetProva, pois j  foram feitos na gravacao dos titu-³
				//³ los gerados pelo desdobramento.                     ³
				If E2_TIPO $ MVPAGANT
					SA6->( dbSeek(xFilial("SA6")+cBancoAdt+cAgenciaAdt+cNumCon) )
				Endif
				If !lDesdobr

					If SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
						Fa050GerPa(cBancoCx,lPadrao,lPccMR,lIrfMR,lInsMR,lIssMR,lCidMR,lSestMR)
					Endif

					If SE2->E2_MULTNAT == "1"
						SEV->(DbGoto(0)) // Desposiciona SEV para contabilizar as demais sequencias do LP 510
						SEZ->(DbGoto(0)) // Desposiciona SEZ para contabilizar as demais sequencias do LP 510
					Endif

					If nHdlPrv <= 0
						//³ Inicializa Lancamento Contabil                                   ³
						nHdlPrv := HeadProva( cLote,;
						"FINA050" /*cPrograma*/,;
						Substr(cUsuario,7,6),;
						@cArquivo )
					Endif

					//Atribui valor as variáveis de contab. motor de retenção
					If nHdlPrv != 0 .And. Len(aMotRet) > 0
						FinCarVarE(aMotRet)
					EndIf

					//³ Prepara Lancamento Contabil                                      ³
					If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
						aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
					Endif
					nTotal += DetProva( nHdlPrv,;
					cPadrao,;
					"FINA050" /*cPrograma*/,;
					cLote,;
					/*nLinha*/,;
					/*lExecuta*/,;
					/*cCriterio*/,;
					/*lRateio*/,;
					/*cChaveBusca*/,;
					/*aCT5*/,;
					/*lPosiciona*/,;
					@aFlagCTB,;
					/*aTabRecOri*/,;
					/*aDadosProva*/ )
				Endif
				If nTotal > 0
					//-- Se for rotina automatica força exibir mensagens na tela, pois mesmo quando não exibe os lançamentos, a tela
					//-- sera exibida caso ocorram erros nos lançamentos padronizados
					If lF050Auto
						lSetAuto := _SetAutoMode(.F.)
						lSetHelp := HelpInDark(.F.)
						If Type('lMSHelpAuto') == 'L'
							lMSHelpAuto := !lMSHelpAuto
						EndIf
					EndIf

					//³ Envia para Lan‡amento Cont bil                      ³
					RodaProva( nHdlPrv,;
					nTotal )

					cA100Incl( cArquivo,;
					nHdlPrv,;
					3 /*nOpcx*/,;
					cLote,;
					( mv_par01 == 1 ) /*lDigita*/,;
					( mv_par07 == 1 ) /*lAglut*/,;
					/*cOnLine*/,;
					/*dData*/,;
					/*dReproc*/,;
					@aFlagCTB,;
					/*aDadosProva*/,;
					aDiario )
					aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento

					If lF050Auto
						HelpInDark(lSetHelp)
						_SetAutoMode(lSetAuto)
						If Type('lMSHelpAuto') == 'L'
							lMSHelpAuto := !lMSHelpAuto
						Endif
					EndIf

					If !lUsaFlag .Or. lDesdobr
						dbSelectArea("SE2")
						//³ Atualiza flag de Lan‡amento Cont bil		  ³
						Reclock("SE2")
						Replace E2_LA With "S"
						SE2->( MsUnlock() )
					EndIf
				Endif
			EndIf
			If !lDesdobr .and. !SE2->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+"SES"
				//³ Atualiza flag de Lan‡amento Cont bil dos titulos de impostos, para nao ³
				//³ duplicar o lancamento na contabilizacao off-line, pois os valores      ³
				//³ destes impostos estao disponiveis no mesmo registro do titulo principal³
				dbSelectArea("SE2")
				nRecCtb := Recno()
				aTps := {"TX ","INS","ISS","SES"}
				aParc := {SE2->E2_PARCIR,SE2->E2_PARCINS,SE2->E2_PARCISS,SE2->E2_PARCSES}
				Aadd(aParc, SE2->E2_PARCPIS)
				Aadd(aParc, SE2->E2_PARCCOF)
				Aadd(aParc, SE2->E2_PARCSLL)
				Aadd(aTps , "TX ")
				Aadd(aTps , "TX ")
				Aadd(aTps , "TX ") // aTps deve ter o mesmo tamanho de aParc
				For nX := 1 to Len(aTps)
					If Dbseek(xFilial("SE2")+SE2->E2_PREFIXO+SE2->E2_NUM+aParc[nX]+aTps[nX])
						Reclock("SE2")
						Replace E2_LA With "S"
					Endif
					dbGoto(nRecCtb)
				Next
			EndIf
		EndIf
	Else
		// Gera LP 511 somente quando NAO FOI EFETUADO DESDOBRAMENTO, caso contrario o LP ja foi gerado no desdobramento
		If cPadrao == "511" .And. CtbInUse()  .And. SE2->E2_DESDOBR != "S"
			// Contabiliza o rateio
			cSeq := Fa050GerLc( cPadrao,cLote, "FINA050", 3, @nHdlPrv, @nTotal, NIL, cProcPCO, cItemPCO, cRecPag )
			If !Empty(cSeq)
				RecLock("SE2")
				Replace E2_ARQRAT		With cSeq
			EndIf
		Endif
	Endif

	If !lPccMR .And. lContrRet .and. lRestValImp
		//³ Restaura os valores originais de PIS / COFINS / CSLL  ³
		RecLock( "SE2", .F. )
		If M->E2_PIS == 0 .or. lSisAltPIS
			SE2->E2_PIS    := If (!Empty(nRetOriPIS),nRetOriPIS,SE2->E2_PIS)
		ElseIf lDigitado .And. aDadosRet[2] > 0
			SE2->E2_PIS    -= If(nRetOriPIS < SE2->E2_PIS   ,nRetOriPIS,0)
		EndIf
		If M->E2_COFINS == 0 .or. lSisAltCOF
			SE2->E2_COFINS := If (!Empty(nRetOriCOF),nRetOriCOF,SE2->E2_COFINS)
		ElseIf lDigitado .And. aDadosRet[3] > 0
			SE2->E2_COFINS -= If(nRetOriCOF < SE2->E2_COFINS,nRetOriCOF,0)
		EndIf
		If M->E2_CSLL == 0 .or. lSisAltCSL
			SE2->E2_CSLL   := If (!Empty(nRetOriCSL),nRetOriCSL,SE2->E2_CSLL)
		ElseIf lDigitado .And. aDadosRet[4] > 0
			SE2->E2_CSLL   -= If(nRetOriCSL < SE2->E2_CSLL  ,nRetOriCSL,0)
		EndIf
		SE2->E2_VLCRUZ := Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,MsDecimais(1)+1,SE2->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
	EndIf
	If SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG .and. ((!lPadrao .and. mv_par04==1) .or.  mv_par04==2 .or. (lPadrao .and. cPadrao == "511" .And. !lDesdobr) )
		Fa050GerPa(cBancoCx,,lPccMR,lIrfMR,lInsMR,lIssMR,lCidMR,lSestMR)
	Endif
	If cPaisLoc $ "ARG|ANG|MEX|COL" .and. SE2->E2_TIPO $ MVPAGANT
		//³ Se for PA, gera Ordem de pagamento.   	  ³
		DbSelectArea("SX5")
		DbSeek(xFilial("SX5")+"99"+"ORDPAG")
		If Found()
			cOrdPago :=	STRZERO(VAL(ALLTRIM(X5_DESCRI))+1,6)
			RecLock("SX5",.F.)
			REPLACE X5_DESCRI	WITH	cOrdPago
			MsUnlock()
		Else
			cOrdPago	:=	"000001"
			RecLock("SX5",.T.)
			X5_FILIAL 	:=	XfILIAL("SX5")
			X5_TABELA	:=	"99"
			X5_CHAVE	:=	"ORDPAG"
			REPLACE X5_DESCRI With StrZero(Val(cOrdPago),6)
			MsUnlock()
		EndIf

		If GetMv("MV_LIBCHEQ") == "S".And. ;
			(Subs(cBancoAdt,1,2)=="CX" .or. cBancoAdt $ cBancoCx )
				aAreaAnt := GetArea()
				oModel := FWLoadModel('FINM030')//Movimento Bancario
				oModel:SetOperation( 4 ) //Alteração
				oModel:Activate()
				oModel:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5

				oSubFKA := oModel:GetModel( "FKADETAIL" )
				oSubFKA:SeekLine( 	{ {"FKA_IDORIG", SE5->E5_IDORIG } } )

				//Dados do movimento
				oSubFK5 := oModel:GetModel( "FK5DETAIL" )
				oSubFK5:SetValue( "FK5_ORDREC", cOrdPago )

				If oModel:VldData()
					oModel:CommitData()
					oModel:DeActivate()
				Else
					cLog := cValToChar(oModel:GetErrorMessage()[4]) + ' - '
					cLog += cValToChar(oModel:GetErrorMessage()[5]) + ' - '
					cLog += cValToChar(oModel:GetErrorMessage()[6])

					If (Type("lF050Auto") == "L" .and. lF050Auto)
						Help( ,,"M050VALID",,cLog, 1, 0 )
					Endif
					lRet := .F.
				Endif
			Restarea(aAreaAnt)
		Endif

		If lRet
			RecLock("SEK",.T.)
			SEK->EK_FILIAL	:= xFilial("SEK")
			SEK->EK_TIPODOC := "PA" //CHEQUE PROPRIO
			SEK->EK_NUM     := SE2->E2_NUM
			SEK->EK_TIPO    := "PA"
			SEK->EK_FORNECE := SE2->E2_FORNECE
			SEK->EK_LOJA	:= SE2->E2_LOJA
			SEK->EK_EMISSAO := dDataBase
			SEK->EK_VENCTO  := dDatabase
			SEK->EK_VALOR   := SE2->E2_VALOR
			SEK->EK_SALDO   := SE2->E2_VALOR
			SEK->EK_VLMOED1 := SE2->E2_VLCRUZ
			SEK->EK_MOEDA	:= STRZERO(SE2->E2_MOEDA,2)
			SEK->EK_ORDPAGO := cOrdpago
			SEK->EK_DTDIGIT := dDataBase
			MSUNLOCK()

			RecLock("SE2",.T.)
			SE2->E2_FILIAL 	:= cFilial
			SE2->E2_BCOCHQ	:= cBancoAdt
			SE2->E2_AGECHQ	:= cAgenciaAdt
			SE2->E2_CTACHQ	:= cNumCon
			SE2->E2_NUM		:= cChequeAdt
			SE2->E2_EMISSAO	:=	If(SubStr(cBancoAdt,1,2) != "CX" .and. !(cBancoAdt$cBancoCx),SEF->EF_DATA,SE5->E5_DATA)
			SE2->E2_VENCTO 	:=	If(SubStr(cBancoAdt,1,2) != "CX" .and. !(cBancoAdt$cBancoCx),SEF->EF_VENCTO,SE5->E5_DTDISPO)
			SE2->E2_VENCREA	:=	DataValida(If(SubStr(cBancoAdt,1,2) != "CX" .and. !(cBancoAdt$cBancoCx),SEF->EF_VENCTO,SE5->E5_VENCTO))
			SE2->E2_VALOR	:= If(SubStr(cBancoAdt,1,2) != "CX" .and. !(cBancoAdt$cBancoCx),SEF->EF_VALOR,SE5->E5_VLMOED2)
			SE2->E2_SALDO	:= If(SubStr(cBancoAdt,1,2) != "CX" .and. !(cBancoAdt$cBancoCx),SEF->EF_VALOR,SE5->E5_VLMOED2)
			SE2->E2_NATUREZ	:= SA2->A2_NATUREZ
			SE2->E2_TIPO	:= "CH"
			SE2->E2_LA		:= "S"
			SE2->E2_NOMFOR  := iif(Empty(cBenef),SEF->EF_BENEF,SA2->A2_NOME)
			SE2->E2_PREFIXO	:= If(SubStr(cBancoAdt,1,2) != "CX" .and. !(cBancoAdt$cBancoCx),SEF->EF_PREFIXO,SE5->E5_PREFIXO)
			SE2->E2_FORNECE := If(SubStr(cBancoAdt,1,2) != "CX" .and. !(cBancoAdt$cBancoCx),SEF->EF_FORNECE,SE5->E5_CLIFOR)
			SE2->E2_LOJA	:= If(SubStr(cBancoAdt,1,2) != "CX" .and. !(cBancoAdt$cBancoCx),SEF->EF_LOJA,SE5->E5_LOJA)
			SE2->E2_EMIS1	:= dDataEmis1
			SE2->E2_VLCRUZ 	:= Round(NoRound(xMoeda(If(SubStr(cBancoAdt,1,2) != "CX" .and. !(cBancoAdt$cBancoCx),SEF->EF_VALOR,SE5->E5_VLMOED2),nMoedSE2,1,DdATABASE,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))
			SE2->E2_MOEDA	:=	nMoedSE2
			MsUnLock()

			RecLock("SEK",.T.)
			SEK->EK_FILIAL	:= cFilial
			SEK->EK_TIPODOC := "CP" //CHEQUE PROPRIO
			SEK->EK_PREFIXO := SE2->E2_PREFIXO
			SEK->EK_NUM     := cChequeAdt
			SEK->EK_TIPO    := "CH"
			SEK->EK_FORNECE := SE2->E2_FORNECE
			SEK->EK_LOJA	:= SE2->E2_LOJA
			SEK->EK_EMISSAO := dDataBase
			SEK->EK_VENCTO  := dDatabase
			SEK->EK_VALOR   := SE2->E2_VALOR
			SEK->EK_SALDO   := SE2->E2_VALOR
			SEK->EK_VLMOED1 := SE2->E2_VLCRUZ
			SEK->EK_MOEDA	:= STRZERO(SE2->E2_MOEDA,2)
			SEK->EK_BANCO   := cBancoAdt
			SEK->EK_AGENCIA := cAgenciaAdt
			SEK->EK_CONTA   := cNumCon
			SEK->EK_ORDPAGO := cOrdpago
			SEK->EK_DTDIGIT := dDataBase
			MsUnlock()
			cPadrao:="570"
			lPadrao:=VerPadrao(cPadrao)
			If lPadrao .and. mv_par04 == 1 // Contabiliza On-Line
				IF !lHeader
					//³ Inicializa Lancamento Contabil                                   ³
					nHdlPrv := HeadProva( cLote,;
					"FINA050" /*cPrograma*/,;
					Substr(cUsuario,7,6),;
					@cArquivo )
					lHeader := .T.
				Endif
				SEK->(DbSetOrder(1))
				SEK->(DbSeek(xFilial("SEK")+cOrdPago,.T.))
				While !SEK->(EOF()).And.SEK->EK_ORDPAGO==cOrdPago
					If ( SEK->EK_TIPODOC=="CP" )
						SA6->(DbsetOrder(1))
						SA6->(DbSeek(xFilial("SA6")+SEK->EK_BANCO+SEK->EK_AGENCIA+SEK->EK_CONTA,.F.))
					Endif

					//³ Prepara Lancamento Contabil                                      ³
					If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
						aAdd( aFlagCTB, {"EK_LA", "S", "SEK", SEK->( Recno() ), 0, 0, 0} )
					EndIf
					nTotal += DetProva( nHdlPrv,;
					"570" /*cPadrao*/,;
					"FINA050" /*cPrograma*/,;
					cLote,;
					/*nLinha*/,;
					/*lExecuta*/,;
					/*cCriterio*/,;
					/*lRateio*/,;
					/*cChaveBusca*/,;
					/*aCT5*/,;
					/*lPosiciona*/,;
					@aFlagCTB,;
					/*aTabRecOri*/,;
					/*aDadosProva*/ )

					If !lUsaFlag
						RecLock("SEK",.F.)
						Replace EK_LA With "S"
						MsUnLock()
					EndIf

					SEK->(DbSkip())
				Enddo
				// Adiciona o recno no array para a contabilização
				If  UsaSeqCor()
					aadd(aDiario, {"SE2", SE2->(recno()) , SE2->E2_DIACTB , "E2_NODIA","E2_DIACTB"} )
				Else
					aDiario := {}
				EndIf
				//³ Envia para Lan‡amento Cont bil                      ³
				RodaProva( nHdlPrv,;
				nTotal )

				cA100Incl( cArquivo,;
				nHdlPrv,;
				3 /*nOpcx*/,;
				cLote,;
				( mv_par01 == 1 ) /*lDigita*/,;
				( mv_par07 == 1 ) /*lAglut*/,;
				/*cOnLine*/,;
				/*dData*/,;
				/*dReproc*/,;
				@aFlagCTB,;
				/*aDadosProva*/,;
				aDiario )
				aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento
			EndIf
		Endif
	EndIf

	If lRet
		//³ Ponto de entrada do FA050FIN, serve p/ tratar dados ³
		//³ antes de sair da rotina.                            ³
		IF lFA050FIN
			ExecBlock("FA050FIN",.f.,.f.)
		Endif

		//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
		//³ Grava os lancamentos nas contas orcamentarias quando nao eh desdobramento - SIGAPCO  ³
		If !lDesdobr .And. SE2->E2_MULTNAT # "1"
			If SE2->E2_TIPO $ MVPAGANT
				PcoDetLan("000002","02","FINA050")	// Tipo PA
			Else
				PcoDetLan("000002","01","FINA050")
			EndIf
		EndIf

		// Verifica o arquivo de rateio, e apaga o arquivo temporario
		// para que no proximo rateio seja criado novamente
		If cPaisLoc == 'BRA' .And. !lRatDes
			If Select("TMP") > 0
				DbSelectArea( "TMP" )
				DbCloseArea()
			EndIf
			If(_oFINA0501 <> NIL)
				_oFINA0501:Delete()
				_oFINA0501 := NIL
			EndIf
		EndIf

		cBancoAdt	:= CriaVar("A6_COD")
		cAgenciaAdt := CriaVar("A6_AGENCIA")
		cNumCon		:= CriaVar("A6_NUMCON")
		cChequeAdt	:= CriaVar("EF_NUM")
		cHistor		:= CriaVar("EF_HIST")
		cBenef		:= CriaVar("EF_BENEF")

		// Adiciona botao para envio de instrucoes de cobranca
		F050GrvFI2()

		// Restaura filial caso a importacao MILE tenha gestao corporativa
		If lMile .And. cFilAnt <> cFilAux
			cFilAnt := cFilAux
		EndIf
		dbSelectArea(cAlias)
		dbSetOrder(nIndex)

		If nSavRec >0
			dbGoto(nSavRec)
		Endif

		If lNRastDSD .and. SE2->E2_DESDOBR == 'S'
			If !IsBlind()
				oMBrowse:Refresh()
			EndIf
			SE2->(DbGoto(nSavRec + 1))
		EndIf

		// Integração com o SigaPfs
		If lIntPFS
			If !F050AtuPFS(3, nSavRec, SE5->(Recno()))
				lRet := .F.
			EndIf
		Endif
	Endif
Endif

If !lRet
	DisarmTransaction()
Endif

Return  /*Function FA050AxInc*/

/*
±±ºPrograma  ³FA050AXALTºAutor  ³Mauricio Pequim Jr  º Data ³  04/08/99   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Fun‡ao para complementacao da Alteracao de C.Pagar          º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³FA050AxAlt(ExpC1)                                           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³xpC1 = Alias do arquivo                                     º±±
*/
Function FA050AxAlt(cAlias)
Local lResult		:= .T.
LOCAL dVencRea
LOCAL dVenIss
LOCAL nValorIss		:= 0
LOCAL cNum 			:= E2_NUM
LOCAL cPrefixo 		:= E2_PREFIXO
LOCAL nValorIr  	:= 0
LOCAL nValInss  	:= 0
LOCAL nValSEST    	:= 0
Local cTipoSE2		:= SE2->E2_TIPO
Local cModSpb		:= "1"
Local lSpbInUse		:= SpbInUse()
LOCAL nTotal		:= 0
LOCAL nHdlPrv		:= 0
Local cArquivo		:= ""
Local nTamParc  	:= TamSx3("E2_PARCELA")[1]
Local lAltLib		:= .T.
Local dVctoReal		:= SE2->E2_VENCREA
Local dEmissao		:= SE2->E2_EMISSAO
Local dEmis1		:= SE2->E2_EMIS1
Local nValPis
Local nValCofins
Local nValCsll
Local cParcPis
Local cParcCof
Local cParcCsll
Local nX := 0
Local cGeraDirf := Iif(cPaisLoc == 'BRA',SE2->E2_DIRF," ")
Local cCodRetIr := Iif(cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN",SE2->E2_CODRET," ")
Local cCodRetPis := ""
Local cCodRetCof := ""
Local cCodRetCsl := ""
Local cChavePIS := ""
Local cChaveCOF := ""
Local cChaveCSL := ""
Local cChaveIrf := ""
Local cChaveInss := ""
Local cChaveIss := ""
Local cCIDE  := GetMv("MV_CIDE",,"")
Local nRegSe2	 := SE2->(RecNo())
Local cUniao	 := GetMv("MV_UNIAO")
Local cForInss	 := GetMv("MV_FORINSS")
Local aRecnos := {}
Local nLoop := 0
Local nSobra := 0
Local nValorTit := 0
Local nRetOriPIS := 0
Local nRetOriCOF := 0
Local nRetOriCSL := 0
Local nVlMinImp := GetNewPar("MV_VL10925",5000)
Local nFatorRed := 0
Local lRestValImp := .F.
Local lRetParc := .T.
Local lContrRet := .T.

Local lCodRtPCC := cPaisLoc == "BRA"

Local nInss     := SE2->E2_INSS
Local cPrefOri  := SE2->E2_PREFIXO
Local cNumOri   := SE2->E2_NUM
Local cParcOri  := SE2->E2_PARCELA
Local cTipoOri  := SE2->E2_TIPO
Local cCfOri    := SE2->E2_FORNECE
Local cLojaOri  := SE2->E2_LOJA
Local lZerouImp := .F.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

//1-Cria NCC/NDF referente a diferenca de impostos entre emitidos (SE2) e retidos (SE5)
//2-Nao Cria NCC/NDF, ou seja, controla a diferenca num proximo titulo
//3-Nao Controla
Local cNccRet  := SuperGetMv("MV_NCCRET",.F.,"1")
Local lIRPFBaixa := .F.
Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local lVenctoIN  	:= (SuperGetMv("MV_VENCINS",.T.,"1") == "2")  //1 = Emissao    2= Vencimento Real
Local nDia			:= 0
Local cTipoFor 		:= ""
//Como a variavel cTipoFor eh destinada mais especificamente ao calculo de IRRF (pelo campo A2_IRPROG) utilizar outra para outros impostos como o INSS
Local cTipoFor02	:= ""
//Verifica se os campos utilizados para o imposto CIDE.
Local lCIDE  := cPaisLoc == "BRA"
Local nRegSeD := SED->(RecNo())
Local aTpImp := {}
Local aFlagCTB := {}
Local lUsaFlag	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
Local dDataIni  := firstDay( dOldVencRe )
Local dDataFim  := LastDay( dOldVencRe )
Local cTitPai   := Rtrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)) //E2_TITPAI
Local cCodAprov := SE2->E2_CODAPRO
Local cLojaImp  := PadR( "00", TamSX3( "A2_LOJA" )[1], "0" )

Local aAreaSed  := {}
Local aAreaSa2  := {}
Local dVencto
Local cKeySe2
Local cFornLoja
Local lVerMinIss	:=	.T. //Verifica se o valor calculado para ISS esta dentro do valor minimo.
Local cForMinISS	:=	GetNewPar("MV_FMINISS","1")
Local lGravRegIss	:=	.T. //Libera registro de ISS para ser gravado.
Local lVcAntIss 	:= (SuperGetMV("MV_ANTVISS",.T.,"2") == "1")  //Antecipa ou nao o vencimento do ISS em caso de vencimento em dia nao util
Local lEmpPub		:= IsEmpPub()
Local lF050IRF 		:= ExistBlock("F050IRF")
Local lF050ISS 		:= ExistBlock("F050ISS")
Local lF050SES		:= ExistBlock("F050SES")

Local lAtuSldNat := .T.

Local lTitReteu := .F.
Local lRatAutPrj	:=Type("LF050AUTO") =="L" .and. lF050Auto .and. Type("aAutoAFR") # "U" .and. !Empty (aAutoAFR)//rateio automatico de projetos

Local cForSEST := PadR( GetMv("MV_FORSEST",,""), Len( SE2->E2_FORNECE ) )

Local  lRetOutMod := F050TitRet()

Local cRetIns	:= M->E2_RETINS
Local lInssBX :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
Local cTpTaxa := Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG, MVTXA, MVTAXA)
Local nTotImp := 0
Local lRndSest  := SuperGetMv("MV_RNDSEST",.F.,.F.)
Local aISSMun	:= {}
Local aImpos    := aClone(aVetImp)

//Contabilização do Rateio
Local cProcPCO		:= "000021"
Local cItemPCO		:= "01"
Local cRecPag 		:= "P"
Local cPadrao 		:= "511"
Local lPadrao 		:= verPadrao(cPadrao)
Local cSeq				:= ""

lIntegracao := IF(GetMV("MV_EASYFIN")=="S",.T.,.F.)
PRIVATE bPMSDlgFI	:= {||PmsDlgFI(4,M->E2_PREFIXO,M->E2_NUM,M->E2_PARCELA,M->E2_TIPO,M->E2_FORNECE,M->E2_LOJA,.F.)}

// Guarda conteudo do Gera Dirf *
cDirfAlt := M->E2_DIRF

// Caso nao exista os tres impostos, o codigo de retencao sera diferenciado para cada imposto
If cAlias == "SE2"
	If (SE2->E2_PIS > 0 .or. !Empty(SE2->E2_PARCPIS))
		cChavePIS := SE2->(E2_PREFIXO+E2_NUM+E2_PARCPIS) + cTpTaxa
	EndIf

	If (SE2->E2_COFINS > 0 .or. !Empty(SE2->E2_PARCCOF))
		cChaveCOF := SE2->(E2_PREFIXO+E2_NUM+E2_PARCCOF) + cTpTaxa
	EndIf

	If (SE2->E2_CSLL > 0 .or. !Empty(SE2->E2_PARCSLL))
		cChaveCSL	:= SE2->(E2_PREFIXO+E2_NUM+E2_PARCSLL) + cTpTaxa
	EndIf

	If (SE2->E2_IRRF > 0 .or. !Empty(SE2->E2_PARCIR))
		cChaveIrf	:= SE2->(E2_PREFIXO+E2_NUM+E2_PARCIR) + cTpTaxa
	EndIf

	If (SE2->E2_INSS > 0 .OR. !Empty(SE2->E2_PARCINS))
		cChaveInss	:= SE2->(E2_PREFIXO+E2_NUM+E2_PARCINS) + cTpTaxa
	EndIf
EndIf

If	(SE2->E2_PIS <= 0 .Or. SE2->E2_COFINS <= 0 .Or. SE2->E2_CSLL <= 0 )
	cCodRetPis := If (lCodRtPCC .and. !Empty(SE2->E2_CODRPIS),SE2->E2_CODRPIS,"5979")
	cCodRetCof := If (lCodRtPCC .and. !Empty(SE2->E2_CODRCOF),SE2->E2_CODRCOF,"5960")
	cCodRetCsl := If (lCodRtPCC .and. !Empty(SE2->E2_CODRCSL),SE2->E2_CODRCSL,"5987")
	If lFINCDRET
		aCRets :=ExecBlock("FINCDRET")
		If aScan(aCRets,cCodRetIr) > 0
			cCodRetPis := cCodRetCof := cCodRetCsl := cCodRetIr
		EndIf
	End
Else
	// Se os 3 impostos juntos for maior que a media de retencao, o codigo sera o mesmo
	// para os tres.
	If SE2->(E2_PIS+E2_COFINS+E2_CSLL) > ((GetMv("MV_VRETPIS")+GetMv("MV_VRETCOF")+GetMv("MV_VRETCSL")) / 3)
		cCodRetPis := If (lCodRtPCC .and. !Empty(SE2->E2_CODRPIS),SE2->E2_CODRPIS,"5952")
		cCodRetCof := If (lCodRtPCC .and. !Empty(SE2->E2_CODRCOF),SE2->E2_CODRCOF,"5952")
		cCodRetCsl := If (lCodRtPCC .and. !Empty(SE2->E2_CODRCSL),SE2->E2_CODRCSL,"5952")
		If lFINCDRET
			aCRets :=ExecBlock("FINCDRET")
			If aScan(aCRets,cCodRetIr) > 0
				cCodRetPis := cCodRetCof := cCodRetCsl := cCodRetIr
			EndIf
		End
	EndIf
Endif

If !lInsMR .And. !lInssBx
	IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
		nInss := 0
	Endif
Endif

SA2->(dbSetOrder(1))
SA2->(MSSeek(xFilial("SA2")+SE2->(E2_FORNECE+E2_LOJA)))

lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)

// Verifica se esta utilizando multiplas naturezas
If MV_MULNATP .And. M->E2_MULTNAT == "1" .And.;
	((SE2->E2_VALOR != nValorAnt 	.Or. SE2->E2_IRRF != nOldIRRF	.Or.;
	SE2->E2_ISS != nOldISSInt	.Or. SE2->E2_INSS != nOldIns .Or.;
	SE2->E2_PIS != nOldPisAnt	.Or. SE2->E2_COFINS != nOldCofAnt .Or. ;
	SE2->E2_CSLL != nOldCslAnt) .Or. Len(aCols) > 0)

	If mv_par06 == 1
		nTotImp := If(lIRPFBaixa, 0, M->E2_IRRF)
		nTotImp += If(lCalcIssBx, 0, M->E2_ISS + If(lBtrISS,M->E2_BTRISS,0))
		nTotImp += If(lPccBaixa, 0, M->E2_PIS + M->E2_COFINS + M->E2_CSLL )
		nTotImp += M->E2_RETENC + M->E2_SEST + nInss
	Else
		nTotImp := 0
	EndIf

	MultNat("SE2" /*cAlias*/, @nHdlPrv, @nTotal, @cArquivo, (mv_par04 == 1) /*lContabiliza*/, 4 /*nOpc*/,  nTotImp /*nImpostos*/, (mv_par10 = 2 .And. mv_par06 = 2) /*lRatImpostos*/,;
	aHeader /*aCols*/, aCols /*aHeader*/, aRegs /*aRegs*/, .T. /*lGrava*/, .F. /*lMostraTela*/, nil /*lRotAuto*/,;
	lUsaFlag /*lUsaFlag*/, @aFlagCTB /*@aFlagCTB*/ ) // Chama a rotina para distribuir o valor entre as naturezas

	If nTotal > 0
		lDigita := IIF( mv_par01 == 1, .T., .F. )

		If  UsaSeqCor()
			aDiario := {}
			aDiario := {{"SE2",SE2->(recno()),SE2->E2_DIACTB,"E2_NODIA","E2_DIACTB"}}
		Else
			aDiario := {}
		EndIf

		//Envia para Lan‡amento Cont bil - Alteracao Multi
		RodaProva( nHdlPrv, nTotal )
		cA100Incl( cArquivo, nHdlPrv, 3/*nOpcx*/,cLote, lDigita, ( mv_par07 == 1 ) /*lAglut*/, /*cOnLine*/, /*dData*/, /*dReproc*/, @aFlagCTB, /*aDadosProva*/, aDiario )
		aFlagCTB := {}//Limpa o coteudo apos a efetivacao do lancamento
	EndIf
Else
	If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
		// Tiro o valor da natureza antiga
		AtuSldNat(cOldNaturez, dOldVencRe, SE2->E2_MOEDA, If(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"3","2"), "P", nOldSaldo, nOldVlCruz, If(SE2->E2_TIPO $ MVABATIM, "+","-"),,FunName(),"SE2",SE2->(Recno()),4)
		// Somo o valor na nova natureza
		AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, If(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"3","2"), "P", M->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM, "-","+"),,FunName(),"SE2", SE2->(Recno()), 4)
	Endif
	//Se a data do titulo principal foi alterada, os venctos dos abatimentos devem ser alterados
	If dOldVencRe != SE2->E2_VENCTO .OR. dOldVencRe != SE2->E2_VENCREA
		dVencto 	 := SE2->E2_VENCTO
		dVencRea  := SE2->E2_VENCREA
		cKeySe2 	 := SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA)
		cFornLoja := SE2->(E2_FORNECE+E2_LOJA)
		If SE2->(MsSeek(xFilial("SE2")+cKeySE2))
			While SE2->(!Eof()) .And. cKeySe2 == SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA)
				If SE2->(E2_FORNECE + E2_LOJA ) == cFornLoja .And.;
				SE2->E2_TIPO $ MVABATIM
					If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
						// Tiro o valor da natureza antiga
						AtuSldNat(cOldNaturez, dOldVencRe, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ,"+",,FunName(),"SE2",SE2->(Recno()),4)
					Endif
					Reclock("SE2", .F. )
					SE2->E2_VENCTO  := dVencto
					SE2->E2_VENCREA := dVencRea
					MsUnlock()
					If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
						// Somo o valor na nova natureza
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),4)
					Endif
				EndIf
				SE2->(dbSkip())
			Enddo
		Endif
		SE2->(MsGoto(nRegSe2))
	Endif
EndIf

Reclock("SE2")
If (SE2->E2_ACRESC != nOldVlAcres)
	Replace E2_SDACRES With E2_ACRESC
Endif
If (SE2->E2_DECRESC != nOldVlDecres)
	Replace E2_SDDECRE With E2_DECRESC
EndIf


//Permissao para alterar titulos liberados para pagamento
If GETMV("MV_CTLIPAG")
	lAltLib := (SuperGetMv("MV_ALTLIPG",.F.,"S") == "S")
	//Se nao permite a alteracao verifico a liberacao.
	//Se parametrizado para que titulo alterado volte para a liberacao de pagamentos
	// Limpo a data de liberacao
	If lAltLib .and. !Empty(SE2->E2_DATALIB) .and. SuperGetMv("MV_CANLIPG",.F.,"N") == "S"
		RecLock("SE2")
		SE2->E2_DATALIB := CTOD("//")
		SE2->E2_STATLIB := "01"
		MsUnlock()
	Endif
Endif


IF SE2->E2_VALOR != nValorAnt
	Reclock("SE2")
	Replace E2_SALDO With E2_VALOR
	nValForte := ConvMoeda(E2_EMISSAO,E2_VENCTO,E2_VALOR,GetMv("mv_mcusto"))
	//³ Atualiza saldo do fornecedor.							  ³
	dbSelectArea("SA2")
	dbSeek(cFilial+SE2->E2_FORNECE+SE2->E2_LOJA)
	RecLock("SA2")
	If !(SE2->E2_TIPO $ MVABATIM+"/"+MVPAGANT+"/"+MV_CPNEG )
		SA2->A2_SALDUP -=Round(NoRound(xMoeda(nOldValor	 ,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,3),3),2)
		SA2->A2_SALDUPM-=Round(NoRound(xMoeda(nOldValor	 ,SE2->E2_MOEDA,nMoeda,SE2->E2_EMISSAO,3),3),2)
		SA2->A2_SALDUP +=Round(NoRound(xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,3),3),2)
		SA2->A2_SALDUPM+=Round(NoRound(xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,nMoeda,SE2->E2_EMISSAO,3),3),2)
	Else
		SA2->A2_SALDUP +=Round(NoRound(xMoeda(nOldValor	 ,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,3),3),2)
		SA2->A2_SALDUPM+=Round(NoRound(xMoeda(nOldValor	 ,SE2->E2_MOEDA,nMoeda,SE2->E2_EMISSAO,3),3),2)
		SA2->A2_SALDUP -=Round(NoRound(xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,3),3),2)
		SA2->A2_SALDUPM-=Round(NoRound(xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,nMoeda,SE2->E2_EMISSAO,3),3),2)
	EndIf
	nValForte := ConvMoeda(SE2->E2_EMISSAO,SE2->E2_VENCTO,A2_SALDUP,GetMv("mv_mcusto"))
	dbSelectArea("SA2")
	If SA2->A2_SALDUPM > A2_MSALDO
		Replace A2_MSALDO With SA2->A2_SALDUPM
	EndIf
EndIF

cTipoFor	:= IIf(SA2->A2_TIPO=="J" .AND. lIRProg == "1","F",SA2->A2_TIPO)
cTipoFor02	:= IIf(!Empty(SA2->A2_TIPO),SA2->A2_TIPO,"J")

//³ Verifica se houve alteracao de VENC.REAL	e nao e tipo imposto 'TX' ³
If SE2->E2_VENCREA != dOldVencRe .And. !E2_TIPO $ "TX /ISS/INS/SES" .and. !lPccBaixa

	dbSelectArea("SE2")
	If lIRPFBaixa
		dVencRea := F050VImp("IRRF",SE2->E2_EMISSAO,SE2->E2_EMIS1,SE2->E2_VENCREA,,,lIRPFBaixa) // Calcula o vencimento do imposto
	Else
		dVencRea := F050VImp("IRRF",SE2->E2_EMISSAO,SE2->E2_EMIS1,SE2->E2_VENCREA,cCodRetIr,cTipoFor) // Calcula o vencimento do imposto
	Endif
	If !Empty(cChaveIrf) .and. MsSeek(cFilial+cChaveIrf+cUniao)
		If SE2->E2_SALDO > 0
			Reclock("SE2")
			SE2->E2_VENCREA 	:= dVencrea
			SE2->E2_VENCTO 	:= dVencrea
			MsUnlock()
		Endif
	Endif
	dbGoto(nRegSe2)
	dVencRea := F050VImp("PIS",SE2->E2_EMISSAO,SE2->E2_EMIS1,SE2->E2_VENCREA,cCodRetPis) // Calcula o vencimento do imposto
	//Atualiza data de vencimento do titulo de PIS
	If !Empty(cChavePis) .and. MsSeek(cFilial+cChavePis+cUniao)
		If SE2->E2_SALDO > 0
			Reclock("SE2")
			SE2->E2_VENCREA 	:= dVencrea
			SE2->E2_VENCTO 	:= dVencrea
			MsUnlock()
		Endif
	Endif
	//Atualiza data de vencimento do titulo de Cofins
	If !Empty(cChaveCof) .and. MsSeek(cFilial+cChaveCof+cUniao)
		If SE2->E2_SALDO > 0
			Reclock("SE2")
			SE2->E2_VENCREA 	:= dVencrea
			SE2->E2_VENCTO 	:= dVencrea
			MsUnlock()
		Endif
	Endif
	//Atualiza data de vencimento do titulo de Cofins
	If !Empty(cChaveCsl) .and. MsSeek(cFilial+cChaveCsl+cUniao)
		If SE2->E2_SALDO > 0
			Reclock("SE2")
			SE2->E2_VENCREA 	:= dVencrea
			SE2->E2_VENCTO 	:= dVencrea
			MsUnlock()
		Endif
	Endif
Endif
dbGoto(nRegSe2)

If lSpbInUse
	cModSpb := IIf(Empty(SE2->E2_MODSPB), "1",SE2->E2_MODSPB)
Endif

//³ Verifica se houve alteracao de Irrf		  ³
If SE2->E2_IRRF != nOldIrrf .or. SE2->E2_CODRET<>cOldCodRet

	dbSelectArea("SE2")
	nRegSe2 := RecNo()
	cTipoSE2 := SE2->E2_TIPO
	nValorIr:= SE2->E2_IRRF
	If nOldIrrf != 0
		If !lIrfMR
			If lIRPFBaixa
				dVencRea := F050VImp("IRRF",SE2->E2_EMISSAO,SE2->E2_EMIS1,SE2->E2_VENCREA,,,lIRPFBaixa) // Calcula o vencimento do imposto
			Else
				dVencRea := F050VImp("IRRF",SE2->E2_EMISSAO,SE2->E2_EMIS1,SE2->E2_VENCREA,cCodRetIr,cTipoFor) // Calcula o vencimento do imposto
			Endif
		EndIf

		If (dbSeek(cFilial+cChaveIrf+cUniao))
			If nValorIr != 0
				If !lIrfMR
					Reclock("SE2")
					SE2->E2_VALOR := nValorIr
					SE2->E2_SALDO := nValorIr
					SE2->E2_VLCRUZ:= Round( nValorIr, MsDecimais(1) )
					//Trata a alteração do codigo de retenção *
					SE2->E2_VENCREA 	:= dVencrea
					SE2->E2_VENCTO 	:= dVencrea
					SE2->E2_DIRF    := cGeraDirf
					SE2->E2_CODRET  := cCodRetIr
				EndIf

				PCODetLan("000002","06","FINA050")		// Altera o lancamento de IRRF gerado no PCO
			Else
				PCODetLan("000002","06","FINA050",.T.)	// Apaga o lancamento de IRRF gerado no PCO
				If !lIrfMR
					Iif(lIntPFS .and. FindFunction("JDelTitCP"), JDelTitCP(SE2->(Recno())), Nil) // Integração SIGAPFS x SIGAFIN remove os desdobramentos quando o titulo for deletado
					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					Reclock("SE2",.F.,.T.)
					dbDelete()
					msUnLock()
					dbGoto (nRegSE2)
					Reclock("SE2",.F.)
					SE2->E2_PARCIR := " "
					msUnLock()
				Endif
			EndIf
		Else
			nOldIrrf := 0
		EndIf
		dbGoto(nRegSe2)
	Endif

	//³ Verifica se informado IRRf sem existir	  ³
	//³ anteriormente.									  ³
	If nOldIrrf = 0 .And. SE2->E2_IRRF != 0 .and. !lIRPFBaixa
		If !lIrfMR
			nValorIr := SE2->E2_IRRF
			//Gera titulo de IRRF Cria o fornecedor, caso nao exista			  ³
			dbSelectArea("SA2")
			If !(dbSeek(cFilial+GetMV("MV_UNIAO")))
				Reclock("SA2",.T.)
				Replace A2_FILIAL With cFilial
				Replace A2_COD   With GetMV("MV_UNIAO")
				Replace A2_NOME	With OemToAnsi(STR0027)  // "UNIAO"
				Replace A2_NREDUZ With OemToAnsi(STR0027)  // "UNIAO"
				Replace A2_LOJA	With cLojaImp
				Replace A2_MUN 	With "."
				Replace A2_EST 	With SuperGetMv("MV_ESTADO")
				Replace A2_BAIRRO With "."
				Replace A2_END 	With "."
				Replace A2_TIPO	With "J"
			EndIF

			dVencRea := F050VImp("IRRF",dEmissao,dEmis1,dVctoReal,cCodRetIr,cTipoFor) // Calcula o vencimento do imposto

			cParcIr := ParcImposto(cPrefixo,cNum,cTipoSE2)
			//³ Grava a parcela do IR no titulo pai fazendo ³
			//³ a amarracao titulo x titulo IR              ³
			dbGoto(nRegSe2)
			RecLock("SE2")
			SE2->E2_PARCIR 	:= cParcIR
			SE2->E2_DIRF    	:= "2" // Desmarca titulo principal, pois apenas o titulo de
			// imposto vai para DIRF
			MsUnlock()

			//³ Grava titulo de IR caso n„o exista anterior.³

			RecLock("SE2",.T.)
			SE2->E2_FILIAL		:= cFilial
			SE2->E2_PREFIXO 	:= cPrefixo
			SE2->E2_NUM			:= cNum
			SE2->E2_PARCELA 	:= cParcIR
			SE2->E2_NATUREZ 	:= &(GetMv("MV_IRF"))
			SE2->E2_TIPO		:= Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG  .And. !lPCCBaixa,MVTXA,MVTAXA)
			SE2->E2_EMISSAO 	:= dEmissao
			SE2->E2_VALOR		:= nValorIr
			SE2->E2_VENCREA 	:= dVencrea
			SE2->E2_SALDO		:= nValorIr
			SE2->E2_VENCTO		:= dVencRea
			SE2->E2_VENCORI 	:= dVencRea
			SE2->E2_EMIS1		:= IIf(Type("dDataEmis1") # "U", IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
			SE2->E2_FORNECE 	:= GetMV("MV_UNIAO")
			SE2->E2_LOJA 		:= cLojaImp
			SE2->E2_NOMFOR		:= SA2->A2_NREDUZ
			SE2->E2_MOEDA		:= 1
			SE2->E2_VLCRUZ		:= Round( nValorIr, MsDecimais(1) )
			//Grava campo E2_TITPAI
			SE2->E2_TITPAI   := cTitPai
			SE2->E2_CODAPRO  := cCodAprov
			If lSpbInUse
				Replace	SE2->E2_MODSPB with cModSpb
			Endif
			SE2->E2_DIRF    := cGeraDirf
			SE2->E2_CODRET  := cCodRetIr
			SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)

			//³ Ponto de Entrada para Titulo IRRF   		  ³
			If lF050IRF
				Execblock("F050IRF",.F.,.F.,nRegSE2)
			EndIf

			//³ Grava o lancamento de IRRF no PCO ³
			PCODetLan("000002","06","FINA050")

			If !lIrfMR
				//Cria a natureza IRF caso nao exista
				dbSelectArea("SED")
				cVar := Alltrim(&(GetMv("MV_IRF")))
				cVar := cVar + Space(10-Len(cVar))
				If !(dbSeek(cFilial+cVar))
					RecLock("SED",.T.)
					Replace 	ED_FILIAL  With cFilial,;
					ED_CODIGO  With cVar	,	;
					ED_CALCIRF With "N" 	,	;
					ED_CALCISS With "N"	, 	;
					ED_CALCINS With "N"	,	;
					ED_CALCCSL With "N"	,	;
					ED_CALCCOF With "N"	,	;
					ED_CALCPIS With "N"	,	;
					ED_DESCRIC With OemToAnsi(STR0028),	;  // "IMPOSTO RENDA RETIDO NA FONTE"
					ED_TIPO	   With "2"
				EndIf
			EndIf
		Endif
	EndIf
	dbSelectArea("SE2")
	dbGoto(nRegSe2)
ElseIf !lIrfMR .And. SE2->E2_IRRF > 0 .and. dOldVencRe <> dVctoReal
	dbSelectArea("SE2")
	nRegSe2 := SE2->(RecNo())
	nValorIr := SE2->E2_IRRF
	If (dbSeek(cFilial+cChaveIrf+cUniao))
		If SE2->E2_SALDO == nValorIr
			dVencRea := F050VImp("IRRF",dEmissao,dEmis1,dVctoReal,cCodRetIr,cTipoFor) // Calcula o vencimento do imposto
			RecLock("SE2",.F.)
			SE2->E2_VENCREA := dVencrea
			SE2->E2_VENCTO 	:= dVencRea
			SE2->E2_VENCORI	:= dVencRea
			SE2->E2_DIRF    := cGeraDirf
			SE2->E2_CODRET  := cCodRetIr
			MsUnlock()
		EndIf
	EndIf
	dbGoto(nRegSe2)
EndIf

// Verifica se houve alteracao do ISS bitributacao
If lBtrISS .and. !lCalcIssBx .and. (SE2->E2_BTRISS != nBtrISSOri .Or. (SE2->E2_BTRISS == 0 .And. !(SE2->E2_TIPO $ MVISS+"/"+MVTAXA+"/"+MVINSS+"/"+"SES"+"/"+MVPAGANT+"/"+MV_CPNEG)))
	dbSelectArea("SE2")
	nRegSe2  := RecNo()
	nValorISS  := SE2->E2_BTRISS
	aISSMun := BtrISSMun("P",,SE2->E2_CODSERV)
	If !Empty(aISSMun) .and. (dbSeek(cFilial+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCISS+MVISS+aISSMun[4]+aISSMun[5]))
		If nValorISS != 0
			Reclock("SE2")
			SE2->E2_VALOR := nValorISS
			SE2->E2_SALDO := nValorISS
		Else
			If !("FINA290" $ SE2->E2_ORIGEM)
				Iif(lIntPFS .and. FindFunction("JDelTitCP"), JDelTitCP(SE2->(Recno())), Nil) // Integração SIGAPFS x SIGAFIN remove os desdobramentos quando o titulo for deletado
				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				Reclock("SE2",.F.,.T.)
				dbDelete()
			Endif
		EndIf
	Else
		nBtrISSOri := 0
	EndIf
	dbGoto(nRegSe2)
EndIf

//³ Verifica se houve alteracao de Iss		     ³
If !lCalcIssBx .and. (SE2->E2_ISS != nOldISSInt .Or. (SE2->E2_ISS == 0 .And. !(SE2->E2_TIPO $ MVISS+"/"+MVTAXA+"/"+MVINSS+"/"+"SES"+"/"+MVPAGANT+"/"+MV_CPNEG)))
	dbSelectArea("SE2")
	nRegSe2  := RecNo()
	nValorISS  := SE2->E2_ISS
	If (dbSeek(cFilial+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCISS+MVISS+SuperGetMV("MV_MUNIC")))
		If nValorISS != 0
			If !lIssMR
				Reclock("SE2")
				SE2->E2_VALOR := nValorISS
				SE2->E2_SALDO := nValorISS
				PCODetLan("000002","09","FINA050")		// Altera o lancamento de ISS gerado no PCO
			EndIf
		Else
			If !("FINA290" $ SE2->E2_ORIGEM)
				PCODetLan("000002","09","FINA050",.T.)	// Apaga o lancamento de ISS gerado no PCO

				If !lIssMR
					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					Reclock("SE2",.F.,.T.)
					dbDelete()
				EndIf
			EndIf
		EndIf
	Else
		nOldIssInt := 0
	EndIf
	dbGoto(nRegSe2)
EndIf

//Verificar valor minimo do ISS.
If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN" .And. ;
SE2->E2_FRETISS == "2" // Nao verificar minimo do ISS
	lVerMinIss := .F.
Endif

If lVerMinIss .and. ;
((cForMinISS == "1" .And. SE2->E2_ISS <= SuperGetMv("MV_VRETISS",.F., 0)) .Or. ;
(cForMinISS == "2" .And. SE2->E2_BASEISS <= GetNewPar("MV_VBASISS",0)))
	lGravRegIss	:=	.F. //Nao libero registro de acordo com o valor minimo do ISS.
EndIf

// Verifica se informado ISS sem existir anteriormente.
If lGravRegIss .AND. !lCalcIssBx
	If !lIssMR
		//Calculo da data de vencimento do ISS
		If SE2->E2_VENCREA != dOldVencRe .OR. SE2->E2_NATUREZ != cOldNatPFS
			Do Case
				Case GetNewPar("MV_VENCISS","E")=="E"
					dVenISS := dEmissao
					dVenISS += 28

					If ( Month(dVenISS) == Month(dEmissao) )
						dVenISS := dVenISS+28
					EndIf

					nTamData := Iif(Len(Dtoc(dVenISS)) == 10, 7, 5)

					If SX6->(dbSeek(SE2->E2_FILORIG+"MV_DIAISS")) .and. lAltera .and. cPaisLoc=="BRA"
						dVenISS	:= Ctod(SX6->X6_CONTEUD+"/"+Subs(Dtoc(dVenISS),4,nTamData))
					Else
						dVenISS	:= Ctod(StrZero(SuperGetMv("MV_DIAISS"),2)+"/"+Subs(Dtoc(dVenISS),4,nTamData))
					EndIf
				Case GetNewPar("MV_VENCISS","E")=="Q" //Ultimo dia util da quinzena subsequente a dEmissao
					If Day(dEmissao) <= 15
						dVenISS	:= LastDay(dEmissao)
						dVenISS := DataValida(dVenISS,.F.)
					Else
						dVenISS := DataValida((LastDay(dEmissao)+1)+14,.F.)
					EndIf
				Case GetNewPar("MV_VENCISS","E")=="U" //Ultimo dia util do mes subsequente da dEmissao
					dVenISS := DataValida(LastDay(LastDay(dEmissao)+1),.F.)
				Case GetNewPar("MV_VENCISS","E")=="D"
					dVenISS := (LastDay(dEmissao)+1)

					If SX6->(dbSeek(SE2->E2_FILORIG+"MV_DIAISS")) .and. lAltera .and. cPaisLoc=="BRA"
						nDiaUtil:= SX6->X6_CONTEUD
					Else
						nDiaUtil:= SuperGetMv("MV_DIAISS")
					Endif

					For nDia := 1 To nDiaUtil-1
						If !(dVenISS == DataValida(dVenISS,.T.))
							nDia-=1
						EndIf
						dVenISS+=1
					Next nDia
				Case GetNewPar("MV_VENCISS","E")=="F" //Qtd de dia do parametro MV_DIAISS apos o fechamento da quinzena.
					If Day(dEmissao) <= 15
						If SX6->(dbSeek(SE2->E2_FILORIG+"MV_DIAISS")) .and. lAltera .and. cPaisLoc=="BRA"
							dVenISS	:= CtoD("15"+SUBSTR(DtoC(dEmissao),3,Len(DtoC(dEmissao))))+SX6->X6_CONTEUD
						Else
							dVenISS := CtoD("15"+SUBSTR(DtoC(dEmissao),3,Len(DtoC(dEmissao))))+SuperGetMv("MV_DIAISS")
						Endif
					Else
						If SX6->(dbSeek(SE2->E2_FILORIG+"MV_DIAISS")) .and. lAltera .and. cPaisLoc=="BRA"
							dVenISS	:= LastDay(dEmissao)+SX6->X6_CONTEUD
						Else
							dVenISS := LastDay(dEmissao)+SuperGetMv("MV_DIAISS")
						Endif
					EndIf
				OtherWise
					dVenISS := dVctoReal
					dVenISS += 28

					If ( Month(dVenISS) == Month(dVctoReal) )
						dVenISS := dVenISS+28
					EndIf

					nTamData := Iif(Len(Dtoc(dVenISS)) == 10, 7, 5)

					If SX6->(dbSeek(SE2->E2_FILORIG+"MV_DIAISS")) .and. lAltera .and. cPaisLoc=="BRA"
						dVenISS	:= Ctod(SX6->X6_CONTEUD+"/"+Subs(Dtoc(dVenISS),4,nTamData))
					Else
						dVenISS	:= Ctod(StrZero(SuperGetMv("MV_DIAISS"),2)+"/"+Subs(Dtoc(dVenISS),4,nTamData))
					Endif
			EndCase

			dVencRea	:=	DataValida(dVenISS,IIF(lVcAntIss,.F.,.T.))
			dVenISS	:=	IIF(dVenIss > dVencRea, dVencRea, dVenIss)
		EndIf
	Endif
	If	(nOldIssInt == 0 .And. SE2->E2_ISS != 0) //Criando o registo do ISS
		If !lIssMR
		nValorIss := SE2->E2_ISS
			//Gera titulo de ISS Cria o fornecedor, caso nao exista
			dbSelectArea("SA2")
			If !(dbSeek(cFilial+GetMV("MV_MUNIC")))
				Reclock("SA2",.T.)
				Replace A2_FILIAL With cFilial
				Replace A2_COD	  With GetMV("MV_MUNIC")
				Replace A2_LOJA   With cLojaImp
				Replace A2_NOME   With OemToAnsi(STR0029)  // "MUNICIPIO"
				Replace A2_NREDUZ With OemToAnsi(STR0029)  // "MUNICIPIO"
				Replace A2_BAIRRO With "."
				Replace A2_MUN	  With "."
				Replace A2_EST	  With SuperGetMv("MV_ESTADO")
				Replace A2_END	  With "."
			EndIf

			cParcISS := STRZERO(1,nTamParc)

			While ( .T. )
				//Verifica se ja' ha' titulo de ISS com esta numeração
				dbSelectArea("SE2")
				If (dbSeek(cFilial+cPrefixo+cNum+cParcISS+"ISS"+GetMV("MV_MUNIC")))
					cParcISS := Soma1( cParcISS,,.t. )
					Loop
				EndIf
				Exit
			Enddo

			RecLock("SE2",.T.)
			SE2->E2_FILIAL  := cFilial
			SE2->E2_PREFIXO := cPrefixo
			SE2->E2_NUM	  	 := cNum
			SE2->E2_PARCELA := cParcIss
			SE2->E2_NATUREZ := &(GetMv("MV_ISS"))
			SE2->E2_TIPO	 := MVISS
			SE2->E2_EMISSAO := dEmissao
			SE2->E2_VALOR   := nValorIss
			SE2->E2_VENCTO  := dVenISS
			SE2->E2_SALDO   := nValorIss
			SE2->E2_VENCREA := dVencRea
			SE2->E2_VENCORI := dVenISS
			SE2->E2_FORNECE := GetMV("MV_MUNIC")
			SE2->E2_LOJA    := cLojaImp
			SE2->E2_NOMFOR  := SA2->A2_NREDUZ
			SE2->E2_MOEDA   := 1
			SE2->E2_VLCRUZ 	:= Round( nValorIss, MsDecimais(1) )
			SE2->E2_ORIGEM 	:= "FINA050"
			SE2->E2_EMIS1 	:= dDataBase
			//Grava campo E2_TITPAI
			SE2->E2_TITPAI   := cTitPai
			SE2->E2_CODAPRO  := cCodAprov

			If lSpbInUse
				Replace	SE2->E2_MODSPB with cModSpb
			Endif

			SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)
		EndIf
		//³ Ponto de Entrada para Titulo ISS			  ³
		If lF050ISS
			Execblock("F050ISS",.F.,.F.,nRegSE2)
		Endif

		//³ Grava o lancamento de ISS no PCO ³
		PCODetLan("000002","09","FINA050")

		If !lIssMR
			//Cria a natureza ISS caso nao exista		  ³
			dbSelectArea("SED")
			cVar := Alltrim(&(GetMv("MV_ISS")))
			cVar := cVar + Space(10-Len(cVar))
			If !(dbSeek( cFilial + cVar ) )
				RecLock("SED",.T.)
				Replace 	ED_FILIAL  With cFilial,;
				ED_CODIGO  With cVar	,	;
				ED_CALCIRF With "N" 	,	;
				ED_CALCISS With "N"	, 	;
				ED_CALCINS With "N"	,	;
				ED_CALCCSL With "N"  ,	;
				ED_CALCCOF With "N"  ,  ;
				ED_CALCPIS With "N"  ,	;
				ED_DESCRIC With OemToAnsi(STR0030),;			  // "IMPOSTO SOBRE SERVICOS"
				ED_TIPO	   With "2"
			EndIf

			//Grava parcela do Iss na parcela do titulo  ³
			dbSelectArea( "SE2" )
			dbGoto( nRegSe2 )
			Reclock( "SE2" , .F. )
			SE2->E2_PARCISS := cParcISS
			MsUnlock()
		EndIf
	ElseIf !lIssMR .And. lAltera .And. nISSOri != SE2->E2_ISS
		nRegSe2 := SE2->(Recno())
		nValorIss 	:= SE2->E2_ISS
		cChaveIss	:= xFilial("SE2") + SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCISS + MVISS + Padr(GetMv("MV_MUNIC"),TamSx3("E2_FORNECE")[1])
		If !Empty(cChaveIss) .and. MsSeek(cChaveIss)
			RecLock("SE2",.F.)
			SE2->E2_VALOR	:= nValorIss
			SE2->E2_SALDO	:= nValorIss
			SE2->E2_VLCRUZ 	:= Round( nValorIss, MsDecimais(1) )
			MsUnlock()
		EndIf
		SE2->(DbGoto( nRegSe2 ))
	ElseIf !lIssMR .And. lBtrISS .and. lAltera .and. nBtrISSOri <> SE2->E2_BTRISS
		nRegSe2		:= SE2->(Recno())
		nValorIss 	:= SE2->E2_BTRISS
		cChaveIss	:= xFilial("SE2") + SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCISS + MVISS + Padr(Upper(SM0->M0_CIDENT),TamSx3("E2_FORNECE")[1])
		If !Empty(cChaveIss) .and. MsSeek(cChaveIss)
			RecLock("SE2",.F.)
			SE2->E2_VALOR	:= nValorIss
			SE2->E2_SALDO	:= nValorIss
			SE2->E2_VLCRUZ 	:= Round( nValorIss, MsDecimais(1) )
			MsUnlock()
	   Endif
	   SE2->(DbGoto( nRegSe2 ))

	ElseIF !lIssMR .And. SE2->E2_VENCTO <> dVenISS .OR. 	SE2->E2_VENCREA <> dVencRea //Alterando registro caso as datas de vencimentos sejam alteradas.
	  	nRegSe2 := SE2->(Recno())
		nValorIss 	:= SE2->E2_ISS
		cChaveIss	:= xFilial("SE2") + SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCISS + MVISS + Padr(GetMv("MV_MUNIC"),TamSx3("E2_FORNECE")[1])
		If SE2->E2_VENCREA != dOldVencRe .and. !Empty(cChaveIss) .and.;
			MsSeek(cChaveIss) .and. Empty(SE2->E2_NUMBOR)
			If SE2->E2_SALDO == nValorIss
				RecLock("SE2", .F. )
				SE2->E2_VENCREA := dVencRea
				SE2->E2_VENCTO	:= dVenIss
				MsUnlock()
			Endif
		Endif
		SE2->(DbGoto( nRegSe2 ))
	EndIf

EndIf
//Verifica se altero o RETINSS
If !lInsMR
	dbSelectArea("SE2")
	nRegSe2 := SE2->(Recno())
	If SE2->(dbSeek(cFilial+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCINS+"INS"+GetMv("MV_FORINSS")))
		If SE2->E2_RETINS <> cRetIns
			Reclock("SE2",.F.)
			SE2->E2_RETINS:= M->E2_RETINS
			SE2->(MsUnlock())
		EndIF

		SE2->(DbGoto( nRegSe2 ))
	EndIF
EndIf
//³ Verifica se houve alteracao de Inss		  ³
dbSelectArea("SE2")
SE2->(DbGoto( nRegSe2 ))
If SE2->E2_INSS != nOldIns .OR. (SE2->E2_INSS == 0 .AND. !(SE2->E2_TIPO $ MVISS+"/"+MVTAXA+"/"+MVINSS+"/"+"SES"+"/"+MVPAGANT+"/"+MV_CPNEG)) .or. ;
	( (SE2->E2_CODRET<>cOldCodRet) .and. cTipoFor02 == 'F') .And. !lInssBx

	nValInss:= SE2->E2_INSS
	If nOldIns != 0
		If (dbSeek(cFilial+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCINS+"INS"+GetMv("MV_FORINSS")))
			If nValInss != 0
				If !lInsMR
					Reclock("SE2")
					SE2->E2_VALOR := nValInss
					SE2->E2_SALDO := nValInss
					SE2->E2_VLCRUZ:= Round( nValInss, MsDecimais(1) )
					SE2->E2_DIRF    := cGeraDirf
					SE2->E2_CODRET  := cCodRetIr
				EndIf

				PCODetLan("000002","07","FINA050")		// Altera o lancamento de INSS gerado no PCO
			Else
				PCODetLan("000002","07","FINA050",.T.)	// Apaga o lancamento de INSS gerado no PCO

				If !lInsMR
					//apaga o registro de inss que tornou indevido após alteracao do principal
					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					Reclock("SE2",.F.,.T.)
					dbDelete()
					MsUnlock()

					SE2->(dbGoto(nRegSE2))
					Reclock("SE2",.F.)
					SE2->E2_PARCINS := " "
					MsUnlock()
					aRecSE2 := FImpExcTit("SE2",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,@aTpImp)

					//atualiza os acumulados do fornecedor, de forma que retorne o status de retencao do INSS
					For nX := 1 to Len(aRecSE2)
						SE2->(MSGoto(aRecSE2[nX]))
						FaAvalSE2(4,,,,,,,,,,"INS")
					Next

					SE2->(dbGoto(nRegSE2))
					FImpExcSFQ("SE2",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
				EndIf
			EndIf
		Else
			nOldIns := 0
		Endif
		SE2->(dbGoto(nRegSe2))
	EndIf

	//Verifica se informado INSS sem existir anteriormente.									  ³
	If nOldIns = 0 .And. SE2->E2_INSS != 0 .And. !lInssBx
		If !lInsMR
			nValInss := SE2->E2_INSS
			//³ Gera titulo de INSS						   ³
			//Gera titulo de INSS
			FGrvINSS(cPrefixo,cNum,cParcInss,"","",1,nRegSED,nRegSE2,dEmissao,dDataBase,dVctoReal,nValInss,.F.,{},{},cGeraDirf,cCodRetIr,lSpbInUse,cModSpb)
		EndIf
		//³ Grava o lancamento de INSS no PCO ³
		PCODetLan("000002","07","FINA050")
	ElseIf !lInsMR .And. nOldIns <> 0 .And. nOldIns <> SE2->E2_INSS
		SE2->E2_PRETINS := " " // PRET = " " - Retido nele mesmo.
	EndIf
	dbSelectArea("SE2")
	dbGoto(nRegSe2)
Endif

If !lInsMR .And. (SE2->E2_INSS > 0) .and. (dOldVencRe <> dVctoReal) .And. !lInssBX
	//Atualiza data de vencimento do titulo de INSS
	dVencRea := F050VImp("INSS",SE2->E2_EMISSAO,SE2->E2_EMIS1,SE2->E2_VENCREA,,cTipoFor02) // Calcula o vencimento do imposto

	If !Empty(cChaveInss) .AND. SE2->(MsSeek(cFilial + cChaveInss + cForInss))
		If SE2->E2_SALDO > 0
			Reclock("SE2")
			SE2->E2_VENCREA	:= dVencrea
			SE2->E2_VENCTO	:= dVencrea
			//	SE2->E2_EMIS1	:= dVencrea -> Data da contabilização dos impostos não pode ser alterada!
			MsUnlock()
		EndIf
	EndIf
	SE2->(dbGoto(nRegSe2))
Endif

//³ Verifica se houve alteracao de SEST   	  ³
If cPaisLoc == 'BRA' .And. (SE2->E2_SEST != nOldSES .OR. (SE2->E2_SEST == 0 .And. !(SE2->E2_TIPO $ MVISS+"/"+MVTAXA+"/"+MVINSS+"/"+"SES"+"/"+MVPAGANT+"/"+MV_CPNEG)))
	dbSelectArea("SE2")
	nRegSe2 := RecNo()
	nValSEST:= SE2->E2_SEST
	If nOldSES != 0
		If (dbSeek(cFilial+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCSES+"SES"+AllTrim(cForSEST) ))
			If nValSEST != 0
				If !lSestMR
					Reclock("SE2")
					SE2->E2_VALOR := nValSEST
					SE2->E2_SALDO := nValSEST
					SE2->E2_VLCRUZ:= Round( nValSEST, MsDecimais(1) )
				EndIf

				PCODetLan("000002","08","FINA050")		// Altera o lancamento de SEST/SENAT gerado no PCO
			Else
				PCODetLan("000002","08","FINA050",.T.)	// Apaga o lancamento de SEST/SENAT gerado no PCO
				If !lSestMR
					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					Reclock("SE2",.F.,.T.)
					dbDelete()
				msUnLock()
					dbGoto (nRegSE2)
					Reclock("SE2",.F.)
					SE2->E2_PARCSES := " "
				EndIf
			EndIf
		Else
			nOldSES := 0
		EndIf
		dbGoto(nRegSe2)
	EndIf
	//³ Verifica se informado SEST sem existir	  ³
	//³ anteriormente.									  ³
	If nOldSES = 0 .And. SE2->E2_SEST != 0
		nValSEST := SE2->E2_SEST

		If !lSestMR
			//Gera titulo de SEST Cria o fornecedor, caso nao exista			  ³
			dbSelectArea("SA2")
			If !(dbSeek(cFilial+AllTrim(cForSEST) ))
				Reclock("SA2",.T.)
				Replace A2_FILIAL With cFilial
				Replace A2_COD    With GetmV("MV_FORSEST")
				Replace A2_NOME	With   STR0109 //"Servico Social do Transporte"
				Replace A2_NREDUZ With  "SEST"
				Replace A2_LOJA	With cLojaImp
				Replace A2_MUN 	With "."
				Replace A2_EST 	With SuperGetMv("MV_ESTADO")
				Replace A2_BAIRRO With "."
				Replace A2_END 	With "."
			EndIF

			dNextMes := Month(SE2->E2_EMISSAO)+1
			dNextVen := CTOD("02/"+IIF(dNextMes==13,"01",StrZero(dNextMes,2))+"/"+;
			Substr(Str(IIF(dNextMes==13,Year(SE2->E2_EMISSAO)+1,Year(SE2->E2_EMISSAO))),2),"ddmmyy")
			dVencRea := DataValida(dNextVen,.T.)

			//³ Verifica parcela do SEST caso exista titulo de SEST com o mesmo numero
			cParcSEST := STRZERO(1,nTamParc)
			DbSelectArea("SE2")
			DbSetOrder(1)

			While .T.
				//³ VerIfica se ja' ha' titulo de SEST com esta numera‡„o ³
				If (DbSeek(cFilial+cPrefixo+cNum+cParcSEST+"SES"+PadR(cForSEST,6)))
					cParcSEST := Soma1( cParcSEST,,.t.)
					Loop
				EndIf
				Exit
			Enddo

			//Grava a parcela do SEST no titulo pai fazendo a amarracao titulo x titulo SEST			  ³
			dbGoto(nRegSe2)
			RecLock("SE2")
			SE2->E2_PARCSES 	:= cParcSEST

			//³ Grava titulo de SEST caso n„o exista anterior.³
			RecLock("SE2",.T.)
			SE2->E2_FILIAL		:= cFilial
			SE2->E2_PREFIXO 	:= cPrefixo
			SE2->E2_NUM			:= cNum
			SE2->E2_PARCELA 	:= cParcSEST
			SE2->E2_NATUREZ 	:= AllTrim(cSEST)
			SE2->E2_TIPO 		:= "SES"
			SE2->E2_EMISSAO 	:= dEmissao
			SE2->E2_VALOR		:= nValSEST
			SE2->E2_VENCREA 	:= dVencrea
			SE2->E2_SALDO		:= nValSEST
			SE2->E2_VENCTO		:= dVencRea
			SE2->E2_VENCORI 	:= dVencRea
			SE2->E2_EMIS1		:= IIf(Type("dDataEmis1") # "U",IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
			SE2->E2_FORNECE	    := Padr(cForSEST,6)
			SE2->E2_LOJA 		:= cLojaImp
			SE2->E2_NOMFOR		:= SA2->A2_NREDUZ
			SE2->E2_MOEDA		:= 1
			SE2->E2_VLCRUZ		:= Iif(lRndSest,Round( nValSEST, MsDecimais(1) ),NoRound( nValSEST, MsDecimais(1) ))
			//Grava campo E2_TITPAI
			SE2->E2_TITPAI   := cTitPai
			SE2->E2_CODAPRO  := cCodAprov

			If lSpbInUse
				Replace	SE2->E2_MODSPB with cModSpb
			Endif

			SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)
		EndIf

		//³ Ponto de Entrada para Titulo SEST   		  ³
		If lF050SES
			Execblock("F050SES",.F.,.F.,nRegSE2)
		Endif

		//³ Grava o lancamento de SEST/SENAT no PCO ³
		PCODetLan("000002","08","FINA050")

		If !lSestMR
			//Cria a natureza SEST caso nao exista 		  ³
			dbSelectArea("SED")
			cVar := Alltrim(cSEST)
			cVar := cVar + Space(10-Len(cVar))
			If !(dbSeek(cFilial+cVar))
				RecLock("SED",.T.)
				Replace 	ED_FILIAL  With cFilial,;
				ED_CODIGO  With cVar	,	;
				ED_CALCIRF With "N" 	,	;
				ED_CALCISS With "N"	, 	;
				ED_CALCINS With "N"	,	;
				ED_CALCCSL With "N"  ,	;
				ED_CALCCOF With "N"  ,  ;
				ED_CALCPIS With "N"  ,	;
				ED_DESCRIC With OemToAnsi(STR0109),;  // "Servico Social do Transporte"
				ED_TIPO	   With "2"
			EndIf

			Iif(lIntPFS .and. FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
		EndIf
	Endif
	dbSelectArea("SE2")
	dbGoto(nRegSe2)
EndIf

//³ Verifica se houve alteracao de CIDE   	  ³
If !lCidMR .And. lCIDE
	If cPaisLoc == "BRA" .And. (SE2->E2_CIDE != nOldCID .OR. ;
	(SE2->E2_CIDE == 0 .And. !(SE2->E2_TIPO $ MVISS+"/"+MVTAXA+"/"+MVINSS+"/"+"CID"+"/"+MVPAGANT+"/"+MV_CPNEG)))
		dbSelectArea("SE2")
		nRegSe2  := RecNo()
		nValCIDE:= SE2->E2_CIDE
		If nOldCID != 0
			If (dbSeek(cFilial+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCCID+"CID"+GetMv("MV_FORCIDE")))
				If nValCIDE != 0
					Reclock("SE2")
					SE2->E2_VALOR := nValCIDE
					SE2->E2_SALDO := nValCIDE
					SE2->E2_VLCRUZ:= Round( nValCIDE, MsDecimais(1) )
					msUnLock()
				Else
					Iif(lIntPFS .and. FindFunction("JDelTitCP"), JDelTitCP(SE2->(Recno())), Nil) // Integração SIGAPFS x SIGAFIN remove os desdobramentos quando o titulo for deletado
					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					Reclock("SE2",.F.,.T.)
					dbDelete()
					msUnLock()
					dbGoto (nRegSE2)
					Reclock("SE2",.F.)
					SE2->E2_PARCCID := " "
					msUnLock()
				EndIf
			Else
				nOldCID := 0
			EndIf
			dbGoto(nRegSe2)
		EndIf

		//³ Verifica se informado CIDE sem existir	  ³
		//³ anteriormente.									  ³
		If nOldCID = 0 .And. SE2->E2_CIDE != 0
			nValCIDE := SE2->E2_CIDE
			//³ Gera titulo de CIDE								  ³
			//³ Cria o fornecedor, caso nao exista			  ³
			dbSelectArea("SA2")
			If !(dbSeek(cFilial+GetMv("MV_FORCIDE")))
				Reclock("SA2",.T.)
				Replace A2_FILIAL With cFilial
				Replace A2_COD    With GetmV("MV_FORCIDE")
				Replace A2_NOME	With  "CIDE"
				Replace A2_NREDUZ With  "CIDE"
				Replace A2_LOJA	With cLojaImp
				Replace A2_MUN 	With "."
				Replace A2_EST 	With SuperGetMv("MV_ESTADO")
				Replace A2_BAIRRO With "."
				Replace A2_END 	With "."
			EndIf
			dNextMes := Month(SE2->E2_EMISSAO)+1
			dNextVen := CTOD("02/"+IIF(dNextMes==13,"01",StrZero(dNextMes,2))+"/"+;
			Substr(Str(IIF(dNextMes==13,Year(SE2->E2_EMISSAO)+1,Year(SE2->E2_EMISSAO))),2),"ddmmyy")
			dVencRea := DataValida(dNextVen,.T.)

			//³ Verifica parcela do CIDE caso exista titulo ³
			//³ de CIDE com o mesmo numero.                 ³
			cParcCIDE := STRZERO(1,nTamParc)
			DbSelectArea("SE2")
			DbSetOrder(1)
			While .T.
				//³ VerIfica se ja' ha' titulo de CIDE com esta numera‡„o ³
				If (DbSeek(cFilial+cPrefixo+cNum+cParcCIDE+"CID"+PadR(GetMv("MV_FORCIDE"),6)))
					cParcCIDE := Soma1( cParcCIDE,,.t.)
					Loop
				EndIf
				Exit
			Enddo
			//³ Grava a parcela do CIDE no titulo pai fazendo ³
			//³ a amarracao titulo x titulo CIDE			  ³
			dbGoto(nRegSe2)
			RecLock("SE2")
			SE2->E2_PARCCID 	:= cParcCIDE

			//³ Grava titulo de CIDE caso n„o exista anterior.³
			RecLock("SE2",.T.)
			SE2->E2_FILIAL		:= cFilial
			SE2->E2_PREFIXO 	:= cPrefixo
			SE2->E2_NUM			:= cNum
			SE2->E2_PARCELA 	:= cParcCIDE
			SE2->E2_NATUREZ 	:= AllTrim(cCIDE)
			SE2->E2_TIPO 		:= "CID"
			SE2->E2_EMISSAO 	:= dEmissao
			SE2->E2_VALOR		:= nValCIDE
			SE2->E2_VENCREA 	:= dVencrea
			SE2->E2_SALDO		:= nValCIDE
			SE2->E2_VENCTO		:= dVencRea
			SE2->E2_VENCORI 	:= dVencRea
			SE2->E2_EMIS1		:= IIf(Type("dDataEmis1") # "U",IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
			SE2->E2_FORNECE   := GetMv("MV_FORCIDE")
			SE2->E2_LOJA 		:= cLojaImp
			SE2->E2_NOMFOR		:= SA2->A2_NREDUZ
			SE2->E2_MOEDA		:= 1
			SE2->E2_VLCRUZ		:= Round( nValCIDE, MsDecimais(1) )
			//Grava campo E2_TITPAI
			SE2->E2_TITPAI   := cTitPai
			SE2->E2_CODAPRO  := cCodAprov
			If lSpbInUse
				Replace	SE2->E2_MODSPB with cModSpb
			Endif

			SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)

			//³ Cria a natureza CIDE caso nao exista 		  ³
			dbSelectArea("SED")
			cVar := Alltrim(cCIDE)
			cVar := cVar + Space(10-Len(cVar))
			If !(dbSeek( cFilial + cVar ) )
				RecLock("SED",.T.)
				Replace 	ED_FILIAL  With cFilial,;
				ED_CODIGO  With cVar	,	;
				ED_CALCIRF With "N" 	,	;
				ED_CALCISS With "N"	, 	;
				ED_CALCINS With "N"	,	;
				ED_CALCCSL With "N"  ,	;
				ED_CALCCOF With "N"  ,  ;
				ED_CALCPIS With "N"  ,	;
				ED_DESCRIC With "CIDE", ;
				ED_TIPO	   With "2"
				msUnLock()

				Iif(lIntPFS .and. FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
			EndIf
		EndIf
		dbSelectArea( "SE2" )
		dbGoto( nRegSe2 )
	EndIf
EndIf

If !lPccMR .And. lContrRet .and. (lAlterNat .or. lAltValor) .and. !lPccBaixa
	Do Case
		Case cModRetPIS == "1"

		nValorTit := SE2->(E2_VALOR+E2_PIS+E2_COFINS+E2_CSLL+E2_IRRF+E2_INSS+E2_ISS)+ ;
		Iif(cPaisLoc == 'BRA', SE2->E2_SEST, 0)

		If aDadosRet[ 1 ] + nValorTit	> nVlMinImp
			lRetParc := .T.
			//³ Guarda os valores originais                           ³
			nRetOriPIS := nVlRetPis
			nRetOriCOF := nVlRetCOF
			nRetOriCSL := nVlRetCSL

			nVlRetPIS := M->E2_PIS
			nVlRetCOF := M->E2_COFINS
			nVlRetCSL := M->E2_CSLL

			nSobra := nDifPCC

			//Havia uma NDF gerada anteriormente e agora deve ser deletada
			If nRecnoNdf > 0
				nSavRec := SE2->( Recno() )
				SE2->(dbGoTo(nRecnoNdf))

				Iif(lIntPFS .and. FindFunction("JDelTitCP"), JDelTitCP(SE2->(Recno())), Nil) // Integração SIGAPFS x SIGAFIN remove os desdobramentos quando o titulo for deletado
				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				SE2->(RecLock("SE2"))
				SE2->(dbDelete())
				SE2->(MsUnlock())

				SE2->(Dbgoto(nSavRec))
			Endif
			If nSobra < 0 .and. cNCCRet == "1"
				//Gero NDF com a diferenca
				ADupCredRt(Abs(nDifPcc),"501",SE2->E2_MOEDA)
			EndIF

			lRestValImp := .T.

			nSavRec := SE2->( Recno() )

			//³ Exclui a Marca de "pendente recolhimento" dos demais registros   ³
			If aDadosRet[1] > 0
				aRecnos := aClone( aDadosRet[ 5 ] )

				cPrefOri  := SE2->E2_PREFIXO
				cNumOri   := SE2->E2_NUM
				cParcOri  := SE2->E2_PARCELA
				cTipoOri  := SE2->E2_TIPO
				cCfOri    := SE2->E2_FORNECE
				cLojaOri  := SE2->E2_LOJA

				For nLoop := 1 to Len( aRecnos )

					SE2->( dbGoto( aRecnos[ nLoop ] ) )

					Reclock("SE2",.F.)

					SE2->E2_PRETPIS := "2"
					SE2->E2_PRETCOF := "2"
					SE2->E2_PRETCSL := "2"

					SE2->( MsUnlock() )

					If nSavRec <> aRecnos[ nLoop ]
						dbSelectArea("SFQ")
						RecLock("SFQ",.T.)
						SFQ->FQ_FILIAL  := xFilial("SFQ")
						SFQ->FQ_ENTORI  := "SE2"
						SFQ->FQ_PREFORI := cPrefOri
						SFQ->FQ_NUMORI  := cNumOri
						SFQ->FQ_PARCORI := cParcOri
						SFQ->FQ_TIPOORI := cTipoOri
						SFQ->FQ_CFORI   := cCfOri
						SFQ->FQ_LOJAORI := cLojaOri

						SFQ->FQ_ENTDES  := "SE2"
						SFQ->FQ_PREFDES := SE2->E2_PREFIXO
						SFQ->FQ_NUMDES  := SE2->E2_NUM
						SFQ->FQ_PARCDES := SE2->E2_PARCELA
						SFQ->FQ_TIPODES := SE2->E2_TIPO
						SFQ->FQ_CFDES   := SE2->E2_FORNECE
						SFQ->FQ_LOJADES := SE2->E2_LOJA
						MsUnlock()
					EndIf
				Next nLoop
			EndIf
			//³ Retorna do ponteiro do SE2 para a parcela         ³
			SE2->( MsGoto( nSavRec ) )
			Reclock("SE2", .F. )

		Else
			//³ Grava a Marca de "pendente recolhimento" dos demais registros    ³
			nRetOriPIS := nVlRetPis
			nRetOriCOF := nVlRetCOF
			nRetOriCSL := nVlRetCSL

			Reclock("SE2", .F. )
			SE2->E2_VRETPIS := 0
			SE2->E2_VRETCOF := 0
			SE2->E2_VRETCSL := 0

			If ( !Empty( nRetOriPis ) .Or. !Empty( nRetOriCof ) .Or. !Empty( nRetOriCsl ) )
				SE2->E2_PRETPIS := "1"
				SE2->E2_PRETCOF := "1"
				SE2->E2_PRETCSL := "1"
			EndIf
			MsUnlock()
			lRetParc := .F.
			lRestValImp := .T.
		EndIf

		Case cModRetPIS == "2"
		//³ Efetua a retencao                                                 ³
		nSavRec := SE2->( Recno() )

		//³ Exclui a Marca de "pendente recolhimento" dos demais registros   ³
		If aDadosRet[1] > 0
			aRecnos := aClone( aDadosRet[ 5 ] )

			cPrefOri  := SE2->E2_PREFIXO
			cNumOri   := SE2->E2_NUM
			cParcOri  := SE2->E2_PARCELA
			cTipoOri  := SE2->E2_TIPO
			cCfOri    := SE2->E2_FORNECE
			cLojaOri  := SE2->E2_LOJA

			For nLoop := 1 to Len( aRecnos )

				SE2->( dbGoto( aRecnos[ nLoop ] ) )

				RecLock("SE2", .F. )

				SE2->E2_PRETPIS := "2"
				SE2->E2_PRETCOF := "2"
				SE2->E2_PRETCSL := "2"

				SE2->( MsUnlock() )

				If nSavRec <> aRecnos[ nLoop ]
					dbSelectArea("SFQ")
					RecLock("SFQ",.T.)
					SFQ->FQ_FILIAL  := xFilial("SFQ")
					SFQ->FQ_ENTORI  := "SE2"
					SFQ->FQ_PREFORI := cPrefOri
					SFQ->FQ_NUMORI  := cNumOri
					SFQ->FQ_PARCORI := cParcOri
					SFQ->FQ_TIPOORI := cTipoOri
					SFQ->FQ_CFORI   := cCfOri
					SFQ->FQ_LOJAORI := cLojaOri

					SFQ->FQ_ENTDES  := "SE2"
					SFQ->FQ_PREFDES := SE2->E2_PREFIXO
					SFQ->FQ_NUMDES  := SE2->E2_NUM
					SFQ->FQ_PARCDES := SE2->E2_PARCELA
					SFQ->FQ_TIPODES := SE2->E2_TIPO
					SFQ->FQ_CFDES   := SE2->E2_FORNECE
					SFQ->FQ_LOJADES := SE2->E2_LOJA
					MsUnlock()
				Endif
			Next nLoop
		Endif
		//³ Retorna do ponteiro do SE1 para a parcela         ³
		SE2->( MsGoto( nSavRec ) )
		Reclock("SE2", .F. )

		lRetParc := .T.
		Case cModRetPIS == "3"
		//³ Nao efetua a retencao                             ³
		lRetParc := .F.
		lRestValImp := .T.
		//³ Grava a Marca de "pendente recolhimento" dos demais registros    ³
		nRetOriPIS := nVlRetPis
		nRetOriCOF := nVlRetCOF
		nRetOriCSL := nVlRetCSL

		If ( !Empty( nRetOriPis ) .Or. !Empty( nRetOriCof ) .Or. !Empty( nRetOriCsl ) )
			Reclock("SE2", .F. )
			SE2->E2_PRETPIS := "1"
			SE2->E2_PRETCOF := "1"
			SE2->E2_PRETCSL := "1"
			Reclock("SE2", .F. )
		EndIf
	EndCase
Else
	lRetParc := .T.
EndIf

If !lPccMR .And. lContrRet .and. (lAlterNat .or. lAltValor) .and. !lPccBaixa

	SE2->( MsGoto( nRegSE2 ) )
	Reclock("SE2" , .F. )

	If lRetParc
		//³ Grava os campos de valor retido              ³
		SE2->E2_VRETPIS := SE2->E2_PIS
		SE2->E2_VRETCOF := SE2->E2_COFINS
		SE2->E2_VRETCSL := SE2->E2_CSLL

		SE2->E2_PRETPIS := " "
		SE2->E2_PRETCOF := " "
		SE2->E2_PRETCSL := " "

	EndIf

	MsUnlock()

Endif

nValPis     := SE2->E2_VRETPIS
nValCofins  := SE2->E2_VRETCOF
nValCsll    := SE2->E2_VRETCSL

If SuperGetMv("MV_AG10925",.F.,"2") == "1" .and. cCodRetPis == "5952"
	nRefCof := nValCofins //Armazena o valor do Cofins, para recompor os valores apos a geracao dos titulos
	nRefCsl := nValCsll   //Armazena o valor do Csll, para recompor os valores apos a geracao dos titulos

	nValPis    += nValCofins + nValCsll
	nValCofins := 0
	nValCsll   := 0
Endif

//³ Verifica se houve alteracao de PIS			  ³
SE2->(dbSetOrder(1))
If (SE2->E2_PIS != nOldPisAnt .or. SE2->E2_CODRET<>cOldCodRet .or. nValorTit	> nVlMinImp) .and. !(SE2->E2_ORIGEM == "MATA100 " .and. !lPCCBaixa) .And. Iif(SuperGetMv("MV_AG10925",.F.,"2") == "1" .and. cCodRetPis == "5952", nValPis > 0,.T.)

	dbSelectArea("SE2")
	nRegSe2 := RecNo()
	//	nValPis:= SE2->E2_PIS
	If SuperGetMv("MV_AG10925",.F.,"2") <> "1"
		nValPis := SE2->E2_PIS
	EndIf
	If nOldPisAnt != 0
		If (dbSeek(xFilial("SE2")+cChavePis+cUniao))
			If nValPis != 0
				If !lPccMR
					Reclock("SE2")
					SE2->E2_VALOR := nValPis
					SE2->E2_SALDO := nValPis
					SE2->E2_VLCRUZ:= Round( nValPis, MsDecimais(1) )
					// Trata a alteração do codigo de retenção *
					SE2->E2_DIRF    := cGeraDirf
					SE2->E2_CODRET  := cCodRetPis
				EndIf
				PCODetLan("000002","10","FINA050")		// Altera o lancamento de PIS gerado no PCO
			Else
				PCODetLan("000002","10","FINA050",.T.)	// Apaga o lancamento de PIS gerado no PCO

				If !lPccMR
					Iif(lIntPFS .and. FindFunction("JDelTitCP"), JDelTitCP(SE2->(Recno())), Nil) // Integração SIGAPFS x SIGAFIN remove os desdobramentos quando o titulo for deletado
					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					Reclock("SE2",.F.,.T.)
					dbDelete()
					msUnLock()

					dbGoto (nRegSE2)
					Reclock("SE2",.F.)
					SE2->E2_PARCPIS := " "
					SE2->E2_VRETPIS := 0
					SE2->E2_PRETPIS := "1"
					msUnLock()
					lZerouImp := .T.
				EndIf
			EndIf
		Else
			nOldPisAnt := 0
		EndIf
		dbGoto(nRegSe2)
	Endif
	//³ Verifica se informado PIS sem existir	  	  ³
	//³ anteriormente.									  ³
	If nOldPisAnt = 0 .And. SE2->E2_PIS != 0 .and. lRetParc .and. !lPccBaixa
		If !lPccMR
			nValPis := SE2->E2_PIS
			//Gera titulo de PIS Cria o fornecedor, caso nao exista			  ³
			dbSelectArea("SA2")

			If !(dbSeek(xFilial("SA2")+GetMv("MV_UNIAO")))
				Reclock("SA2",.T.)
				Replace A2_FILIAL With xFilial("SA2")
				Replace A2_COD    With GetmV("MV_UNIAO")
				Replace A2_NOME	With "UNIAO"
				Replace A2_NREDUZ With "UNIAO"
				Replace A2_LOJA	With cLojaImp
				Replace A2_MUN 	With "."
				Replace A2_EST 	With SuperGetMv("MV_ESTADO")
				Replace A2_BAIRRO With "."
				Replace A2_END 	With "."
				Replace A2_TIPO	With "J"
			EndIF

			dVencRea := F050VImp("PIS",dEmissao,dEmis1,dVctoReal) // Calcula o vencimento do imposto

			//Verifica parcela do PIS caso exista titulo de PIS com o mesmo numero.                 ³
			cParcPis := ParcImposto(cPrefixo,cNum,cTipoSE2)

			//Grava a parcela do PIS no titulo pai fazendo a amarracao titulo x titulo PIS
			dbGoto(nRegSe2)
			RecLock("SE2")
			SE2->E2_PARCPIS 	:= cParcPis
			SE2->E2_DIRF    	:= "2"	 // Desmarca titulo principal, pois apenas o titulo de
			// imposto var para DIRF
			//imposto var para DIRF Cria a natureza PIS caso nao exista
			dbSelectArea("SED")
			cVar := Alltrim(GetMv("MV_PISNAT"))
			cVar := cVar + Space(10-Len(cVar))
			If !(dbSeek(cFilial+cVar))
				RecLock("SED",.T.)
				Replace 	ED_FILIAL  With cFilial,;
				ED_CODIGO  With cVar	,	;
				ED_CALCIRF With "N" 	,	;
				ED_CALCISS With "N"	, 	;
				ED_CALCINS With "N"	,	;
				ED_CALCCSL With "N"  ,	;
				ED_CALCCOF With "N"  ,  ;
				ED_CALCPIS With "N"  ,	;
				ED_DESCRIC With "PIS",  ;
				ED_TIPO	   With "2"
				MsUnlock()

				Iif(lIntPFS .and. FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
			EndIf
			//³ Grava titulo de PIS caso n„o exista anterior.³
			RecLock("SE2",.T.)
			SE2->E2_FILIAL		:= cFilial
			SE2->E2_PREFIXO 	:= cPrefixo
			SE2->E2_NUM			:= cNum
			SE2->E2_PARCELA 	:= cParcPis
			SE2->E2_NATUREZ 	:= GetMv("MV_PISNAT")
			SE2->E2_TIPO		:= Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG  .And. !lPCCBaixa,MVTXA,MVTAXA)
			SE2->E2_EMISSAO 	:= dEmissao
			SE2->E2_VALOR		:= nValPis
			SE2->E2_VENCREA 	:= dVencrea
			SE2->E2_SALDO		:= nValPis
			SE2->E2_VENCTO		:= dVencRea
			SE2->E2_VENCORI 	:= dVencRea
			SE2->E2_EMIS1		:= IIf(Type("dDataEmis1") # "U",IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
			SE2->E2_FORNECE		:= GetMv("MV_UNIAO")
			SE2->E2_LOJA 		:= cLojaImp
			SE2->E2_NOMFOR		:= SA2->A2_NREDUZ
			SE2->E2_MOEDA		:= 1
			SE2->E2_VLCRUZ		:= Round( nValPis, MsDecimais(1) )
			//Grava campo E2_TITPAI
			SE2->E2_TITPAI      := cTitPai
			SE2->E2_CODAPRO  := cCodAprov

			If lSpbInUse
				Replace	SE2->E2_MODSPB with cModSpb
			Endif

			SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)
			SE2->E2_DIRF    := cGeraDirf
			SE2->E2_CODRET  := cCodRetPis
			SE2->(MsUnlock())
		EndIf

		//³ Grava o lancamento de PIS no PCO ³
		PCODetLan("000002","10","FINA050")

	EndIf
	dbSelectArea("SE2")
	dbGoto(nRegSe2)
EndIf
//³ Verifica se houve alteracao de COFINS		  ³
If (SE2->E2_COFINS != nOldCofAnt .or. SE2->E2_CODRET<>cOldCodRet .or. nValorTit	> nVlMinImp) .and. !(SE2->E2_ORIGEM == "MATA100 " .and. !lPCCBaixa) .and. Iif(SuperGetMv("MV_AG10925",.F.,"2") == "1" .and. cCodRetPis == "5952", nValCofins > 0,.T.)
	dbSelectArea("SE2")
	nRegSe2 := RecNo()
	//nValCofins:= SE2->E2_COFINS
	If SuperGetMv("MV_AG10925",.F.,"2") <> "1"
		nValCofins:= SE2->E2_COFINS
	EndIf
	If nOldCofAnt != 0
		If (dbSeek(xFilial("SE2")+cChaveCof+cUniao))
			If nValCofins != 0
				If !lPccMR
					Reclock("SE2")
					SE2->E2_VALOR := nValCofins
					SE2->E2_SALDO := nValCofins
					SE2->E2_VLCRUZ:= Round( nValCofins, MsDecimais(1) )

					// Trata a alteração do codigo de retenção *
					SE2->E2_DIRF    := cGeraDirf
					SE2->E2_CODRET  := cCodRetCof
				EndIf

				PCODetLan("000002","11","FINA050")		// Altera o lancamento de COFINS gerado no PCO
			Else
				PCODetLan("000002","11","FINA050",.T.)	// Apaga o lancamento de COFINS gerado no PCO

				If !lPccMR
					Iif(lIntPFS .and. FindFunction("JDelTitCP"), JDelTitCP(SE2->(Recno())), Nil) // Integração SIGAPFS x SIGAFIN remove os desdobramentos quando o titulo for deletado
					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					Reclock("SE2",.F.,.T.)
					dbDelete()
					msUnLock()

					dbGoto (nRegSE2)
					Reclock("SE2",.F.)
					SE2->E2_PARCCOF := " "
					SE2->E2_VRETCOF := 0
					SE2->E2_PRETCOF := "1"
					msUnLock()
					lZerouImp := .T.
				EndIf
			EndIf
		Else
			nOldCofAnt := 0
		EndIf
		dbGoto(nRegSe2)
	Endif
	//³ Verifica se informado COFINS sem existir	  ³
	//³ anteriormente.									  ³
	If nOldCofAnt = 0 .And. SE2->E2_COFINS != 0 .and. lRetParc .and. !lPccBaixa
		nValCofins := SE2->E2_COFINS

		If !lPccMR
			//³ Gera titulo de COFINS Cria o fornecedor, caso nao exista			  ³
			dbSelectArea("SA2")
			If !(dbSeek(xFilial("SA2")+GetMv("MV_UNIAO")))
				Reclock("SA2",.T.)
				Replace A2_FILIAL With xFilial("SA2")
				Replace A2_COD    With GetmV("MV_UNIAO")
				Replace A2_NOME	With "UNIAO"
				Replace A2_NREDUZ With "UNIAO"
				Replace A2_LOJA	With cLojaImp
				Replace A2_MUN 	With "."
				Replace A2_EST 	With SuperGetMv("MV_ESTADO")
				Replace A2_BAIRRO With "."
				Replace A2_END 	With "."
				Replace A2_TIPO	With "J"
			EndIF

			dVencRea := F050VImp("COFINS",dEmissao,dEmis1,dVctoReal) // Calcula o vencimento do imposto

			//³ Verifica parcela do COFINS caso exista titulo de COFINS com o mesmo numero.                 ³
			cParcCof := ParcImposto(cPrefixo,cNum,cTipoSE2)

			//Grava a parcela do COFINS no titulo pai fazendo a amarracao titulo x titulo COFINS	   			 ³
			RecLock("SE2")
			SE2->E2_PARCCOF 	:= cParcCof
			SE2->E2_DIRF    	:= "2"	 // Desmarca titulo principal, pois apenas o titulo de

			// imposto var para DIRF
			//³ Cria a natureza COFINS caso nao exista 	³
			dbSelectArea("SED")
			cVar := Alltrim(GetMv("MV_COFINS"))
			cVar := cVar + Space(10-Len(cVar))

			If !(dbSeek(cFilial+cVar))
				RecLock("SED",.T.)
				Replace 	ED_FILIAL  With cFilial,;
				ED_CODIGO  With cVar	,	;
				ED_CALCIRF With "N" 	,	;
				ED_CALCISS With "N"	, 	;
				ED_CALCINS With "N"	,	;
				ED_CALCCSL With "N"  ,	;
				ED_CALCCOF With "N"  ,  ;
				ED_CALCPIS With "N"  ,	;
				ED_DESCRIC With "COFINS" , ;
				ED_TIPO	   With "2"
				MsUnlock()

				Iif(lIntPFS .and. FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
			EndIf
			//³ Grava titulo de COFINS caso n„o exista anterior.³
			RecLock("SE2",.T.)
			SE2->E2_FILIAL		:= cFilial
			SE2->E2_PREFIXO 	:= cPrefixo
			SE2->E2_NUM			:= cNum
			SE2->E2_PARCELA 	:= cParcCof
			SE2->E2_NATUREZ 	:= GetMv("MV_COFINS")
			SE2->E2_TIPO	   := Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG  .And. !lPCCBaixa,MVTXA,MVTAXA)
			SE2->E2_EMISSAO 	:= dEmissao
			SE2->E2_VALOR		:= nValCofins
			SE2->E2_VENCREA 	:= dVencrea
			SE2->E2_SALDO		:= nValCofins
			SE2->E2_VENCTO		:= dVencRea
			SE2->E2_VENCORI 	:= dVencRea
			SE2->E2_EMIS1		:= IIf(Type("dDataEmis1") # "U",IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
			SE2->E2_FORNECE	:= GetMv("MV_UNIAO")
			SE2->E2_LOJA 		:= cLojaImp
			SE2->E2_NOMFOR		:= SA2->A2_NREDUZ
			SE2->E2_MOEDA		:= 1
			SE2->E2_VLCRUZ		:= Round( nValCofins, MsDecimais(1) )
			//Grava campo E2_TITPAI
			SE2->E2_TITPAI      := cTitPai
			SE2->E2_CODAPRO  := cCodAprov

			If lSpbInUse
				Replace	SE2->E2_MODSPB with cModSpb
			Endif

			SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)
			SE2->E2_DIRF    := cGeraDirf
			SE2->E2_CODRET  := cCodRetCof
			SE2->(MsUnlock())
		EndIf

		//³ Gera o lancamento de COFINS no PCO ³
		PCODetLan("000002","11","FINA050")

	EndIf
	dbSelectArea("SE2")
	dbGoto(nRegSe2)
EndIf
//³ Verifica se houve alteracao de CSLL		  ³
If (SE2->E2_CSLL != nOldCslAnt .or. SE2->E2_CODRET<>cOldCodRet .or. nValorTit > nVlMinImp) .and. !(SE2->E2_ORIGEM == "MATA100 " .and. !lPCCBaixa) .And. Iif(SuperGetMv("MV_AG10925",.F.,"2") == "1" .and. cCodRetPis == "5952", nValCsll > 0,.T.)
	dbSelectArea("SE2")
	nRegSe2 := RecNo()
	//	nValCsll:= SE2->E2_CSLL
	If SuperGetMv("MV_AG10925",.F.,"2") <> "1"
		nValCsll:= SE2->E2_CSLL
	EndIf
	If nOldCslAnt != 0
		If (dbSeek(xFilial("SE2")+cChaveCsl+cUniao))
			If nValCsll != 0
				If !lPccMR
					Reclock("SE2")
					SE2->E2_VALOR := nValCsll
					SE2->E2_SALDO := nValCsll
					SE2->E2_VLCRUZ:= Round( nValCsll, MsDecimais(1) )
					// Trata a alteração do codigo de retenção *
					SE2->E2_DIRF    := cGeraDirf
					SE2->E2_CODRET  := cCodRetCsl
				EndIf

				PCODetLan("000002","12","FINA050")		// Altera o lancamento de CSLL gerado no PCO
			Else
				PCODetLan("000002","12","FINA050",.T.)	// Apaga o lancamento de CSLL gerado no PCO

				If !lPccMR

					Iif(lIntPFS .and. FindFunction("JDelTitCP"), JDelTitCP(SE2->(Recno())), Nil) // Integração SIGAPFS x SIGAFIN remove os desdobramentos quando o titulo for deletado
					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					Reclock("SE2",.F.,.T.)
					dbDelete()
					msUnLock()
					dbGoto (nRegSE2)
					Reclock("SE2",.F.)
					SE2->E2_PARCSLL := " "
					SE2->E2_VRETCSL := 0
					SE2->E2_PRETCSL := "1"
					msUnLock()
					lZerouImp := .T.
				EndIf
			EndIf
		Else
			nOldCslAnt := 0
		EndIf
		dbGoto(nRegSe2)
	Endif
	//³ Verifica se informado CSLL sem existir	  ³
	//³ anteriormente.									  ³
	If nOldCslAnt = 0 .And. SE2->E2_CSLL != 0 .and. lRetParc .and. !lPccBaixa
		If !lPccMR
			nValCsll := SE2->E2_CSLL
			//Gera titulo de CSLL Cria o fornecedor, caso nao exista			  ³
			dbSelectArea("SA2")

			If !(dbSeek(xFilial("SA2")+GetMv("MV_UNIAO")))
				Reclock("SA2",.T.)
				Replace A2_FILIAL With xFilial("SA2")
				Replace A2_COD    With GetmV("MV_UNIAO")
				Replace A2_NOME	With "UNIAO"
				Replace A2_NREDUZ With "UNIAO"
				Replace A2_LOJA	With cLojaImp
				Replace A2_MUN 	With "."
				Replace A2_EST 	With SuperGetMv("MV_ESTADO")
				Replace A2_BAIRRO With "."
				Replace A2_END 	With "."
				Replace A2_TIPO	With "J"
			EndIF

			dVencRea := F050VImp("CSLL",dEmissao,dEmis1,dVctoReal) // Calcula o vencimento do imposto

			//Verifica parcela do CSLL caso exista titulo de CSLL com o mesmo numero.                 ³
			cParcCsll := ParcImposto(cPrefixo,cNum,cTipoSE2)

			//Grava a parcela do CSLL no titulo pai fazendo a amarracao titulo x titulo CSLL
			dbGoto(nRegSe2)
			RecLock("SE2")
			SE2->E2_PARCSLL 	:= cParcCsll
			SE2->E2_DIRF    	:= "2"	 // Desmarca titulo principal, pois apenas o titulo de

			//imposto vai para DIRF Cria a natureza CSLL caso nao exista 	³
			dbSelectArea("SED")
			cVar := Alltrim(GetMv("MV_CSLL"))
			cVar := cVar + Space(10-Len(cVar))

			If !(dbSeek(cFilial+cVar))
				RecLock("SED",.T.)
				Replace 	ED_FILIAL  With cFilial,;
				ED_CODIGO  With cVar	,	;
				ED_CALCIRF With "N" 	,	;
				ED_CALCISS With "N"	, 	;
				ED_CALCINS With "N"	,	;
				ED_CALCCSL With "N"  ,	;
				ED_CALCCOF With "N"  ,  ;
				ED_CALCPIS With "N"  ,	;
				ED_DESCRIC With "CSLL", ;
				ED_TIPO	   With "2"
				MsUnlock()

				Iif(lIntPFS .and. FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
			EndIf

			//³ Grava titulo de CSLL caso n„o exista anterior.³
			RecLock("SE2",.T.)
			SE2->E2_FILIAL		:= cFilial
			SE2->E2_PREFIXO 	:= cPrefixo
			SE2->E2_NUM			:= cNum
			SE2->E2_PARCELA 	:= cParcCsll
			SE2->E2_NATUREZ 	:= GetMv("MV_CSLL")
			SE2->E2_TIPO		:= Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG  .And. !lPCCBaixa,MVTXA,MVTAXA)
			SE2->E2_EMISSAO 	:= dEmissao
			SE2->E2_VALOR		:= nValCsll
			SE2->E2_VENCREA 	:= dVencrea
			SE2->E2_SALDO		:= nValCsll
			SE2->E2_VENCTO		:= dVencRea
			SE2->E2_VENCORI 	:= dVencRea
			SE2->E2_EMIS1		:= IIf(Type("dDataEmis1") # "U",IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
			SE2->E2_FORNECE		:= GetMv("MV_UNIAO")
			SE2->E2_LOJA 		:= cLojaImp
			SE2->E2_NOMFOR		:= SA2->A2_NREDUZ
			SE2->E2_MOEDA		:= 1
			SE2->E2_VLCRUZ		:= Round( nValCsll, MsDecimais(1) )
			//Grava campo E2_TITPAI
			SE2->E2_TITPAI      := cTitPai
			SE2->E2_CODAPRO  	:= cCodAprov

			If lSpbInUse
				Replace	SE2->E2_MODSPB with cModSpb
			Endif

			SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)
			SE2->E2_DIRF    := cGeraDirf
			SE2->E2_CODRET  := cCodRetCsl
			SE2->(MsUnlock())
		EndIf

		//³ Gera o lancamento de CSLL no PCO ³
		PCODetLan("000002","12","FINA050")

	EndIf
	dbSelectArea("SE2")
	dbGoto(nRegSe2)

	If !lPccMR .And. lContrRet .and. lZerouImp .and. !lPccBaixa
		aRecSE2 := FImpExcTit("SE2",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
		For nX := 1 to Len(aRecSE2)
			SE2->(MSGoto(aRecSE2[nX]))
			FaAvalSE2(4)
		Next

		//³ Exclui os registros de relacionamentos do SFQ                                ³
		SE2->(dbGoto(nRegSE2))
		FImpExcSFQ("SE2",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
	Endif
EndIf

//Refaz os valores de PIS/COFINS/CSLL, quando aglutinados em um unico TX.
If SuperGetMv("MV_AG10925",.F.,"2") == "1" .and. cCodRetPis == "5952"
	nValPis     -= nRefCof + nRefCsl
	nValCsll    := nRefCsl
	nValCofins  := nRefCof
EndIf

If !lPccMR .And. (SE2->E2_ORIGEM == "MATA100 " .or. (!lAlterNat .And. !lZerouImp .And. SE2->E2_EMISSAO < dLastPCC)) .and. !lPCCBaixa
	RECLOCK("SE2",.f.)
	SE2->E2_PIS 	:= nPisOri
	SE2->E2_COFINS 	:= nCofOri
	SE2->E2_CSLL 	:= nCslOri
	MsUnlock()
EndIf

If !lPccMR .And. lContrRet .and. lRestValImp .and. !lPccBaixa
	//³ Restaura os valores originais de PIS / COFINS / CSLL  ³
	RecLock("SE2", .F. )

	If M->E2_PIS == 0 .Or. (nRetOriPIS <> nVlRetPIS .And. nVlRetPIS <> SE2->E2_PIS)
		SE2->E2_PIS    := If (!Empty(nRetOriPIS),nRetOriPIS,SE2->E2_PIS)
	EndIf

	If M->E2_COFINS == 0 .Or. (nRetOriCOF <> nVlRetCOF .And. nVlRetCOF <> SE2->E2_COFINS)
		SE2->E2_COFINS := If (!Empty(nRetOriCOF),nRetOriCOF,SE2->E2_COFINS)
	EndIf

	If M->E2_CSLL == 0 .Or. (nRetOriCSL <> nVlRetCSL .And. nVlRetCSL <> SE2->E2_CSLL)
		SE2->E2_CSLL   := If (!Empty(nRetOriCSL),nRetOriCSL,SE2->E2_CSLL)
	EndIf

	SE2->E2_VLCRUZ := Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,MsDecimais(1)+1,SE2->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
EndIf

//³ Efetua a atualizacao dos arquivos do SIGAPMS        ³
// integração com o PMS
If IntePMS() .And. SE2->E2_PROJPMS == "1" .and. !lRatAutPrj//so validar se nao for chamado pelo array automatico de rateio
	Eval(bPMSDlgFI)
EndIf

lPrimeiro:= .T. //Wilson em 06/06/2011

If IntePMS() .and. SE2->E2_PROJPMS == "1"
	PmsWriteFI(2,"SE2")	//Estorno
	PmsWriteFI(1,"SE2") //Inclusao
Endif

//³ Efetua a gravacao das justificativas                ³
// Adiciona botao para envio de instrucoes de cobranca
F050GrvFI2()

//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
If SE2->E2_TIPO $ MVPAGANT
	PcoDetLan("000002","02","FINA050")
Else
	PcoDetLan("000002","01","FINA050")
EndIf

//Chamada de funcao para tratamento da Average
If lIntegracao
	FI400VALFIN()
EndIF

// Valores acessórios
If lF050Auto .and. ValType(aVAAuto) = "A" .and. FAPodeTVA(SE2->E2_TIPO, /*cNatureza*/, .F., "P")
	If !Fa050VA(.T.)
		lResult := .F.
	Endif
Endif

//realiza a gravacao da alteracao do model
If cPaisLoc=="BRA"
	Fa986grava("SE2","FINA050")
EndIf

//realiza a integracao online do titulo para o TAF
//habilitar somente quando tiver a integra??o TAF
//If FindFunction("TAFExstInt") .And. TAFExstInt()
//FinExpTAF(SE2->(Recno()),1,,,,, )
//EndIf

//Alteracao no titulo retido ou retentor com PCC retido na emissao
If 	!lPccBaixa
	//Alteração de Valores (Titulo e/ou PCC)
	If	((nVlrOri != SE2->E2_VALOR) .Or. (SE2->E2_PIS != nPisOri .Or. SE2->E2_COFINS != nCofOri .Or. SE2->E2_CSLL != nCslOri)) .And. (SE2->E2_VENCREA 	>= dDataIni .And. SE2->E2_VENCREA <= dDataFim)
		//Verifica a possibilidade de Alteração de um titulo que teve seus impostos(PCC) Retidos em outro Titulo(Retentor)
		If F050VerAlt()
			//Caso seja permitida a alteracao de um titulo retido
			If	lTitRetA
				F050AltRtd()

				//Caso seja permitida a alteracao de um titulo retentor ou aguardando retenção
			ElseIf  (SE2->E2_PRETPIS <>	"2" .Or. SE2->E2_PRETCOF <>	"2"	.Or. SE2->E2_PRETCSL <>  "2")

				//Verifico se o titulo eh retentor
				lTitReteu := (SE2->E2_PRETPIS == " " .Or. SE2->E2_PRETCOF == " " .Or. SE2->E2_PRETCSL == " ")

				aAreaSed := SED->(GetArea())
				aAreaSa2 := SA2->(GetArea())
				//Se nao tiver essa checagem no caso de uma alteracao efetuando a retencao dos valores do PCC na mao
				//de um titulo que tenha uma natureza sem impostos os campos E2_PIS,E2_COFINS e E2_CSLL sao gravados zerados.
				SA2->(dbSeek(xFilial("SA2") + SE2->(E2_FORNECE + E2_LOJA)))
				SED->(dbSeek(xFilial("SED") + SE2->E2_NATUREZ))
				If (SED->ED_CALCPIS == "S" .AND. SA2->A2_RECPIS  == "2" .OR. ;
				SED->ED_CALCCOF == "S" .AND. SA2->A2_RECCOFI == "2" .OR. ;
				SED->ED_CALCCSL == "S" .AND. SA2->A2_RECCSLL == "2" ) .AND. ;
				!lTitReteu .And. !lZerouImp .And. lAlterNat

					F050GrvRtr()
				Endif
				RestArea(aAreaSed)
				RestArea(aAreaSa2)
			EndIf
		Endif
	Endif
	//Alteração do Periodo,Data Vencto (Titulo e/ou PCC)
	If	(SE2->E2_VENCREA 	< dDataIni 		.Or. SE2->E2_VENCREA > dDataFim)
		//Verifica a possibilidade de Alteração de um titulo que teve seus impostos(PCC)
		//Retidos em outro Titulo(Retentor)
		If F050VerAlt()
			//Caso seja permitida a alteracao de um titulo retido
			If	lTitRetA
				//Antes de chamar a função para a geracao dos titulos do PCC (F050AlRtd2 + F050TxPCC) verificar necessidade da geracao
				SA2->(dbSeek(xFilial("SA2") + SE2->(E2_FORNECE + E2_LOJA)))
				SED->(dbSeek(xFilial("SED") + SE2->E2_NATUREZ))
				If SED->ED_CALCPIS == "S"  .AND. SA2->A2_RECPIS == "2" .OR. ;
				SED->ED_CALCCOF == "S" .AND. SA2->A2_RECCOFI == "2" .OR. ;
				SED->ED_CALCCSL == "S"  .and. SA2->A2_RECCSLL == "2"
					If M->E2_EMISSAO < dLastPcc .Or. lEmpPub
						F050AlRtd2(!lRetOutMod)
					EndIf
				EndIf
				//Caso seja permitida a alteracao de um titulo retentor ou aguardando retenção
			ElseIf  (SE2->E2_PRETPIS <>	"2" .Or. SE2->E2_PRETCOF <>	"2" .Or. SE2->E2_PRETCSL <>	"2")
				//Antes de chamar a função para a geracao dos titulos do PCC (F050GrRtr2 + F050TxPCC) verificar necessidade da geracao
				SA2->(dbSeek(xFilial("SA2") + SE2->(E2_FORNECE + E2_LOJA)))
				SED->(dbSeek(xFilial("SED") + SE2->E2_NATUREZ))
				If SED->ED_CALCPIS == "S"  .AND. SA2->A2_RECPIS == "2" .OR. ;
				SED->ED_CALCCOF == "S" .AND. SA2->A2_RECCOFI == "2" .OR. ;
				SED->ED_CALCCSL == "S"  .and. SA2->A2_RECCSLL == "2"
					If M->E2_EMISSAO < dLastPcc .Or. lEmpPub
						F050AlRtd2(!lRetOutMod)
					EndIf


				EndIf

			EndIf
		EndIf
	EndIf
EndIf

dbGoto(nRegSe2)
// Gera LP 511 somente quando NAO FOI EFETUADO DESDOBRAMENTO, caso contrario o LP ja foi gerado no desdobramento
If CtbInUse()  .And. SE2->E2_DESDOBR != "S" .And. lPadrao .And. Empty(SE2->E2_ARQRAT)
	// Contabiliza o rateio
	cSeq := Fa050GerLc( cPadrao,cLote, "FINA050", 3, , , NIL, cProcPCO, cItemPCO, cRecPag )
	If !Empty(cSeq)
			RecLock("SE2")
			Replace E2_ARQRAT		With cSeq
			SE2->(MsUnLock())
	EndIf
Endif 

// Integração com o SigaPfs
If lIntPFS .and. !(lResult := F050AtuPFS(4, SE2->(Recno())))
	DisarmTransaction()
Endif

//Motor de retenções
If lTemMR .And. _lGrvMR
	FinSetAPrc("FK2")
	FinGrvImp("1", nRegSE2, aImpos, SE2->E2_ORIGEM, (mv_par10 = 2 .And. mv_par06 = 2), {}, {}, .T., .F., .F., SE2->E2_EMISSAO, "", "")
	FinSetAPrc("")
EndIf

Return ( lResult ) // Function FA050AxAlt


/*/
±±³Fun‡…o	 ³Fa050Verim³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 17/12/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Procura se titulo de Imposto tem chque - na Exclusao		  ³±±
/*/
FuncTion Fa050VerImp()

LOCAL nRegSE2
Local lRet := .f.
Local cPrefixo
Local cNum
Local cSEST	:= GetMv("MV_SEST",,"")
Local cParcSES
Local cParcIRF
Local cParcINS
Local cParcISS
Local aParcelas
Local aNaturezas
Local nX
Local cTitPai	:= ""
Local aValPCC	:= {}
Local cTipo

dbSelectArea("SE2")
dbSetOrder(1)
nRegSE2:= Recno()

IF !(SE2->E2_TIPO $ MVISS+"/"+MVTAXA+"/"+MVTXA+"/"+MVINSS +"/" + "SES"+"/"+"INA")

	cPrefixo := SE2->E2_PREFIXO
	cNum		:= SE2->E2_NUM
	cTipo		:= SE2->E2_TIPO
	cTitPai		:= AllTrim( SE2->( E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA ) )
	cParcIRF	:= SE2->E2_PARCIR
	cParcISS	:= SE2->E2_PARCISS
	cParcINS	:= SE2->E2_PARCINS
	cParcSES 	:= SE2->E2_PARCSES

	If SE2->E2_ISS > 0
		If dbSeek(cFilial+cPrefixo+cNum+cParcISS+"ISS")
			While !Eof() .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
			cFilial+cPrefixo+cNum+cParcISS+MVISS
				IF AllTrim(E2_NATUREZ) = AllTrim(&(GetMv("MV_ISS")))
					If SE2->E2_IMPCHEQ == "S" .And. AllTrim( SE2->E2_TITPAI ) == cTitPai
						lRet := .T.
					EndIf
				EndIf
				dbSkip()
			EndDo
		EndIf
	EndIf

	If SE2->E2_INSS > 0
		If !lRet
			If dbSeek(cFilial+cPrefixo+cNum+cParcINS+IF(cTipo$MVPAGANT,"INA","INS"))
				While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
				cFilial+cPrefixo+cNum+cParcINS+IF(cTipo$MVPAGANT,"INA",MVINSS)
					IF AllTrim(E2_NATUREZ) = AllTrim(&(GetMv("MV_INSS")))
						If SE2->E2_IMPCHEQ == "S" .And. AllTrim( SE2->E2_TITPAI ) == cTitPai
							lRet := .T.
						EndIf
					EndIf
					dbSkip()
				EndDo
			EndIf
		EndIf
	EndIf

	If SE2->E2_SEST > 0
		If !lRet
			If dbSeek(cFilial+cPrefixo+cNum+cParcSES+"SES")
				While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
				cFilial+cPrefixo+cNum+cParcSES+"SES"
					IF AllTrim(E2_NATUREZ) = AllTrim(cSEST)
						If SE2->E2_IMPCHEQ == "S" .And. AllTrim( SE2->E2_TITPAI ) == cTitPai
							lRet := .T.
						EndIf
					EndIf
					dbSkip()
				EndDo
			EndIf
		EndIf
	EndIf

	If SE2->E2_IRRF > 0
		If !lRet
			If dbSeek(cFilial+cPrefixo+cNum+cParcIRF+"TX ")
				While !EOF() .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
				cFilial+cPrefixo+cNum+cParcIRF+MVTAXA
					IF E2_NATUREZ = &(GetMv("MV_IRF"))
						If SE2->E2_IMPCHEQ == "S" .And. AllTrim( SE2->E2_TITPAI ) == cTitPai
							lRet := .T.
						EndIf
					EndIf
					dbSkip()
				EndDo
			EndIf
		EndIf
	EndIf

	If !lRet
		aValPCC   := { SE2->E2_PIS    , SE2->E2_COFINS , SE2->E2_CSLL }
		aParcelas := { SE2->E2_PARCPIS, SE2->E2_PARCCOF, SE2->E2_PARCSLL }
		aNaturezas := { GetMv("MV_PISNAT"), GetMv("MV_COFINS"), GetMv("MV_CSLL") }
		For nX := 1 To Len(aParcelas)
			If aValPCC[nX] > 0
				If MsSeek(xFilial("SE2")+cPrefixo+cNum+aParcelas[nX]+MVTAXA)
					While !EOF() .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
					cFilial+cPrefixo+cNum+aParcelas[nX]+MVTAXA
						IF E2_NATUREZ = aNaturezas[nX]
							If SE2->E2_IMPCHEQ == "S" .And. AllTrim( SE2->E2_TITPAI ) == cTitPai
								lRet := .T.
							EndIf
						EndIf
						dbSkip()
					EndDo
				EndIf
			EndIf
		Next
	EndIf
Endif
dbSelectArea("SE2")
dbGoto(nRegSE2)
Return lRet

/*
±±³Fun‡„o    ³FA050MCPO ³ Autor ³ Fernando A. Bernardes ³ Data ³ 05/12/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Monta array com os campos que podera ser alterado          ³±±
±±³          ³ Criado para compatibilizacao com rotinas automaticas       ³±±
*/
Function fa050MCpo(nOpcAuto)
Local aCpos := {}
Local lSpbInUse := SpbInUse()
Local lPode := .F.
Local nX
Local lAltLib := .T.
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
Local lF050MCP := ExistBlock("F050MCP")
Local lIs48 As Logical
Local lContrRet := .T.

//Base IRPF na baixa
Local lBaseIRPF	:= F050BIRPF(2)
Local lBaseImp	 	:= F050BSIMP(2)	//Verifica a existência dos campos

DEFAULT nOpcAuto := 3 // Rotinas automaticas sao por default Inclusao.

//Permissao para altera
If GETMV("MV_CTLIPAG")
	lAltLib := (SuperGetMv("MV_ALTLIPG",.F.,"S") == "S")
	//Se nao permite a alteracao verifico a liberacao.
	If !lAltLib
		//Se o titulo nao foi liberado, libero a alteracao
		If	Empty(SE2->E2_DATALIB)
			lAltLib := .T.
		Endif
	Endif
Endif

//³ Titulos com baixa ou titulo de ISS ou IR ou INSS   ³
//³ ou SEST podem ter alterados apenas alguns campos.  ³

If cPaisLoc == "RUS"
	lIs48 := R604Is48(SE2->E2_FILIAL,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
Else
	lIs48 := .F.
Endif

If nOpcAuto != 3 .And.;
	(!Empty(SE2->E2_BAIXA) .or. SE2->E2_TIPO $ MVISS+"/"+MVTAXA+"/"+MVINSS+"/"+"SES"+"/"+MVTAXA+"/"+MVISS+"/"+MVTXA+"/"+"INA" .Or. ;
	"S" $ SE2->E2_LA .or. SE2->E2_IMPCHEQ == "S" .or. !lAltLib .or. "GPE" $ SE2->E2_ORIGEM .Or.;
	"S" $ SE2->E2_RATEIO .or. SE2->E2_FATURA = "NOTFAT" .or. F050BxImp() .or. ;
	(lContrRet .and. (SE2->E2_PRETPIS == "2" .or. SE2->E2_PRETCOF == "2" .or. SE2->E2_PRETCSL == "2")) .or. (lIs48))

	If SE2->E2_SALDO = 0
		Help(" ",1,"FA050BAIXA")
		Return
	EndIf

	//Habilita os campos para Alteração
	//Não devem ser alterados titulos originados do modulo Compras que tiverem retencao de pcc na emissao.
	//Conforme chamado TRGZT8, passou-se a permitir a alteracao da data de vencimento, porem, os impostos nao sao recalculados.
	If F050VerAlt(.F.) .Or. (SuperGetMv("MV_VENCIRF", .F.,"V") == "C" .AND. SE2->E2_IRRF > 0)
		AADD(aCpos,"E2_VENCTO")
		AADD(aCpos,"E2_VENCREA")
		lTitRetA 	:= .T.
	EndIF

	//³ Permite alterar os campos se o Titulo foi gerado:                                   ³
	//³ no Modulo de Transporte, datas de Vencimento do Titulo.                             ³
	//³ no Modulo de TOTVSGFE, datas de Vencimento do Titulo, Codigo de Barras e Historico. ³
	If nOpcAuto == 4 .And. AllTrim(SE2->E2_ORIGEM) $ 'SIGATMS/TOTVSGFE'
		aCpos := {}
		If AllTrim(SE2->E2_ORIGEM) $ "SIGATMS"
			AADD(aCpos,"E2_VENCTO")
			AADD(aCpos,"E2_VENCREA")
		ElseIf AllTrim(SE2->E2_ORIGEM) $ "TOTVSGFE"
			AADD(aCpos,"E2_VENCTO")
			AADD(aCpos,"E2_VENCREA")
			AADD(aCpos,"E2_CODBAR")
			AADD(aCpos,"E2_PORTADO") //Portador
			AADD(aCpos,"E2_MODSPB") //Mod.Pagto
			AADD(aCpos,"E2_LINDIG") //Linha Dig
			AADD(aCpos,"E2_FORBCO") //Banco For
			AADD(aCpos,"E2_FORAGE") //Agencia For
			AADD(aCpos,"E2_FAGEDV") //DV Agencia
			AADD(aCpos,"E2_FORCTA") //Conta For
			AADD(aCpos,"E2_FCTADV") //DV Conta
			AADD(aCpos,"E2_FORMPAG") //Form Pag
		EndIf

		AADD(aCpos,"E2_HIST")
		Return aCpos
	EndIf

	If nOpcAuto == 4 .And. cModulo<>"EIC" .AND. AllTrim(SE2->E2_ORIGEM) $ 'SIGAEIC'
		aCpos := {}
		//TDF - 04/08/2011 - Quando o título é "INV" não pode alterar os campos "E2_VENCTO" e "E2_VENCREA"
		If SE2->E2_TIPO <> "INV"
			AADD(aCpos,"E2_VENCTO")
			AADD(aCpos,"E2_VENCREA")
		EndIf
		AADD(aCpos,"E2_HIST")
		AADD(aCpos,"E2_PORTADO")
		AADD(aCpos,"E2_FLUXO")
		AADD(aCpos,"E2_DIRF")
		AADD(aCpos,"E2_CODBAR")

		Return aCpos
	EndIf

	AADD(aCpos,"E2_HIST")
	AADD(aCpos,"E2_INDICE")
	AADD(aCpos,"E2_OP")
	AADD(aCpos,"E2_PORTADO")
	AADD(aCpos,"E2_FLUXO")
	AADD(aCpos,"E2_VALJUR")
	AADD(aCpos,"E2_PORCJUR")
	AADD(aCpos,"E2_CODRET")
	If !F050BxImp()
		AADD(aCpos,"E2_DIRF")
	EndIf
	AADD(aCpos,"E2_CODBAR")
	AADD(aCpos,"E2_LINDIG")

	If lSpbInUse
		AADD(aCpos,"E2_MODSPB")
	Endif

	// So permite alterar a natureza, depois de contabilizado o titulo, se ela nao estiver
	// preenchida
	If SED->(MsSeek(xFilial("SED")+SE2->E2_NATUREZ))
		For nX := 1 To SED->(FCount())
			If "_CALC" $ SED->(FieldName(nX))
				lPode := !SED->(FieldGet(nX)) $ "1S" // So permite alterar se nao calcular impostos
				If !lPode // No primeiro campo que calcula impostos, nao permite alterar
					Exit
				Else
					// Não permite alterar em casos de titulos gerados por outros módulos que possuem impostos
					If !("FINA" $ Upper(SE2->E2_ORIGEM)) .And. ;
					((SE2->E2_IRRF+SE2->E2_ISS+SE2->E2_INSS+SE2->E2_SEST+SE2->E2_PIS+SE2->E2_COFINS+SE2->E2_CSLL) > 0)
						lPode := .F.
						Exit
					Endif
				Endif
			Endif
		Next
	Endif
	If Empty(SE2->E2_NATUREZ) .Or.;
	lPode
		Aadd(aCpos,"E2_NATUREZ")
	Endif
	//So permite alterar os campos abaixo se não houve baixa, ainda que tenha sido contabilizada
	//a inclusao do mesmo
	If Empty(SE2->E2_BAIXA)
		AADD(aCpos,"E2_ACRESC")
		AADD(aCpos,"E2_DECRESC")
	Endif

	If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN"
		AADD(aCpos,"E2_VARIAC")
	EndIf
	If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
		AADD(aCpos,"E2_PERIOD")
	EndIf

	If lBaseIrpf .and. lPode
		AADD(aCpos,"E2_BASEIRF")
	Endif
	AADD(aCpos,"E2_FORMPAG")
Else
	//³ Permite alterar os campos se o Titulo foi gerado:                                   ³
	//³ no Modulo de Transporte, datas de Vencimento do Titulo.                             ³
	//³ no Modulo de TOTVSGFE, datas de Vencimento do Titulo, Codigo de Barras e Historico. ³
	If nOpcAuto == 4 .And. AllTrim(SE2->E2_ORIGEM) $ 'SIGATMS/TOTVSGFE'
		aCpos := {}
		If AllTrim(SE2->E2_ORIGEM) $ "SIGATMS"
			AADD(aCpos,"E2_VENCTO")
			AADD(aCpos,"E2_VENCREA")
		ElseIf AllTrim(SE2->E2_ORIGEM) $ "TOTVSGFE"
			AADD(aCpos,"E2_VENCTO")
			AADD(aCpos,"E2_VENCREA")
			AADD(aCpos,"E2_CODBAR")
		EndIf

		AADD(aCpos,"E2_HIST")
		Return aCpos
	EndIf

	If nOpcAuto == 4 .And. cModulo<>"EIC" .AND. AllTrim(SE2->E2_ORIGEM) $ 'SIGAEIC'
		aCpos := {}
		//TDF - 04/08/2011 - Quando o título é "INV" não pode alterar os campos "E2_VENCTO" e "E2_VENCREA"
		If SE2->E2_TIPO <> "INV"
			AADD(aCpos,"E2_VENCTO")
			AADD(aCpos,"E2_VENCREA")
		EndIf
		AADD(aCpos,"E2_HIST")
		AADD(aCpos,"E2_PORTADO")
		AADD(aCpos,"E2_FLUXO")
		AADD(aCpos,"E2_DIRF")
		AADD(aCpos,"E2_CODBAR")
		Return aCpos
	EndIf

	AADD(aCpos,"E2_VENCTO")
	AADD(aCpos,"E2_VENCREA")
	AADD(aCpos,"E2_HIST")
	AADD(aCpos,"E2_INDICE")
	AADD(aCpos,"E2_OP")
	AADD(aCpos,"E2_PORTADO")
	AADD(aCpos,"E2_VALJUR")
	AADD(aCpos,"E2_PORCJUR")

	If AllTrim(SE2->E2_ORIGEM) <> 'JURCTORC' // Integração Controle Orçamentário SIGAPFS x SIGAFIN
		AADD(aCpos,"E2_VALOR")
	EndIf

	AADD(aCpos,"E2_IRRF")
	AADD(aCpos,"E2_ISS")
	AADD(aCpos,"E2_FLUXO")
	AADD(aCpos,"E2_INSS")
	AADD(aCpos,"E2_ACRESC")
	AADD(aCpos,"E2_DECRESC")
	AADD(aCpos,"E2_CODRET")
	AADD(aCpos,"E2_DIRF")
	AADD(aCpos,"E2_LINDIG")
	AADD(aCpos,"E2_FORMPAG")

	If SE2->E2_LA != "S"
		AADD( aCpos , "E2_CONTAD")
		AADD( aCpos , "E2_DEBITO")
		AADD( aCpos , "E2_CCUSTO")
		AADD( aCpos , "E2_CCD")
		AADD( aCpos , "E2_CCC")
		AADD( aCpos , "E2_ITEMD")
		AADD( aCpos , "E2_ITEMC")
		AADD( aCpos , "E2_CLVLDB")
		AADD( aCpos , "E2_CLVLCR")
	EndIf

	If lSpbInUse
		AADD(aCpos,"E2_MODSPB")
	Endif

	AADD(aCpos,"E2_CODBAR")

	If !lPccBaixa
		AAdd(aCpos, "E2_PIS")
		AAdd(aCpos, "E2_COFINS")
		AAdd(aCpos, "E2_CSLL")
	Endif

	If AllTrim(SE2->E2_ORIGEM) <> 'JURCTORC' // Integração Controle Orçamentário SIGAPFS x SIGAFIN
		// Nao permite alterar a natureza do titulo que reteve os impostos PIS/COFINS/CSL
		// do periodo, dele e de outros titulos.
		If SED->(MsSeek(xFilial("SED")+SE2->E2_NATUREZ))
			If !((SED->ED_CALCPIS == "S" .OR. SED->ED_CALCCSL == "S" .OR. SED->ED_CALCCOF == "S") .and. ;
			lContrRet .and. (SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL) > 0 .and. ;
			STR(SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL),17,2) != STR(SE2->(E2_PIS+E2_COFINS+E2_CSLL),17,2)))
				Aadd(aCpos,"E2_NATUREZ")
			Endif
		ElseIf Empty(SE2->E2_NATUREZ)
			Aadd(aCpos,"E2_NATUREZ")
		Endif
	Endif

	If lBaseIrpf
		AADD(aCpos,"E2_BASEIRF")
	Endif

	If lBaseImp
		AADD(aCpos,"E2_BASEIRF")
		AADD(aCpos,"E2_BASEPIS")
		AADD(aCpos,"E2_BASEINS")
		AADD(aCpos,"E2_BASEISS")
	Endif

EndIf
If cPaisLoc == "BRA"
	Aadd(aCpos,"E2_NUMPRO")
	Aadd(aCpos,"E2_INDPRO")
	Aadd(aCpos,"E2_FORBCO")
	Aadd(aCpos,"E2_FORAGE")
	Aadd(aCpos,"E2_FAGEDV")
	Aadd(aCpos,"E2_FORCTA")
	Aadd(aCpos,"E2_FCTADV")
	AADD(aCpos,"E2_DTAPUR")
	AADD(aCpos,"E2_RETINS")
Endif

If  SE2->( FieldPos( "E2_MSBLQD" ) )>0
	AADD(aCpos,"E2_MSBLQD")
EndIf

If  SE2->( FieldPos( "E2_MSBLQL" ) )>0
	AADD(aCpos,"E2_MSBLQL")
EndIf

If lF050MCP
	aCpos := ExecBlock("F050MCP",.F.,.F.,aCpos)
Endif
If cPaisLoc == "RUS"
	Aadd(aCpos,"E2_FORBCO")
	Aadd(aCpos,"E2_FORAGE")
	Aadd(aCpos,"E2_FORCTA")
Endif

If lRatMulNat .And. SE2->E2_MULTNAT == "2"
	AADD(aCpos, "E2_MULTNAT")
EndIf

If (SE2->E2_LA != "S") .and. Empty(SE2->E2_ARQRAT)
	AADD(aCpos,"E2_RATEIO")
Endif

Return aCpos

/*/
±±³Fun‡…o	 ³F050EscRat³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 16/05/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Escolhe se digita rateio ou escolhe pre-configurado  		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³F050EscRat( ExpC1,ExpC2,ExpC3 ) 							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA050,FINA100											  ³±±
/*/
Function F050EscRat(cPadrao,cProg,cLote)

Local oDlg1
Local oRadio
Local cCodRateio	:= CriaVar("CTJ_RATEIO")
Local nRadio		:= 0
Local nOpca 		:= 0
Local cHistorico 	:= CriaVar("CT2_HIST")
Local cSeq			:= ""
Local nIncAlt		:= 3
Local aRet			:= {} //variavel utilizada para o retorno do ponto de entrada F050RAUT
Local nOpRat		:= 1
Local aRet2			:= {}
Local lF050RAUT 	:= ExistBlock("F050RAUT")

Private cDebito	 	:= CriaVar("CT2_DEBITO")
Private cCredito 	:= CriaVar("CT2_CREDIT")

If !CtbInUse()
	Return
Endif

lF050Auto := IF(Type("lF050Auto") == "U", .F., lF050Auto)

If lF050TMP1
	aRet2 := ExecBlock("F050TMP1",.f.,.f.,{/*nTipo*/,cCodRateio,cProg,cPadrao,cDebito,cCredito,cHistorico,lF050Auto,nOpRat})
EndIf

IF ( (empty(aRet2).Or.(aRet2[2] >= 1)) .And. !lF050Auto )  //Indica deseja abrir tela de Opcoes de rateio para rateio customizado.

	nRadio	:= 1

	DEFINE MSDIALOG oDlg1 FROM  94,1 TO 350,310 TITLE OemToAnsi(STR0088) PIXEL // "Opcoes de Rateio"

	@ 10,17 Say OemToAnsi(STR0089) SIZE 150,7 OF oDlg1 PIXEL  // "Escolha como Ratear"

	@ 27,07 TO 82, 150 OF oDlg1  PIXEL

	@ 35,10 Radio 	oRadio 	VAR nRadio;
	ITEMS 	OemToAnsi(STR0090),;		// "Digitado"
	OemToAnsi(STR0091);			// "Pre-Configurado"
	3D SIZE 100,10 OF oDlg1 PIXEL;
	ON CHANGE 	If(nRadio = 2, (oRateio:SetFocus(), .T.),;
	(cCodRateio := Space(Len(cCodRateio)), .T.)) .And.;
	(CtbDigCta(cCodRateio, oSayDeb, oDebito, oSayCrd, oCredito), .T.)
	@ 60,10 Say 	OemToAnsi(STR0092) PIXEL
	@ 60,50 MSGET 	oRateio Var cCodRateio F3 "CTJ" Picture "@!";
	SIZE 070,10 OF oDLG1 PIXEL When nRadio = 2;
	Valid CtbDigCta(cCodRateio, oSayDeb, oDebito, oSayCrd, oCredito,, .T.) HASBUTTON
	@ 87,07 	Say oSayDeb Prompt STR0117 OF oDlg1 PIXEL //"Conta a Debito"
	oSayDeb:Disable()
	@ 85,50 	MSGET oDebito Var cDebito;
	F3 "CT1" Picture "@!" Valid Ctb105Cta(cDebito) SIZE 070,8 OF oDlg1 PIXEL HASBUTTON
	oDebito:Disable()

	@ 102,07	Say oSayCrd Prompt STR0118 OF oDlg1 PIXEL //"Conta a Credito"
	oSayCrd:Disable()
	@ 100,50 	MSGET oCredito Var cCredito;
	F3 "CT1" Picture "@!" Valid Ctb105Cta(cCredito) SIZE 070,8 OF oDlg1 PIXEL HASBUTTON
	oCredito:Disable()
	@ 115,07	Say STR0119 OF oDlg1 PIXEL //"Historico"
	@ 115,50  	MSGET oHistorico Var cHistorico;
	Picture PesqPict("CT2", "CT2_HIST") SIZE 100,8 OF oDlg1 PIXEL

	DEFINE SBUTTON oBtn FROM 098,120 TYPE 1 ENABLE OF oDlg1;
	ACTION  Fa050ValRat(nRadio, cCodRateio, oDlg1, cDebito, cCredito, @nOpca)

	ACTIVATE MSDIALOG oDlg1 CENTERED

Else
	nOpca := 1
EndIf

If nOpca == 1
	//O ponto de entrada F050RAUT recebe um array de tamanho 3 para alterar o conteudo das variaveis nRadio (Tipo de rateio), cCodRateio(Codigo do rateio), cHistorico (Historico do rateio), e atribui verdadeiro na variavel lRatAut para nao mostrar a tela de rateio.
	If lF050RAUT .and. lF050Auto
		aRet := ExecBlock("F050RAUT",.f.,.f.)
		If ValType(aRet) = "A" .And. Len(aRet) >= 5
			nRadio		:= aRet[1]
			cCodRateio	:= aRet[2]
			cHistorico	:= aRet[3]
			cDebito		:= aRet[4]
			cCredito		:= aRet[5]
			lRatAut		:= .T.
		EndIf
	ElseIf lF050Auto .and. type("aItensCTB")=="A" .AND. Len(aItensCTB) > 0
		nRadio      := 1
		lRatAut		:= .T.
	EndIf
	cDebito  := If(nRadio = 1, "", cDebito)
	cCredito := If(nRadio = 1, "", cCredito)
	If cProg == "FINA050"
		If SuperGetMv("MV_FIRATD",.T.,"1") == "1"
			nIncAlt	:= If(nRadio=2,2,3)
		EndIf
	ElseIf cProg == "FINA100"
		If SuperGetMv("MV_FIRATD",.T.,"1") == "1"
			nIncAlt	:= If(nRadio=2,2,3)
		EndIf
	Endif
	cSeq		:= CtbRatFin(cPadrao,cProg,cLote,nRadio,cCodRateio,nIncAlt,cDebito,cCredito,cHistorico)
ElseIf M->E2_RATEIO == "S"
	M->E2_RATEIO := "N"
EndIf

Return cSeq

/*/
±±³Fun‡…o	 ³CtbRatFin ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 11/05/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Rateio de Contas a Pagar - >            SIGACTB     		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³CtbDigRat( ExpC1,ExpC2,ExpC3 ) 							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA050,FINA100											  ³±±
/*/
Function CtbRatFin(cPadrao,cProg,cLote,nTipo,cCodRateio,nOpc,cDebito,cCredito,cHistorico,nHdlPrv,nTotal,aFlagCTB, cProcPCO, cItemPCO, cRecPag )
Local lPanelFin 	:= IsPanelFin()
Local aCampos
Local aSaveArea 	:= GetArea()
Local aRotAnt		:= NIL			// Armazena conteudo da aRotina
Local aTamQtd		:= TAMSX3("CTJ_QTDTOT")
Local aAltera		:= {}
Local cArq
Local cSeq			:= ""
Local nTamQtd		:= aTamQtd[1]
Local oDlg
Local oGetDb
Local lRatAut		:= .F.
Local nInss			:= 0
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)
Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local aSize 		:= {}
Local oPanel
Local oTimer
Local oPanel2
Local nTimeOut  	:= SuperGetMv("MV_FATOUT",,900)*1000 	// Estabelece 15 minutos para que o usuarios selecione os titulos a faturar
Local nTimeMsg  	:= SuperGetMv("MV_MSGTIME",,120)*1000 	// Estabelece 02 minutos para exibir a mensagem para o usuário
// informando que a tela fechará automaticamente em XX minutos
Local aRecCV4 		:= {}
Local nOpRat		:= 2
Local aRet			:= {}

Local lVisRateio	:= ( nTipo == 5 .And. AllTrim( Upper( cProg ) ) == "FINA050" )
Local nTelaRat		:= 1
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
Local lTempBloq	:= .F.
Local nValorTela  	:= 0
Local lF050RAUT 	:= ExistBlock("F050RAUT")
Local lUsaRatMem	:= .F.

Default nOpc		:= 3
Default nHdlPrv 	:= 0
Default nTotal    	:= 0

DEFAULT aFlagCTB 	:= {}
DEFAULT cProcPCO 	:= "000021"
DEFAULT cItemPCO 	:= "01"
DEFAULT cRecPag  	:= "P"

Private aTela		:= {}
Private aGets		:= {}
Private aHeader		:= {}

// Obs: este array aRotina foi inserido apenas para permitir o
// funcionamento das rotinas internas da MSGETDB
If Type("aRotina") != "A"
	Private aRotina := { { "aRotina Falso", "AxInclui", 0 , nOpc} }
Else
	aRotAnt		:= aClone(aRotina)
Endif

Private cPrograma	:= cProg
Private nValRat	:= 0
Private oValRat
Private nTPRateio := nTipo // Tipo de rateio para que seja feito seu tratamento na validação das entidades contabéis adicionais

Ctb120IniVar()

lF100Auto := If(Type('lF100Auto') == "U", .F.,lF100Auto)
lF050Auto := IF(Type("lF050Auto") == "U", .F., lF050Auto)

lRatAut := Iif(ProcName(1)=="FA370PROCESSA",.F.,Iif(lF050Auto .OR. lF100Auto,.T.,.F.))

// Cria aHeader
aCampos := F050HeadCT(cPadrao,cProg,@aAltera,nTipo)

// Caso o arquivo exista, o sistema apaga e reconstroi vazio.
If Select("TMP") > 0 .and. nOpc#5
	If (( type("aItensCTB")=="A" .and. Len(aItensCTB) > 0 ) .or. (lF050Auto .and. lF050RAUT)) .Or. ( cProg $ "FINA370" .and. lF050TMP1 .and. Len(aCampos) > 0 ) // Criar a TMP CTJ para não ocorrer error.log na contabilização Fina370 com o PE.
		F050Cria(aCampos)
	EndIf
	If !lF050TMP1 .and. !lF050Auto
		If nOpc != 3 .Or. (nOpc == 3 .And. !(lUsaRatMem := MsgYesNo(STR0132,STR0115))) // "Existe um rateio na memória. Deseja utilizá-lo?"#"Atenção"//Apaga TMP1
			F050Cria(aCampos)
		Endif
	EndIf
Else
	If nOpc#5 //Quando for exclusão a temporaria já estará criada
		F050Cria(aCampos) //Cria TMP1
	ElseIf nOpc == 5 .AND. AllTrim( Upper( cProg ) ) == "FINA100"
		F050Cria(aCampos) //Cria TMP1
	Endif
EndIf

//Indica se rateio Customizado, passando o lF050AUTO para identificação de rotina automática
IF  lF050TMP1 .And. TMP->(RecCount()) <= 0 .And. !lVisRateio
	aRet := ExecBlock("F050TMP1",.f.,.f.,{nTipo,cCodRateio,cProg,cPadrao,cDebito,cCredito,cHistorico,lF050Auto,nOpRat})
	If (ValType(aRet)=="A")
		nValRat  := aRet[1]
		nTelaRat := aRet[2]
	EndIf
	If nValRat == 0
		nValRat := F050Carr(nTipo,cCodRateio,cProg,cPadrao,cDebito,cCredito,cHistorico,aRecCV4,aCampos)
	EndIf
	IIF(lF050Auto ,lRatAut := .T., )
ElseIf !lUsaRatMem
	nValRat := F050Carr(nTipo,cCodRateio,cProg,cPadrao,cDebito,cCredito,cHistorico,aRecCV4,aCampos)
	IIF(lF050Auto,lRatAut := .T., )
Endif

//³ Mostra o corpo da rateio 						   ³
nOpca := 0
If cProg $ "FINA750/FINA050"
	If TMP->(Eof()) .And. TMP->CTJ_PERCEN ==0 .And. TMP->CTJ_VALOR == 0 .And. cProg $ "FINA050" //evitar error log caso seja inf primeiro a cta de deb ou cred
		Reclock("TMP", .T.)
		lTempBloq := .T.
	Endif
	nInss := M->E2_INSS
	IF !lInssBx .And. SED->ED_DEDINSS == "2"  //desconta o INSS do principal
		nInss := 0
	Endif

	If	!lRatAut .And. ;
	((nOpc !=5) .Or. (mv_par08 == 1 .And. nOpc == 5)) .And. ; //Se mostra tela de rateio na exclusao
	nTelaRat > 0

		aSize := MSADVSIZE()

		DEFINE MSDIALOG oDlg TITLE STR0037 From aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL//"Rateios"
		oTimer:= TTimer():New((nTimeOut-nTimeMsg),{|| MsgTimer(nTimeMsg,oDlg) },oDlg) // Ativa timer
		oTimer:Activate()
		oDlg:lMaximized := .T.

		//TOPO DA TELA
		//---
		oPanel := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,20,20,.T.,.T. )
		oPanel:Align := CONTROL_ALIGN_TOP

		@ 002 , 002		Say OemToAnsi(STR0021) + M->E2_FORNECE		FONT oDlg:oFont	OF oPanel PIXEL	// "Fornecedor: "
		@ 002 , 080		Say OemToAnsi(STR0022) + M->E2_LOJA			FONT oDlg:oFont	OF oPanel PIXEL	// "Loja: "
		@ 002 , 128  	Say OemToAnsi(STR0038) + M->E2_PREFIXO		FONT oDlg:oFont	OF oPanel PIXEL	// "Prefixo: "
		@ 002 , 175   	Say OemToAnsi(STR0039) + M->E2_NUM			FONT oDlg:oFont	OF oPanel PIXEL	// "N£mero T¡tulo: "
		@ 002 , 273   	Say OemToAnsi(STR0040) + M->E2_PARCELA		FONT oDlg:oFont	OF oPanel PIXEL	// "Parcela: "


		//GETDB - DIGITACAO
		//---
		oGetDB := 	MSGetDB():New(034,002,400,315,nOpc,"Fa050LinCT",{|| Fa050TudCT(nOpc,cPadrao,cProg,nTipo) },;
		"",.T.,aAltera,,.f.,,"TMP",,,.F.,,,,"FIN050DEL")

		n := TMP->(Reccount())
		oGetDB:ForceRefresh()
		oGetDB:lNewLine := .F.
		oGetDB:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
		//---

		//Se for Rateio digitado nao ira mostrar a quantidade total.
		oPanel2 := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,20,20,.T.,.T. )

		@  001, 005 To  018,495 OF oPanel2 PIXEL

		nValorTela := Iif(mv_par06==1,;
		If(M->E2_MOEDA > 1 ,M->E2_VLCRUZ,M->E2_VALOR)+If(lIRPFBaixa,0,M->E2_IRRF)+If(!lCalcIssBx,M->E2_ISS,0)+If(!lInssBx,M->E2_INSS,0)+M->E2_RETENC+M->E2_SEST+IIF(lPccBaixa,0,M->E2_PIS+M->E2_COFINS+M->E2_CSLL),;
		M->E2_VALOR)
		If mv_par06 == 1 .and. M->E2_MOEDA > 1
			nValorTela := Round(NoRound(xMoeda(nValorTela,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
		EndIf

		If nTipo == 1
			@ 005 , 010	Say OemToAnsi(STR0041)	FONT oDlg:oFont OF oPanel2 PIXEL  		// "Valor T¡tulo: "
			@ 005 , 042	Say nValorTela Picture PesqPict("SE2","E2_VALOR",17) 					FONT oDlg:oFont ;
			COLOR CLR_HBLUE OF oPanel2 PIXEL
		Else
			@ 005 , 010	Say STR0122	FONT oDlg:oFont OF oPanel2 PIXEL  		// "Quant. Total "
			@ 005 , 042	Say nQtdTot Picture PesqPict("CTJ","CTJ_QTDTOT",nTamQtd) FONT oDlg:oFont COLOR CLR_HBLUE OF oPanel2 PIXEL
			@ 005 , 130	Say OemToAnsi(STR0041)	FONT oDlg:oFont OF oPanel2 PIXEL 		// "Valor T¡tulo: "
			@ 005 , 162	Say nValorTela Picture PesqPict("SE2","E2_VALOR",17) FONT oDlg:oFont COLOR CLR_HBLUE OF oPanel2 PIXEL
		EndIf
		If nOpc <> 5	//Se for Exclusao de titulo nao exibir o valor rateado
			@ 005 , 238	Say OemToAnsi(STR0042) FONT oDlg:oFont OF oPanel2 PIXEL 		// "Valor Rateio: "
			@ 005 , 270	Say oValRat VAR nValRat Picture PesqPict("CTJ","CTJ_VALOR",17)	FONT oDlg:oFont COLOR CLR_HBLUE OF oPanel2 PIXEL
		EndIf

		If lPanelFin  //Chamado pelo Painel Financeiro
			ACTIVATE MSDIALOG oDlg ON INIT (FaMyBar(oDlg,;
			{||nOpca:=1,if(nOpc = 2 .Or. fa050TudCT(nOpc,cPadrao,cProg,nTipo),oDlg:End(),nOpca := 0)},;
			{||nOpca:=2,fa050DelRat(),oDlg:End()}), oPanel2:Align := CONTROL_ALIGN_BOTTOM)
		Else
			ACTIVATE MSDIALOG oDlg ON INIT (EnchoiceBar(oDlg,;
			{||nOpca:=1,if(nOpc = 2 .Or. fa050TudCT(nOpc,cPadrao,cProg,nTipo,oGetDB),oDlg:End(),nOpca := 0)},;
			{||nOpca:=2,fa050DelRat(),oDlg:End()}), oPanel2:Align := CONTROL_ALIGN_BOTTOM)
		Endif
	Else
		nOpca :=1
	Endif
	If lTempBloq
		TMP->(MsUnlock())
		lTempBloq := .F.
	EndIf

	If nOpca == 2 .And. M->E2_RATEIO == "S"
		M->E2_RATEIO := "N"
	EndIf
ElseIf cProg == "FINA100"
	If !lRatAut
		aSize := MSADVSIZE()

		DEFINE MSDIALOG oDlg TITLE STR0037 From aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL//"Rateios"
		oTimer:= TTimer():New((nTimeOut-nTimeMsg),{|| MsgTimer(nTimeMsg,oDlg) },oDlg) // Ativa timer
		oTimer:Activate()
		oDlg:lMaximized := .T.

		//TOPO DA TELA
		//---
		oPanel := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,25,25,.T.,.T. )
		oPanel:Align := CONTROL_ALIGN_TOP

		@ 001,005 To  018,495 OF oPanel PIXEL
		@ 008,010 	SAY OemToAnsi(STR0043) + DtoC(M->E5_DATA)  FONT oDlg:oFont OF oPanel PIXEL	// "Data: "
		@ 008,190	SAY OemToAnsi(STR0044) + M->E5_DOCUMEN FONT oDlg:oFont OF oPanel PIXEL  		//"Doc.: "

		If nTipo == 1
			oGetDB := 	MSGetDB():New(034,005,400,315,nOpc,"Fa050LinCT",{|| Fa050TudCT(nOpc,cPadrao,cProg,nTipo) },;
			"",.T.,aAltera,,.f.,,"TMP",,,EMPTY(TMP->(RECCOUNT())),,,,"FIN050DEL")
		Else
			oGetDB := 	MSGetDB():New(034,005,400,315,nOpc,"Fa050LinCT",{|| Fa050TudCT(nOpc,cPadrao,cProg,nTipo) },;
			"",.T.,aAltera,,.f.,,"TMP",,,.F.,,,,"FIN050DEL")
		EndIf

		n := TMP->(Reccount())
		oGetDB:ForceRefresh()
		oGetDB:lNewLine := .F.
		oGetDB:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

		//---
		oPanel2 := TPanel():New(0,0,'',oDlg, oDlg:oFont, .T., .T.,, ,30,30,.T.,.T. )
		IF !lPanelFin
			oPanel2:Align := CONTROL_ALIGN_BOTTOM
		Endif


		//RODAPE
		//---
		//Se for Rateio digitado nao ira mostrar a quantidade total.
		@ 001, 005 To  018,495 OF oPanel2 PIXEL
		If nTipo == 1
			@ 004 , 010 	Say OemToAnsi(STR0041)	FONT oDlg:oFont OF oPanel2 PIXEL  		// "Valor T¡tulo: "
			@ 004 , 042 	Say M->E5_VALOR			Picture PesqPict("SE5","E5_VALOR",17) 		FONT oDlg:oFont ;
			COLOR CLR_HBLUE OF oPanel2 PIXEL
		Else
			@ 004 , 010		Say STR0122    FONT oDlg:oFont OF oPanel2 PIXEL  		// "Quant. Total "
			@ 004 , 042 	Say nQtdTot Picture PesqPict("CTJ","CTJ_QTDTOT",nTamQtd) FONT oDlg:oFont COLOR CLR_HBLUE OF oPanel2 PIXEL
			@ 004 , 130 	Say OemToAnsi(STR0041)	FONT oDlg:oFont OF oPanel2 PIXEL // "Valor T¡tulo: "
			@ 004 , 162 	Say M->E5_VALOR	Picture PesqPict("SE5","E5_VALOR",17) 	FONT oDlg:oFont ;
			COLOR CLR_HBLUE OF oPanel2 PIXEL
		EndIf
		If nOpc <> 5	//Se for Exclusao de titulo nao exibir o valor rateado
			@ 004 , 238 	Say OemToAnsi(STR0042)	FONT oDlg:oFont OF oPanel2 PIXEL 		// "Valor Rateio: "
			@ 004 , 270  	Say oValRat VAR nValRat Picture PesqPict("CTJ","CTJ_VALOR",17)	FONT oDlg:oFont COLOR CLR_HBLUE OF oPanel2 PIXEL
		EndIf

		If lPanelFin  //Chamado pelo Painel Financeiro
			ACTIVATE MSDIALOG oDlg ON INIT (FaMyBar(oDlg,;
			{||nOpca:=1,if(nOpc = 2 .Or. fa050TudCT(nOpc,cPadrao,cProg,nTipo,oGetDB,.T.),oDlg:End(),nOpca := 0)},;
			{||nOpca:=2, fa050DelRat(),oDlg:End()}),oPanel2:Align := CONTROL_ALIGN_BOTTOM)
		Else
			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,;
			{||nOpca:=1,if(nOpc = 2 .Or. fa050TudCT(nOpc,cPadrao,cProg,nTipo,oGetDB,.T.),oDlg:End(),nOpca := 0)},;
			{||nOpca:=2, fa050DelRat(),oDlg:End()})
		Endif
	Else
		nOpca :=1
	EndIf
ElseIf cProg == "FINA370"

	nOpca := 1
	nOpc  := If(cPadrao $ "516/517",NIL,nOpc)

EndIf

If (nOpca == 1 .And. nOpc <> 2 .And. cPadrao $ "511/512/557/558") .Or. (cPadrao $ "516/517" .And. cProg == "FINA370")
	cSeq := Fa050GerLc( cPadrao,cLote, cPrograma, If(nTipo=2,3,nOpc), @nHdlPrv, @nTotal, @aFlagCTB, cProcPCO, cItemPCO, cRecPag, aRecCV4 )
Endif

aRotina := aClone(aRotAnt)

RestArea(aSaveArea)

Return cSeq

/*/
±±³Program   ³F050Headct³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Monta aHeader                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Matriz com campos alteraveis                       ³±±
/*/
Function F050HeadCT(cPadrao,cProg,aAltera,nTipo)

Local aSaveArea:= GetArea()
Local aCampos	:= {}
Local aFora		:= {	"CTJ_FILIAL", "CTJ_RATEIO","CTJ_DESC","CTJ_MOEDLC","CTJ_TPSALD",;
"CTJ_SEQUEN", "CTJ_QTDTOT"}

Local lConta	:= Iif(cPrograma$"FINA050/FINA100" .And. mv_par03==2,.f.,.t.)		// Nao considera contas no rateio -> mv_par03 == 2
Local lCusto	:= CtbMovSaldo("CTT")
Local lItem	 	:= CtbMovSaldo("CTD")
Local lCLVL	 	:= CtbMovSaldo("CTH")
Local lMovEnt05 := CtbMovSaldo("CT0",,'05')
Local lMovEnt06 := CtbMovSaldo("CT0",,'06')
Local lMovEnt07 := CtbMovSaldo("CT0",,'07')
Local lMovEnt08 := CtbMovSaldo("CT0",,'08')
Local lMovEnt09 := CtbMovSaldo("CT0",,'09')

Local nPos

PRIVATE nUsado := 0
// Verificação de quais entidades estão o saldo controlado no contabilidade gerencial
If !lConta
	Aadd(aFora,"CTJ_DEBITO")
	Aadd(aFora,"CTJ_CREDIT")
EndIf
If !lCusto
	Aadd(aFora,"CTJ_CCD")
	Aadd(aFora,"CTJ_CCC")
EndIf
If !lItem
	Aadd(aFora,"CTJ_ITEMD")
	Aadd(aFora,"CTJ_ITEMC")
EndIf
If !lCLVL
	Aadd(aFora,"CTJ_CLVLDB")
	Aadd(aFora,"CTJ_CLVLCR")
EndIf

If !lMovEnt05
	Aadd(aFora,"CTJ_EC05DB")
	Aadd(aFora,"CTJ_EC05CR")
EndIf

If !lMovEnt06
	Aadd(aFora,"CTJ_EC06DB")
	Aadd(aFora,"CTJ_EC06CR")
EndIf

If !lMovEnt07
	Aadd(aFora,"CTJ_EC07DB")
	Aadd(aFora,"CTJ_EC07CR")
EndIf

If !lMovEnt08
	Aadd(aFora,"CTJ_EC08DB")
	Aadd(aFora,"CTJ_EC08CR")
EndIf

If !lMovEnt09
	Aadd(aFora,"CTJ_EC09DB")
	Aadd(aFora,"CTJ_EC09CR")
EndIf

//Se foi escolhido Rateio Digitado ou Pre-configurado, nao ira mostrar o campo de Quantidade Distribuida (CTJ_QTDDIS).
If nTipo == 1
	Aadd(aFora,"CTJ_QTDDIS")
EndIf

dbSelectArea("SX3")
SX3->(dbSetOrder(1)) // Tabela
SX3->(dbSeek("CTJ"))
While SX3->(!EOF() .And. (X3_ARQUIVO == "CTJ"))
	If Ascan(aFora,TRIM(X3_CAMPO)) <= 0
		nUsado++
		AADD(aHeader,{ TRIM(X3Titulo()), X3_CAMPO, X3_PICTURE,;
		X3_TAMANHO, X3_DECIMAL, X3_VALID,;
		X3_USADO, X3_TIPO, "TMP", X3_CONTEXT } )
		AADD(aCampos, { SX3->X3_CAMPO, SX3->X3_TIPO, SX3->X3_TAMANHO,;
		SX3->X3_DECIMAL } )
		If Alltrim(x3_campo) <> "CTJ_QTDDIS"
			Aadd(aAltera,Trim(X3_CAMPO))
		EndIf
	EndIf
	SX3->(dbSkip())
EndDO
Aadd(aCampos,{"CTJ_FLAG","L",1,0})

// Carrega validacoes para esta tela
nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_PERCEN"})
aHeader[nPos][6] := "CT050CALCP('"+cPadrao+"','"+cProg+"','"+Str(nTipo,1)+"')"
nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_VALOR"})
aHeader[nPos][6] := "CT050CALCV('"+cPadrao+"','"+cProg+"','"+Str(nTipo,1)+"')"
If lConta
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_DEBITO"})
	aHeader[nPos][6] := "Vazio() .Or. Ctb105Cta()"
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_CREDIT"})
	aHeader[nPos][6] := "Vazio() .Or. Ctb105Cta()"
EndIf
If lCusto
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_CCD"})
	aHeader[nPos][6] := "Vazio() .Or. Ctb105Cc()"
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_CCC"})
	aHeader[nPos][6] := "Vazio() .Or. Ctb105Cc()"
EndIf

If lItem
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_ITEMD"})
	aHeader[nPos][6] := "Vazio() .Or. Ctb105Item()"
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_ITEMC"})
	aHeader[nPos][6] := "Vazio() .Or. Ctb105Item()"
EndIf

If lClVl
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_CLVLDB"})
	aHeader[nPos][6] := "Vazio() .Or. Ctb105ClVl()"
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_CLVLCR"})
	aHeader[nPos][6] := "Vazio() .Or. Ctb105ClVl()"
EndIf

If lMovEnt05
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_EC05DB"})
	aHeader[nPos][6] := "(Vazio().Or.Ctb120Form())"

	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_EC05CR"})
	aHeader[nPos][6] := "(Vazio().Or.Ctb120Form())"
EndIf

If lMovEnt06
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_EC06DB"})
	aHeader[nPos][6] := "(Vazio().Or.Ctb120Form()) "

	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_EC06CR"})
	aHeader[nPos][6] := "(Vazio().Or.Ctb120Form()) "
EndIf

If lMovEnt07
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_EC07DB"})
	aHeader[nPos][6] := "(Vazio().Or.Ctb120Form()) "

	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_EC07CR"})
	aHeader[nPos][6] := "(Vazio().Or.Ctb120Form()) "
EndIf

If lMovEnt08
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_EC08DB"})
	aHeader[nPos][6] := "(Vazio().Or.Ctb120Form()) "

	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_EC08CR"})
	aHeader[nPos][6] := "(Vazio().Or.Ctb120Form()) "
EndIf

If lMovEnt09
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_EC09DB"})
	aHeader[nPos][6] := "(Vazio().Or.Ctb120Form()) "

	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_EC09CR"})
	aHeader[nPos][6] := "(Vazio().Or.Ctb120Form()) "
EndIf

//Ponto de Entrada para inclusao de novos campos.
If lF050HEAD
	aCampos := 	ExecBlock("F050HEAD",.f.,.f.,{aCampos})
EndIf

RestArea(aSaveArea)

Return aCampos

/*/
±±³Program   ³F050Cria  ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cria arquivo temporario para GetDb                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Matriz com campos a serem criados no TMP1           ³±±
/*/
Function F050Cria(aCampos)

Local aSaveArea := GetArea()

If Select("TMP")>0
	DbSelectArea( "TMP" )
	DbCloseArea()
Endif

//Deleta a tabela temporária no banco, caso já exista
If(_oFINA0501 <> NIL)
	_oFINA0501:Delete()
	_oFINA0501 := NIL
EndIf

//Cria tabela temporária no banco de dados (alias TMP)
_oFINA0501 := FwTemporaryTable():New("TMP")
_oFINA0501:SetFields(aCampos)
_oFINA0501:AddIndex("1", {Alltrim( aCampos[1][1] )})
_oFINA0501:Create()

dbSelectArea( "TMP" )
dbSetOrder(0) //ordem natural de inserção

RestArea(aSaveArea)

Return

/*/
±±³Program   ³F050Carr  ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Carrega dados para GetDB                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Opcao do Menu                                      ³±±
/*/
Function F050Carr(nTipo,cCodRateio,cProg,cPadrao,cDebito,cCredito,cHistorico,aRecCV4,aCampos)

Local aSaveArea	:= GetArea()
Local cArqRat
Local nValor
Local nRegCTJ
Local lConta	:= Iif(cProg$"FINA050/FINA100" .And. mv_par03==2,.f.,.t.)		// Nao considera contas no rateio -> mv_par03 == 2
Local lCusto	:= CtbMovSaldo("CTT")
Local lItem	 	:= CtbMovSaldo("CTD")
Local lCLVL	 	:= CtbMovSaldo("CTH")
Local nTipoRat	:= 1 // Tipo de rateio, 1=Bruto, 2=Liquido
Local nCont := 0
Local nInss		:= 0
Local nRecCTJ
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)
Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local nI      := 0
Local nY 	  := 0
Local nPosCpo := 0
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
Local lF50CTMP := ExistBlock("F50CARTMP1")
Local lF50CTP1 := ExistBlock("F50CTMP1")

Default aRecCV4 := {}
Default aCampos := {}

If cProg == "FINA050" .Or. cPadrao $ "511#512"
	If !lInssBx
		nInss	:= M->E2_INSS
		IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
			nInss := 0
		Endif
	Endif

	If cProg == "FINA050"
		nTipoRat	:= mv_par06 // Esta pergunta faz parte do grupo de perguntas do FIN050, mas
		// Nao faz parte do grupo do FIN370 ou AFI100, de onde tambem e
		// utilizada esta funcao, atraves da CtbRatFin.
	Endif
	cArqRat := SE2->E2_ARQRAT
	//soma os impostos da emissao em moeda 1
	nValor := Iif(nTipoRat == 1,;
	If(M->E2_MOEDA > 1,M->E2_VLCRUZ,M->E2_VALOR)+If(lIRPFBaixa,0,M->E2_IRRF)+If(!lCalcIssBx,M->E2_ISS,0)+nInss+M->E2_RETENC+M->E2_SEST+IIF(lPccBaixa,0,M->E2_PIS+M->E2_COFINS+M->E2_CSLL),;
	M->E2_VALOR)

	If nTipoRat == 1 .and. M->E2_MOEDA > 1
		//converte na moeda do titulo
		nValor := Round(NoRound(xMoeda(nValor,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
	EndIf
Else
	nValor	:= M->E5_VALOR
	cArqRat	:= M->E5_ARQRAT
	if Empty(cArqRat)
		cArqRat := FK8->FK8_ARQRAT
	Endif
EndIf
nValRat		:= 0
If nTipo == 1					// Usuario vai digitar o Rateio -> Inclusao
	dbSelectArea("TMP")		// Vale somente para digitacao
	DbGotop()
	If type("aItensCTB")=="A" .and. Len(aItensCTB) > 0 //.and. lF050Auto
		For nI:= 1 To Len(aItensCTB)
			dbSelectArea("TMP")
			dbAppend()
			For nY:= 1 To Len(aCampos)
				If ( nPosCpo := Ascan( aItensCTB[nI], { | x | AllTrim(x[ 1 ]) == AllTrim(aCampos[nY,1]) }) ) > 0
					TMP->&( Alltrim(aItensCTB[nI,nPosCpo,1]) ) := aItensCTB[nI,nPosCpo,2]
				EndIf
			Next nY
		Next nI
	EndIf
ElseIf nTipo == 2				// Rateio ja cadastrado -> Inclusao
	dbSelectArea("CTJ")			// Vale somente para digitacao
	dbSetOrder(1)
	dbSeek(xFilial()+cCodRateio)
	nRegCtj := Recno()
	nQtdTot	:= CTJ->CTJ_QTDTOT
	While !Eof() .And. CTJ->CTJ_FILIAL == xFilial() .And. CTJ->CTJ_RATEIO == cCodRateio
		dbSelectArea("TMP")
		dbAppend()
		For nCont := 1 To Len(aHeader)
			If (aHeader[nCont][08] <> "M" .And. aHeader[nCont][10] <> "V" )
				// Verifica se o campo existe na estrutura do CTJ
				TMP->(FieldPut(FieldPos(aHeader[nCont][2]),;
				(CTJ->(FieldGet(FieldPos(aHeader[nCont][2]))))))
			EndIf
		Next nCont
		TMP->CTJ_FLAG 		:= .F.

		If (! Empty(cDebito) .Or. ! Empty(cCredito)) .And. lConta

			TMP->CTJ_DEBITO := cDebito
			TMP->CTJ_CREDIT := cCredito
			If ! Empty(cDebito)
				CT1->(MsSeek(xFilial("CT1") + cDebito))
				If CT1->CT1_ACCUST = "2" .And. lCusto
					TMP->CTJ_CCD := ""
				Endif
				If CT1->CT1_ACITEM = "2" .And. lItem
					TMP->CTJ_ITEMD	:= ""
				Endif
				If CT1->CT1_ACCLVL = "2" .And. lCLVL
					TMP->CTJ_CLVLDB	:= ""
				Endif
			Endif

			If ! Empty(cCredito)
				CT1->(MsSeek(xFilial("CT1") + cCredito))
				If CT1->CT1_ACCUST = "2" .And. lCusto
					TMP->CTJ_CCC	:= ""
				Endif
				If CT1->CT1_ACITEM = "2" .And. lItem
					TMP->CTJ_ITEMC	:= ""
				Endif
				If CT1->CT1_ACCLVL = "2" .And. lCLVL
					TMP->CTJ_CLVLCR	:= ""
				Endif
			Endif
		Endif

		If ! Empty(cHistorico)
			TMP->CTJ_HIST := cHistorico
		Endif
		TMP->CTJ_VALOR		:= nValor * (TMP->CTJ_PERCEN/100)
		nValRat += TMP->CTJ_VALOR
		//ponto de entrada para cada linha da CTJ
		If lF50CTMP
			nRecCTJ := CTJ->( Recno() )
			ExecBlock("F50CARTMP1", .F., .F., {cPadrao,nTipo,cProg})
			CTJ->( dbGoto(nRecCTJ) )
		Endif
		dbSelectArea("CTJ")
		dbSkip()
	EndDo
	// Ajusta a diferença do rateio na ultima linha
	TMP->CTJ_VALOR	+= (nValor - nValRat)
	nValRat 			 	+= (nValor - nValRat)
	dbGoto(nRegCTJ)
ElseIf nTipo == 3		// Exlusao do rateio
	LeDadosCV4(cArqRat,lConta,lCusto,lItem,lClVl,@nValRat, cPadrao, nValor, .T., aRecCV4)
ElseIf nTipo == 4		//Contabilizacao Off-Line do Rateio
	LeDadosCV4(cArqRat,lConta,lCusto,lItem,lClVl,@nValRat, cPadrao, nValor, .F.)
ElseIf nTipo == 5					   // Visualizacao do rateio
	LeDadosCV4(cCodRateio,lConta,lCusto,lItem,lClVl,@nValRat, cPadrao, nValor, .F.)
Endif
If lF50CTP1
	ExecBlock("F50CTMP1", .F., .F., {cPadrao,nTipo,cProg})
Endif

dbSelectArea("TMP")
dbGoTop()

RestArea(aSaveArea)

Return nValRat

/*/
±±³Fun‡…o	 ³Ct050CalcP³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 15/05/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calcula o porcentual digitado para rateio no Centro Custo   ³±±
/*/
Function Ct050CalcP(cPadrao,cProg,cTipo)

Local aSaveArea	:= GetArea()
Local lRet			:= .T.
Local nPercentual := M->CTJ_PERCEN
Local nReg
Local nValor
Local nTipoRat	:= 1 // Tipo de rateio, 1=Bruto, 2=Liquido
Local nInss := 0
Local nTotPerc := 0
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
Local nDecVlr	:= TamSX3("CTJ_VALOR")[2]

Local	lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)

Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

If cProg == "FINA050" .Or. cPadrao $ "511#512"
	If !lInssBx
		nInss := M->E2_INSS
		IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
			nInss := 0
		Endif
	Endif
	If cProg == "FINA050"
		nTipoRat	:= mv_par06 // Esta pergunta faz parte do grupo de perguntas do FIN050, mas
		// Nao faz parte do grupo do FIN370 ou AFI100, de onde tambem e
		// utilizada esta funcao, atraves da CtbRatFin.
	Endif
	nValor := Iif(nTipoRat == 1,;
	If(M->E2_MOEDA > 1 ,M->E2_VLCRUZ,M->E2_VALOR)+If(lIRPFBaixa,0,M->E2_IRRF)+If(!lCalcIssBx,M->E2_ISS,0)+nInss+M->E2_RETENC+M->E2_SEST+IIF(lPccBaixa,0,M->E2_PIS+M->E2_COFINS+M->E2_CSLL),;
	M->E2_VALOR)

	If nTipoRat == 1 .and. M->E2_MOEDA > 1
		nValor := Round(NoRound(xMoeda(nValor,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
	EndIf

Else
	nValor := M->E5_VALOR
EndIf

If nPercentual > 100
	lRet := .F.
EndIf

nValRat	:= 0

If lRet
	IF nPercentual == 0
		TMP->CTJ_PERCEN	:= 0
		TMP->CTJ_VALOR  	:= 0
	Else
		If TMP->(Eof()) .And. FunName() $ "FINA050"
			Reclock("TMP", .T.)
			TMP->CTJ_PERCEN 	:= M->CTJ_PERCEN
			TMP->CTJ_VALOR 	:= Round(NoRound((nValor * nPercentual)/100 ,3),2)
			TMP->(MsUnlock())
		Else
			TMP->CTJ_PERCEN 	:= M->CTJ_PERCEN
			TMP->CTJ_VALOR 	:= Round(NoRound((nValor * nPercentual)/100, nDecVlr + 1), nDecVlr)
		EndIf
	Endif

	//So ira preencher o campo de Quantidade disponivel se o Rateio for pre-configurado.
	If cTipo == "2"
		TMP->CTJ_QTDDIS	:= (TMP->CTJ_PERCEN * nQtdTot) / 100
	EndIf

	nReg := TMP->(Recno())
	TMP->(dbGoTop())
	While	TMP->(!Eof())
		If !TMP->CTJ_FLAG
			nValRat += TMP->CTJ_VALOR
			nTotPerc += TMP->CTJ_PERCEN
		Endif
		TMP->(dbSkip())
	EndDo
	TMP->(dbGoTo(nReg))

	//Acerto de arredondamento
	If nTotPerc == 100 .And. ABS( nValor - nValRat) == 0.01
		If (nValor-nValRat) == 0.01
			TMP->CTJ_VALOR += 0.01
			nValRat += 0.01
		ElseIf (nValor-nValRat) == - 0.01
			TMP->CTJ_VALOR -= 0.01
			nValRat -= 0.01
		EndIf
	Endif

EndIf
If Type("oValRat")=="O"
	oValRat:Refresh()
EndIf

RestArea(aSaveArea)

Return lRet

/*/
±±³Fun‡…o	 ³Ct050CalcV³ Autor ³ Pilar S. Albaladejo	³ Data ³ 15/05/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calcula o valor digitado para rateio no Centro Custo		  ³±±
/*/
Function Ct050CalcV(cPadrao,cProg,cTipo)

Local aSaveArea := GetArea()
Local nValor
Local nReg
Local nTipoRat	:= 1 // Tipo de rateio, 1=Bruto, 2=Liquido
Local nPercCalc := 0
Local nInss := 0
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local	lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)

Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"

nValRat := 0

If TMP->(Eof()) .And. FunName() $ "FINA050"
	Reclock("TMP", .T.)
	TMP->CTJ_VALOR		:= M->CTJ_VALOR
	TMP->(MsUnlock())
Else
	TMP->CTJ_VALOR		:= M->CTJ_VALOR
EndIf

If cProg == "FINA050" .Or. cPadrao $ "511#512"
	If !lInssBx
		nInss := M->E2_INSS
		IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
			nInss := 0
		Endif
	Endif
	If cProg == "FINA050"
		nTipoRat	:= mv_par06 // Esta pergunta faz parte do grupo de perguntas do FIN050, mas
		// Nao faz parte do grupo do FIN370 ou AFI100, de onde tambem e
		// utilizada esta funcao, atraves da CtbRatFin.
	Endif
	nValor := Iif(nTipoRat == 1,;
	M->E2_VALOR+If(lIRPFBaixa,0,M->E2_IRRF)+If(!lCalcIssBx,M->E2_ISS,0)+nInss+M->E2_RETENC+M->E2_SEST+IIF(lPccBaixa,0,M->E2_PIS+M->E2_COFINS+M->E2_CSLL),;
	M->E2_VALOR)
Else
	nValor := M->E5_VALOR
EndIf

nPercCalc	:= Round(NoRound((TMP->CTJ_VALOR * 100) / nValor,Max(3,TamSX3("CTJ_PERCEN")[2])),TamSX3("CTJ_PERCEN")[2])

If nPercCalc > 100 .OR. (TamSX3("CTJ_PERCEN")[2] >= 3 .And. nPercCalc = 100 .And. FunName() $ "FINA050") 			/// Evita erro de replace pois o percentual será maior que o tamanho disponível. (3 inteiros, 2 decimais)
	Return .F.				/// O maior valor permitido para uma linha de rateio será o correspondente a 100% do título/movimento.
EndIf

TMP->CTJ_PERCEN	:= nPercCalc
//So ira preencher o campo de quantidade disponivel se for rateio pre-configurado.
If cTipo == "2"
	TMP->CTJ_QTDDIS	:= (TMP->CTJ_PERCEN * nQtdTot) / 100
EndIf

nReg := TMP->(Recno())
TMP->(dbGoTop())
While TMP->(!Eof())
	If !TMP->CTJ_FLAG
		nValRat += TMP->CTJ_VALOR
	EndIf
	TMP->(dbSkip())
EndDo
TMP->(dbGoto(nReg))

If Type("oValRat")=="O"
	oValRat:Refresh()
EndIf

RestArea(aSaveArea)

Return .t.

/*
±±ºPrograma  ³FA050GERLCºAutor  ³Pilar S. Albaladejo º Data ³  15/05/01   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Gera Lancamento Contabil - SIGACTB                          º±±
*/
Function Fa050GerLc( cPadrao,cLote,cPrograma, nOpc,nHdlPrv,nTotal,aFlagCTB, cProcPCO, cItemPCO, cRecPag, aRecCV4, lUsaFlag )

Local aSaveArea		:= GetArea()
Local aTps
Local aParc
Local cArquivo
Local lDigita		:= .F.
Local lCusto		:= CtbMovSaldo("CTT")
Local lItem	 		:= CtbMovSaldo("CTD")
Local lCLVL	 		:= CtbMovSaldo("CTH")
Local lMovEnt05 	:= CtbMovSaldo("CT0",,'05')
Local lMovEnt06 	:= CtbMovSaldo("CT0",,'06')
Local lMovEnt07 	:= CtbMovSaldo("CT0",,'07')
Local lMovEnt08 	:= CtbMovSaldo("CT0",,'08')
Local lMovEnt09 	:= CtbMovSaldo("CT0",,'09')

// Nao considera contas no rateio -> mv_par03 == 2 e programa igual a FINA050,
// pois no FINA100 e FINA370, a variavel MV_PAR03 se refere a outra pergunta.
Local lConta		:= Iif(cPrograma $ "FINA050/FINA100"  .And. mv_par03==2,.f.,.t.)
Local lAglutina		:= .F.
Local lContabiliza  := .T.
Local lRateio		:= .T.
Local nReg			:= 0
Local nCont
Local nPis			:= SE2->E2_PIS
Local nCofins		:= SE2->E2_COFINS
Local nCsll			:= SE2->E2_CSLL
Local nMoeda		:= SE2->E2_MOEDA
Local nInss			:= SE2->E2_INSS
Local nIrrf			:= SE2->E2_IRRF
Local nIss			:= SE2->E2_ISS
Local nSest			:= SE2->E2_SEST
Local nLinTmp1		:= 0
Local lItSeqCV4 	:= .T.
Local nTotPerc		:= 0
Local nTotVal2		:= 0
Local nTotVal3		:= 0
Local nTotVal4		:= 0
Local nTotVal5		:= 0
Local nTotVal6		:= 0
Local nTotVal7		:= 0
Local nTotSEST		:= 0
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
//Verifica se o ISS eh retido na baixa
Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

//Verifica se controla retencao dos impostos
Local lContrRet := .T.

Local aAreaAux
Local nUltLin	:=	0
Local nVldTot	:= 0
Local aEntCont	:= {} // Entidades Contabeis Adicionais
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
Local cLog
Local oModel
Local oSubFK5
Local oSubFKA
Local aAreaAnt
Local lNextCV4 := .F.
Local lNext370 := .F.
Local cChave   := SE5->E5_ARQRAT
Local lRndSest  := SuperGetMv("MV_RNDSEST",.F.,.F.)

Private STRLCTPAD

Default nHdlPrv := 0
Default nTotal	 := 0

DEFAULT lUsaFlag	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
DEFAULT aFlagCTB := {}
DEFAULT cProcPCO := "000021"
DEFAULT cItemPCO := "01"
DEFAULT cRecPag  := "P"
DEFAULT aRecCV4  := {}

lF100Auto := If(Type('lF100Auto') == "U", .F.,lF100Auto)

// Assegura que o usuario nao desistiu do rateio
If (cPrograma=="FINA050" .And. SE2->E2_RATEIO != "S") .Or.;
(cPrograma=="FINA100" .And. SE5->E5_RATEIO != "S") .Or.;
Iif(ProcName(1) $ "CTBRATFIN|FA050AXINC" .And. (lF050Auto .or. lF100Auto),.F.,("_RATEIO" $ Upper(ReadVar()))) .Or.; // Nao grava rateio, quando ainda estiver na validacao do campo. //Aqui AVB Se for a rotina de inclusao do rateio e for rotina automatica nao verifica o campo.
(FWIsInCallStack("F050EscRat") .And. lF050Auto) //Nao grava o rateio na execucao do cTudoOK na substituicao de titulos via Mensagem Unica
	Return //Function Fa050GerLc
Endif

If cPrograma == "FINA050"
	lAglutina	:= Iif(mv_par07==1,.T.,.F.)
	lDigita 	:= Iif(mv_par01==1,.T.,.F.)
	lContabiliza:= Iif(mv_par04==1 .And. ((!SE2->E2_TIPO $ MVPROVIS) .or. (SE2->E2_TIPO $ MVPROVIS .and. mv_par02 == 1)),.T.,.F.)
	lRateio		:= Iif(mv_par06==1,.T.,.F.)

	//Se for exclusao de titulo rateado na emissão (LP511) e ja contabilizado,
	//Devo contabilizar ainda que Contabiliza On-line = Não (MV_PAR04 == 1)
	If cPadrao == "512" .and. SE2->E2_LA == "S"
		lContabiliza := .T.
	Endif
ElseIf cPrograma == "FINA100"
	lAglutina	:= Iif(mv_par01==1,.T.,.F.)
	lDigita		:= Iif(mv_par02==1,.T.,.F.)
	lContabiliza:= Iif(mv_par04==1,.T.,.F.)
ElseIf cPrograma == "FINA370"
	lAglutina	:= Iif(mv_par02==1,.T.,.F.)
	lDigita		:= Iif(mv_par01==1,.T.,.F.)
	lContabiliza:= .T.
EndIf
// Restaura perguntas da rotina
pergunte("FIN050",.F.)


//Compatibilização com os pontos de bloqueio do SIGAPCO
If Type("cSeqCv4") == "U"
	nSaveSx8Len := GetSx8Len()
	If nOpc == 3 // Inclusao
		cSeqCv4 := GetSx8Num("CV4", "CV4_SEQUEN")
	Else
		cSeqCv4 := ""
	EndIf
Endif

dbSelectArea("CV4")
dbSetOrder(1)
DbSeek(cChave)   //cChave jah contem filial

If cPrograma == "FINA370"
	nValRat := 0
Else
	//Remonto o valor a ratear
	If lRateio
		nValRat := SE2->(E2_VALOR+E2_IRRF+E2_SEST)
		If !lInssBx
			nValRat += SE2->E2_INSS
		Endif
		If !lCalcIssBx
			nValRat += SE2->E2_ISS
		Endif

		//Pcc pela emissao
		If !lPccBaixa
			If lContrRet
				If Empty(SE2->E2_PRETPIS)
					nValRat += IIF(Empty(SE2->E2_VRETPIS), SE2->E2_PIS , SE2->E2_VRETPIS )
				Endif
				If Empty(SE2->E2_PRETCOF)
					nValRat += IIF(Empty(SE2->E2_VRETCOF), SE2->E2_COFINS , SE2->E2_VRETCOF )
				Endif
				If Empty(SE2->E2_PRETCSL)
					nValRat += IIF(Empty(SE2->E2_VRETCSL), SE2->E2_CSLL , SE2->E2_VRETCSL )
				Endif
			Else
				nBaseIrrf += SE2->(E2_PIS+E2_COFINS+E2_CSLL)
			Endif
		Endif
	Else
		nValRat := SE2->E2_VALOR
	Endif
EndIf

If Select("TMP") > 0 .And.  TMP->(RecCount()) > 0
	// Se o cabecalho nao foi criado por outra rotina
	If lContabiliza // Contabiliza on-line
		If nHdlPrv <= 0
			//³ Inicializa Lancamento Contabil                                   ³
			nHdlPrv := HeadProva( cLote,;
			cPrograma,;
			Substr(cUsuario,7,6),;
			@cArquivo )
		Endif
	Endif

	//Inicia processo do lancamento no Pco somente se for conta a pagar ou receber com rateio
	//movimento bancario deve usar o proprio processo --> 000007
	If cProcPco == "000021"
		PcoIniLan(cProcPCO)
	EndIf
	nUltLin	:=	0
	dbSelectArea("TMP")
	dbGoTop()
	While !Eof()
		If !TMP->CTJ_FLAG
			nUltLin++
		Endif
		If cPrograma == "FINA370"
			// quando vier do fina370, não sabe se o rateio foi pelo valor bruto ou liquido, por isso soma todos os valores
			// rateados para pegar o total
			nValRat += TMP->CTJ_VALOR
		EndIf
		DbSkip()
	Enddo
	dbSelectArea("TMP")
	dbGoTop()
	nLinTmp1 := 0

	If nOpc == 3 // Inclusao
		While (GetSx8Len() > nSaveSx8Len)
			ConfirmSX8()
		End
	Endif
	nCTRLLin := 0

	While !Eof()
		nLinTmp1++
		If !TMP->CTJ_FLAG
			nCTRLLin++
			// Variaveis de Contabilizacao exclusivas do SIGACTB
			Historico:= TMP->CTJ_HIST
			If lCusto
				CustoD	:= TMP->CTJ_CCD
				CustoC	:= TMP->CTJ_CCC
			EndIf

			// Variaveis de contabilizacao utilizadas no SIGACON e no SIGACTB
			If lConta					// considera contas no rateio -> mv_par03 == 1
				Debito	:= TMP->CTJ_DEBITO
				Credito	:= TMP->CTJ_CREDIT
			EndIF
			If lCusto
				Custo		:= Iif(!Empty(TMP->CTJ_CCD),TMP->CTJ_CCD,TMP->CTJ_CCC)
			EndIf
			If lItem
				ItemD		:= TMP->CTJ_ITEMD
				ItemC		:= TMP->CTJ_ITEMC
			EndIf
			If lCLVL
				ClvlD		:= TMP->CTJ_CLVLDB
				ClVlC		:= TMP->CTJ_CLVLCR
			EndIf

			/*
			* Entidades Contábeis Adicionais
			*/
			aEntCont := {}
			If lMovEnt05
				aAdd(aEntCont,{"05",TMP->CTJ_EC05DB,TMP->CTJ_EC05CR})
				EC05DB := TMP->CTJ_EC05DB
				EC05CR := TMP->CTJ_EC05CR
			EndIf

			If lMovEnt06
				aAdd(aEntCont,{"06",TMP->CTJ_EC06DB,TMP->CTJ_EC06CR})
				EC06DB := TMP->CTJ_EC06DB
				EC06CR := TMP->CTJ_EC06CR
			EndIf

			If lMovEnt07
				aAdd(aEntCont,{"07",TMP->CTJ_EC07DB,TMP->CTJ_EC07CR})
				EC07DB := TMP->CTJ_EC07DB
				EC07CR := TMP->CTJ_EC07CR
			EndIf

			If lMovEnt08
				aAdd(aEntCont,{"08",TMP->CTJ_EC08DB,TMP->CTJ_EC08CR})
				EC08DB := TMP->CTJ_EC08DB
				EC08CR := TMP->CTJ_EC08CR
			EndIf

			If lMovEnt09
				aAdd(aEntCont,{"09",TMP->CTJ_EC09DB,TMP->CTJ_EC09CR})
				EC09DB := TMP->CTJ_EC09DB
				EC09CR := TMP->CTJ_EC09CR
			EndIf

			If cPadrao == "511" .Or. cPadrao == "512"
				Valor	:= Round(xMoeda(TMP->CTJ_VALOR,nMoeda,1,SE2->E2_EMISSAO,3,SE2->E2_TXMOEDA),2)
			Else
				Valor	:= TMP->CTJ_VALOR
			Endif

			VlrInStr 	:= Valor
			Valor2		:= Round(nIrrf		* (Valor / nValRat),2)
			Valor3		:= Round(nInss		* (Valor / nValRat),2)
			Valor4		:= Round(nIss		* (Valor / nValRat),2)
			SEST		:= Iif(lRndSest,Round(nSest		* (Valor / nValRat),2),NoRound(nSest		* (Valor / nValRat),2))

			If cPrograma == "FINA370" .AND. lContrRet .AND. !lPCCBaixa .AND. (cPadrao == "511" .OR. cPadrao == "512")
				If Empty(SE2->E2_PRETPIS) .AND. Empty(SE2->E2_PRETCOF) .AND. Empty(SE2->E2_PRETCSL)
					Valor5		:= Round(SE2->E2_VRETPIS * (Valor / nValRat),2)
					Valor6		:= Round(SE2->E2_VRETCOF * (Valor / nValRat),2)
					Valor7		:= Round(SE2->E2_VRETCSL * (Valor / nValRat),2)
				Else
					Valor5		:= 0
					Valor6		:= 0
					Valor7		:= 0
				Endif
			Else
				Valor5		:= Round(nPis 		* (Valor / nValRat),2)
				Valor6		:= Round(nCofins	* (Valor / nValRat),2)
				Valor7		:= Round(nCsll		* (Valor / nValRat),2)
			Endif
			//Somatorio dos valores para verificacao de arredondamentos
			nTotPerc		+= iif(nMoeda>1,(TMP->CTJ_VALOR / nValRat),(Valor / nValRat))
			nTotVal2		+= VALOR2
			nTotVal3		+= VALOR3
			nTotVal4		+= VALOR4
			nTotVal5		+= VALOR5
			nTotVal6		+= VALOR6
			nTotVal7		+= VALOR7
			nTotSEST		+= SEST
			If nTotVal2 > nIRRF
				VALOR2	:=	VALOR2 - (nTotVal2- nIRRF)
				nTotVal2	:=	nIRRF
			Endif
			If nTotVal3 > nInss
				VALOR3	:=	VALOR3 - (nTotVal3 - nInss)
				nTotVal3	:=	nInss
			Endif
			If nTotVal4 > nIss
				VALOR4	:=	VALOR4 - (nTotVal4 - nIss)
				nTotVal4	:=	nIss
			Endif
			If nTotVal5 > nPis
				VALOR5	:=	VALOR5 - (nTotVal5 - nPis)
				nTotVal5	:=	nPis
			Endif
			If nTotVal6 > nCofins
				VALOR6	:=	VALOR6 - (nTotVal6 - nCofins)
				nTotVal6	:=	nCofins
			Endif
			If nTotVal7 > nCsll
				VALOR7	:=	VALOR7 - (nTotVal7 - nCsll)
				nTotVal7	:=	nCsll
			Endif
			nVldTot += valor
			//Verificacao de aplicacao de arredondamento
			If nCTRLLin == nUltLin
				Valor2 += (nIrrf - nTotVal2)
				Valor3 += (nInss - nTotVal3)
				Valor4 += (nIss - nTotVal4)
				//Se a chamada for do FINA370, o PCC for gerado na emissao e o titulo reteve o PCC, contabilizar o PCC senao levar zero
				If cPrograma == "FINA370" .AND. lContrRet .AND. !lPCCBaixa .AND. (cPadrao == "511" .OR. cPadrao == "512")
					If Empty(SE2->E2_PRETPIS) .AND. Empty(SE2->E2_PRETCOF) .AND. Empty(SE2->E2_PRETCSL)
						Valor5 += (SE2->E2_VRETPIS - nTotVal5)
						Valor6 += (SE2->E2_VRETCOF - nTotVal6)
						Valor7 += (SE2->E2_VRETCSL - nTotVal7)
					Endif
				Else
					Valor5 += (nPis - nTotVal5)
					Valor6 += (nCofins - nTotVal6)
					Valor7 += (nCsll - nTotVal7)
				Endif

				If (nVldTot - (SE2->E2_VLCRUZ + If(mv_par06==1,(nIrrf + nInss + nIss + nPis + nCofins + nCsll),0))) > 0 .and.;
				(cPadrao == "511" .Or. cPadrao == "512")
					Valor -= (nVldTot - SE2->E2_VLCRUZ)
				Elseif (nVldTot - SE5->E5_VALOR) > 0 .and. cPadrao == "516"
					Valor -= (nVldTot - SE5->E5_VALOR)
				Endif
			Endif

			// Retorna chave de busca -> quando utiliza variavel VALOR
			cChaveBusca := CtRelation(cPadrao)

			If cPadrao == "511" .Or. cPadrao == "512"
				// Desposiciona SE2
				dbSelectArea("SE2")
			Else
				// Desposiciona SE5
				dbSelectArea("SE5")
			EndIf

			If nReg = 0
				nReg := Recno()
			Endif
			STRLCTPAD := nReg // Disponibiliza o registro do titulo/movimento bancario
			// para ser utilizado no LP para recuperar informacoes
			// do registro contabilizado
			If lContabiliza .And. cPrograma $ "FINA050;FINA370" .And. cPadrao $ "511|512" .And. ;
				lRateio .And. STR(nOpc,1) $ ('4|5') .And. !Empty(SE2->E2_ARQRAT) .And. !lNextCV4
				CV4->(MsSeek(Rtrim(SE2->E2_ARQRAT)))
				lNextCV4 := .T.
			EndIf

			IF lContabiliza .And. cPrograma == "FINA370" .And. cPadrao $ "516"
				lNext370 := .T.
			Endif

			dbGoBottom()
			dbSkip()

			If lContabiliza  // Contabiliza on-line
				//³ Prepara Lancamento Contabil                                      ³
				//Contabiliza pela variavel VALOR. Nao necessita de controle de flag.
				nTotal += DetProva( nHdlPrv,;
				cPadrao,;
				cPrograma,;
				cLote,;
				/*nLinha*/,;
				/*lExecuta*/,;
				/*cCriterio*/,;
				.T. /*lRateio*/,;
				cChaveBusca,;
				/*aCT5*/,;
				/*lPosiciona*/,;
				/*@aFlagCTB*/,;
				/*aTabRecOri*/,;
				/*aDadosProva*/ )
			Endif

			If cPadrao == "511" .Or. cPadrao == "512"
				dbSelectArea("SE2")
			Else
				dbSelectArea("SE5")
			EndIf
			dbGoto(nReg)
			VlrInStr := Valor

			If nOpc == 3 .and. !TMP->CTJ_FLAG // Inclusao
				// Grava Rateio digitado ou pre-configurado
				GravaCv4( cSeqCv4,;
				dDataBase,;
				If(lConta,TMP->CTJ_DEBITO,""),;
				If(lConta, TMP->CTJ_CREDIT,""),;
				TMP->CTJ_PERCEN,;
				TMP->CTJ_VALOR,;
				TMP->CTJ_HIST,;
				If(lCusto, TMP->CTJ_CCC,""),;
				If(lCusto, TMP->CTJ_CCD,""),;
				If(lItem, TMP->CTJ_ITEMD,""),;
				If(lItem, TMP->CTJ_ITEMC,""),;
				If(lClVl, TMP->CTJ_CLVLDB,""),;
				If(lClVl, TMP->CTJ_CLVLCR,""),;
				If(lItSeqCV4, StrZero(nLinTmp1,Len(CV4->CV4_ITSEQ)), NIL),;
				cProcPCO, ;
				cItemPCO, ;
				cPrograma,;
				aEntCont ) // Entidade Contabeis Adicionais
			ElseIf nOpc == 5
				If Len(aRecCV4) > 0 .And. nLinTmp1 <= Len(aRecCV4)
					aAreaAux := GetArea()
					dbSelectArea("CV4")
					dbGoto(aRecCV4[nLinTmp1])
					PcoDetLan(cProcPco, cItemPco, cPrograma)
					RestArea(aAreaAux)
				EndIf
			Endif

		Endif
		dbSelectArea("TMP")
		dbSkip()

		If cPrograma == "FINA370"  .and. cPadrao == "516" .and. lNext370
			CV4->(dbSkip())
		Endif

		If lNextCV4
			CV4->(dbSkip())
		EndIf
	Enddo

	//finaliza processo de lancamento no PCO
	If cProcPco == "000021"
		PcoFinLan(cProcPCO)
	EndIf

	Valor	 := 0
	Valor2 	 := 0
	Valor3	 := 0
	Valor4	 := 0
	Valor5 	 := 0
	Valor6	 := 0
	Valor7	 := 0
	SEST	 := 0
	VlrInStr := 0
	If cPadrao == "511" .Or. cPadrao == "512"
		dbSelectArea("SE2")
	Else
		dbSelectArea("SE5")
	EndIf
	dbGoTo(nReg)
	If lContabiliza .And. !lNextCV4 .And. !lNext370 .OR. ((lNextCV4 .or. lNext370 ) .And. cPrograma $ "FINA050;FINA370" .And. cPadrao $ "511|512|516") // Contabiliza on-line
		//³ Prepara Lancamento Contabil                                      ³
		If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
			If cPadrao $ "511#512"
				aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
			Else
				aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
			Endif
		Endif
		nTotal += DetProva( nHdlPrv,;
		cPadrao,;
		cPrograma,;
		cLote,;
		/*nLinha*/,;
		/*lExecuta*/,;
		/*cCriterio*/,;
		/*lRateio*/,;
		/*cChaveBusca*/,;
		/*aCT5*/,;
		/*lPosiciona*/,;
		@aFlagCTB,;
		/*aTabRecOri*/,;
		/*aDadosProva*/ )

		// Se nao rateia desdobramento, faz a contabilizacao, senao a tela sera exibida apos todas as parcelas
		// serem incluidas
		If cPrograma != "FINA370" .And. SE2->E2_DESDOBR != "S"
			RodaProva( nHdlPrv,;
			nTotal )
		Endif
	Endif
Endif

If nTotal > 0  .And. lContabiliza .And. cPrograma != "FINA370" .And. SE2->E2_DESDOBR != "S"

	If  UsaSeqCor()
		aDiario := {}
		aDiario := {{"SE2",SE2->(recno()),SE2->E2_DIACTB,"E2_NODIA","E2_DIACTB"}}
	Else
		aDiario := {}
	EndIf

	DBSELECTAREA("TMP")

	//³ Efetiva Lan‡amento Contabil                                      ³
	cA100Incl( cArquivo,;
	nHdlPrv,;
	3 /*nOpcx*/,;
	cLote,;
	lDigita,;
	lAglutina,;
	/*cOnLine*/,;
	/*dData*/,;
	/*dReproc*/,;
	@aFlagCTB,;
	/*aDadosProva*/,;
	aDiario )
	aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento

	If !lUsaFlag
		If cPadrao == "511" .Or. cPadrao == "512"
			dbSelectArea("SE2")
			dbGoto(nReg)
			//³ Atualiza flag de Lan‡amento Cont bil	   ³
			Reclock("SE2")
			Replace E2_LA With "S"
			aTps := {"TX ","INS","ISS","SES"}
			aParc := {SE2->E2_PARCIR,SE2->E2_PARCINS,SE2->E2_PARCISS,SE2->E2_PARCSES}
			dbSetOrder(1)
			For nCont := 1 to Len(aTps)
				If Dbseek(xFilial("SE2")+SE2->E2_PREFIXO+SE2->E2_NUM+aParc[nCont]+aTps[nCont])
					Reclock("SE2")
					Replace E2_LA With "S"
				Endif
				dbGoto(nReg)
			Next nCont
		Else
			dbSelectArea("SE5")
			dbGoto(nReg)
			//³ Atualiza flag de Lan‡amento Cont bil 	   ³
			aAreaAnt := GetArea()
			oModel :=  FWLoadModel('FINM030')//Mov. Bancario Manual
			oModel:SetOperation( 4 ) //Alteração
			oModel:Activate()
			oSubFKA := oModel:GetModel( "FKADETAIL" )
			oSubFKA:SeekLine( 	{ {"FKA_IDORIG", SE5->E5_IDORIG } } )

			//Dados do movimento
			oSubFK5 := oModel:GetModel( "FK5DETAIL" )
			oSubFK5:SetValue( "FK5_LA", "S" )

			If oModel:VldData()
				oModel:CommitData()
				oModel:DeActivate()
			Else

				cLog := cValToChar(oModel:GetErrorMessage()[4]) + ' - '
				cLog += cValToChar(oModel:GetErrorMessage()[5]) + ' - '
				cLog += cValToChar(oModel:GetErrorMessage()[6])
				Help( ,,"M040VALID",,cLog, 1, 0 )
			Endif
			Restarea(aAreaAnt )
		EndIf
	Endif
Endif
If cPrograma == "FINA100"
	Pergunte("AFI100",.F.) // Restaura perguntas do FINA100 para pegar os parametros corretos
ElseIf cPrograma == "FINA370"
	Pergunte("FIN370",.F.) // Restaura perguntas do FINA370 para pegar os parametros corretos
EndIf

RestArea(aSaveArea)

Return xFilial("CV4")+DTOS(dDataBase)+cSeqCv4 //Function Fa050GerLc

/*/
±±³Fun‡…o	 ³fa050LinCT³ Autor ³ Pilar S. Albabadejo	³ Data ³ 15/05/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Analisa a linha digitada - SIGACTB 						  ³±±
/*/
Function FA050LinCT()
Local lRet := .T.
Local lF050LRCT := ExistBlock("F050LRCT") // Validar a inclusao da linha do rateio on-line

// Se existir o PE F050LRCT, utiliza o retorno do PE para validar a linha
If lF050LRCT
	lRet := ExecBlock("F050LRCT", .F., .F. )
Endif

Return lRet

/*/
±±³Fun‡…o	 ³fa050TudCT³ Autor ³ Pilar S. Albaladejo	³ Data ³ 15/05/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Analisa a tela digitada									  ³±±
/*/
Function FA050TudCT(nOpc,cPadrao,cPrograma,nTipo,oGetDB,lRat05)

Local aSaveArea := GetArea()
Local nValor
Local lRet 		:= .T.
Local nTipoRat	:= 1 // Tipo de rateio, 1=Bruto, 2=Liquido
Local nValRat
Local nInss 	:= 0, nVlrN

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local	lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)

Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

//Local lConta		:= Iif(cPrograma $ "FINA050/FINA100"  .And. mv_par03==2,.f.,.t.)
Local lCusto		:= CtbMovSaldo("CTT")
Local lItem	 		:= CtbMovSaldo("CTD")
Local lCLVL	 		:= CtbMovSaldo("CTH")
Local nX
Local aCpos         := {}
Local lF0502RAT	:= ExistBlock("F0502RAT")

Local lCtaCC		:= .F. //Indica se os campos conta debito, conta credito, centro de custo debito e centro de custo credito do arquivo temporario estao em branco.
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"

DEFAULT nOpc  := 3
DEFAULT nTipo := 1
Default lRat05 := .F.

If Select("TMP") <= 0
	Return .T.
Endif


If type("n")=="U"  //se a variavel nao existe declara como private
	Private n
EndIf

If n != NIL   //salva valor de n utilizado na GetDB
	nVlrN := n
EndIf

If cPrograma $ "FINA050/FINA100" .And. Valtype(oGetDB) == "O"
	For nX := 1 TO Len(oGetDB:aAlter)
		SX3->(DbSetOrder(2))
		SX3->(DbSeek(Upper(AllTrim(oGetDB:aAlter[nX]))))
		If x3uso(SX3->X3_USADO) .and. (X3Obrigat(SX3->X3_CAMPO) .or. VerByte(SX3->X3_RESERV,7))
			aAdd(aCpos, Alltrim(oGetDB:aAlter[nX]) )
		EndIf
	Next
EndIf

nValRat 	:= 0
lCtaCC		:= .F.
dbSelectArea("TMP")
dbGotop()
While !Eof()
	If !TMP->CTJ_FLAG
		If Empty(TMP->CTJ_PERCEN) 	//Verifica se existe alguma linha com o percentual zerado
			TMP->CTJ_FLAG := .T.		//Deleto linhas em branco
		Else
			If Len(aCpos) > 0
				For nX := 1 TO TMP->(FCOUNT())
					If Ascan(aCpos, Alltrim(TMP->(FieldName(nX)))) > 0 .And. Empty(Tmp->(FieldGet(nX)))
						MsgAlert(STR0228)//Help(1," ","OBRIGAT",,FieldName(nX),3,0)
						Return (.F.)
					EndIf
				Next
			EndIf
			nValRat += TMP->CTJ_VALOR
		Endif

		If FUNNAME() $ "FINA050/FINA100/FINA750" .and. mv_par03 == 2
			If Empty(TMP->CTJ_CCD) .And. Empty(TMP->CTJ_CCC)
				lCtaCC	:= .T.
			Endif
		Else
			If Empty(TMP->CTJ_CCD) .And. Empty(TMP->CTJ_CCC) .And. Empty(TMP->CTJ_DEBITO) .And. Empty(TMP->CTJ_CREDIT)
				lCtaCC	:= .T.
			Endif
		EndIf

	EndIf

	dbSkip()
EndDo

If lF050RAT
	lRet := ExecBlock("F050RAT",.F.,.F.)
	Return lRet
EndIf

//Caso conta debito, conta credito, centro de custo debito e centro de custo credito estejam todos em branco não devo gravar o registro.
If lCtaCC
	MsgAlert(STR0229)
	Return (.F.)
EndIf

If cPrograma == "FINA050" .Or. cPadrao $ "511#512"
	If !lInssBx
		nInss := M->E2_INSS
		IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
			nInss := 0
		Endif
	Endif
	If cPrograma == "FINA050"
		nTipoRat	:= mv_par06 // Esta pergunta faz parte do grupo de perguntas do FIN050, mas
		// Nao faz parte do grupo do FIN370 ou AFI100, de onde tambem e
		// utilizada esta funcao, atraves da CtbRatFin.
	Endif
	nValor := Iif(nTipoRat==1,;
	If(M->E2_MOEDA > 1 ,M->E2_VLCRUZ,M->E2_VALOR)+If(lIRPFBaixa,0,M->E2_IRRF)+If(!lCalcIssBx,M->E2_ISS,0)+nInss+M->E2_RETENC+M->E2_SEST+IIF(lPccBaixa,0,M->E2_PIS+M->E2_COFINS+M->E2_CSLL),;
	M->E2_VALOR)

	If nTipoRat == 1 .and. M->E2_MOEDA > 1
		nValor := Round(NoRound(xMoeda(nValor,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))

	EndIf
Else
	nValor := M->E5_VALOR
EndIf

If nOpc <> 5
	If Str(nValRat,17,2) != Str(nValor,17,2)
		Help( " ", 1, "FA050RATEI")
		lRet := .F.
	Endif
EndIf

//tratamento para o modulo sigapco  // POR TOTAL
If nOpc == 3
	If lRet .And. cPrograma == "FINA050"
		dbSelectArea("TMP")
		dbGotop()
		n := 0
		While TMP->(!Eof())
			n++  //incrementa variavel n utilizado na pcovldlan (bloqueio)
			If !TMP->CTJ_FLAG
				lRet := PcoVldLan("000021","01","FINA050")
				If ! lRet
					Exit
				EndIf
			EndIf
			TMP->(dbSkip())
		EndDo
		//Restaura o valor de n -- utilizado na GetDB
		n := nVlrN
	ElseIf lRet .And. cPrograma == "FINA100" .And. lRat05
		dbSelectArea("TMP")
		dbGotop()
		n := 0
		While TMP->(!Eof())
			n++  //incrementa variavel n utilizado na pcovldlan (bloqueio)
			If !TMP->CTJ_FLAG
				lRet := PcoVldLan("000007","05","FINA100")
				If !lRet
					Exit
				EndIf
			EndIf
			TMP->(dbSkip())
		EndDo
		//Restaura o valor de n -- utilizado na GetDB
		n := nVlrN
	EndIf
EndIf

If lRet .and. lF0502RAT
	lRet := ExecBlock("F0502RAT",.F.,.F.)
EndIf

// Tipo de Rateio Pre-Configurado deve validar Centro de custo/Item/Classe de Valor informados
If lRet .And. nTipo == 2
	TMP->( dbGotop() )
	Do While TMP->( !Eof() )
		If !TMP->CTJ_FLAG
			// Verifica centros de custo credito e debito
			If lCusto
				If !Empty(TMP->CTJ_CCD)
					lRet := Ctb105CC(TMP->CTJ_CCD)
					If !lRet
						Exit
					EndIf
				EndIf
				If !Empty(TMP->CTJ_CCC)
					lRet := Ctb105CC(TMP->CTJ_CCC)
					If !lRet
						Exit
					EndIf
				EndIf
			EndIf
			// Verifica item credito e item debito
			If lItem
				If !Empty(TMP->CTJ_ITEMD)
					lRet := Ctb105Item(TMP->CTJ_ITEMD)
					If !lRet
						Exit
					EndIf
				EndIf
				If !Empty(TMP->CTJ_ITEMC)
					lRet := Ctb105Item(TMP->CTJ_ITEMC)
					If !lRet
						Exit
					EndIf
				EndIf
			EndIf
			// Verifica classe de valor credito e debito
			If lCLVL
				If !Empty(TMP->CTJ_CLVLDB)
					lRet := Ctb105ClVl(TMP->CTJ_CLVLDB)
					If !lRet
						Exit
					EndIf
				EndIf
				If !Empty(TMP->CTJ_CLVLCR)
					lRet := Ctb105ClVl(TMP->CTJ_CLVLCR)
					If !lRet
						Exit
					EndIf
				EndIf
			EndIf
		EndIf
		TMP->( dbSkip() )
	EndDo
EndIf

RestArea(aSaveArea)

Return lRet

/*/
±±³Fun‡…o	 ³fa050CodRa³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 21/05/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Analisa a tela digitada									  ³±±
/*/
Function Fa050CodRat(cCodRateio,nRadio)

Local lRet		:= .T.
Local lF050VLC := ExistBlock("F050VLCOD")

If nRadio == 2 .And. Empty(cCodRateio)
	lRet := .F.
EndIf

If lF050VLC
	lRet := ExecBlock("F050VLCOD",.F.,.F.,{cCodRateio,nRadio})
EndIf

Return lRet

/*/
±±³Fun‡…o	 ³Fa050ValRa³ Autor ³ Pilar S. Albaladejo	³ Data ³ 15/05/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida Tela de Rateio - Financeiro                  		  ³±±
/*/
Function Fa050ValRat(nRadio,cCodRateio, oDlg1, cDebito, cCredito, nOpca)

Local aSaveArea := GetArea()
Local lRet := .T.
Local cTpEntida := ""
Local lF050VLRAT:= ExistBlock("F050VLRAT")

nOpca := 1

If nRadio == 1 .And. ! Empty(cCodRateio)
	nOpca := 0
EndIf

If lRet
	If nRadio == 2

		If lF050VLRAT
			nOpca:= ExecBlock("F050VLRAT",.f.,.f., cCodRateio)
		EndIf

		dbSelectArea("CTJ")
		dbSetOrder(1)
		If !dbSeek(xFilial()+cCodRateio)
			Help(" ",1,"FA050RATER")
			nOpca := 0
		EndIf

		If 	oDlg1 # Nil .And. mv_par03==1 .And.;
		CtbDigCta(cCodRateio,,,,, @cTpEntida) .And.;
		! CtbValCta(cDebito, cCredito, cTpEntida)
			Help(" ",1,"CT9DEBCRED")
			nOpca := 0
		Endif

	EndIf
EndIF

If nOpca == 1
	If oDlg1 # Nil
		oDlg1:End()
	EndIf
Else
	lRet := .F.
Endif

RestArea(aSaveArea)

Return lRet

//-------------------------------------------------------
/*/{Protheus.doc} Fa050MultNat
	Recalcular o valor do titulo e zerar os impostos

@author Claudio D. de Souza
@since 16/08/2001
@version P12
*/
//-------------------------------------------------------
FUNCTION Fa050MultNat()

//Verifico se permite rateios de desdobramento no mesmo titulo
If lRatDsd == NIL
	lRatDsd := IIF(GetMv("MV_RATDESD",,"2") == "1", .T., .F.)
Endif

// Retirar X3_WHEN dos campos - E2_ISS, E2_IRRF, E2_INSS
// Passa a ser permitido rateio de multiplas naturezas usando a pergunta 06
// Rateio de Liquido/Bruto
If !MV_MULNATP .And. M->E2_MULTNAT == "1"
	HELP(' ',1,'MULNATP' ,,STR0297,2,0,,,,,,{STR0298})	//'Parƒmetro MV_MULNATP est  desativado. Com isto este campo n?o ter  efeito para a gera‡?o do rateio multinatureza.'###'Para efetuar rateios multinatureza ‚ necess rio ativar o parƒmetro MV_MULNATP.'
	M->E2_MULTNAT := "2"
ElseIf !lRatDsd
	M->E2_DESDOBR := "N"
EndIf

Return .T.

/*
±±³Fun‡„o    ³FA050IniS ³ Autor ³ Wagner Mobile Costa   ³ Data ³ 21/09/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Funcao para inicializacao dos campos de memoria para rotina³±±
±±³          ³ de substituicao                                            ³±±
*/
Function fa050IniS( )

Local aIniCpos 	:= {}, nInd
Local lFa050S 	:= ExistBlock("FA050S")
Local lFa050SUB := ExistBlock("FA050SUB")
Local lF050TPRV := ExistBlock("F050TPRV")
Local nRegAtu
Local aArea 	:= GetArea()
Local aAreaSubs
Local aAltera	:= {}
Local cArq
Local lCusto	:= CtbMovSaldo("CTT")
Local lItem	 	:= CtbMovSaldo("CTD")
Local lCLVL	 	:= CtbMovSaldo("CTH")
Local lAchouCV4 := .F.

nQtdTit	:= If (Type("nQtdTit") != "N",0,nQtdTit)

If Type("nValorS") # "U" .And. nValorS # Nil
	dbSelectArea("SA2")
	dbSetOrder(1)
	dbSeek(xFilial()+cCodFor+cLojaFor)
	lIRProg := IIf(cPaisLoc == "BRA",IIf(!Empty(SA2->A2_IRPROG),SA2->A2_IRPROG,"2"),"2")

	If nQtdTit == 1
		M->E2_PREFIXO	:= SE2->E2_PREFIXO
		M->E2_NUM		:= SE2->E2_NUM
		M->E2_NATUREZ	:= SE2->E2_NATUREZ
		M->E2_HIST		:= SE2->E2_HIST
	EndIf

	M->E2_VALOR    := nValorS
	M->E2_TXMOEDA  := SE2->E2_TXMOEDA
	M->E2_VLCRUZ   := Round(NoRound(xMoeda(nValorS,nMoedSubs,1,M->E2_EMISSAO,MsDecimais(1)+1,SE2->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
	M->E2_FORNECE  := cCodFor
	M->E2_LOJA     := cLojaFor
	M->E2_NOMFOR   := SA2->A2_NREDUZ
	M->E2_MOEDA	   := nMoedSubs
	M->E2_VENCTO   := dDataBase + (SE2->E2_VENCTO - SE2->E2_EMISSAO)
	M->E2_VENCREA  := DataValida(M->E2_VENCTO,.T.)

	If FwIsInCallStack('Fa050Subst')
		M->E2_BASEPIS	:= nValorS
		M->E2_BASECOF	:= nValorS
		M->E2_BASECSL	:= nValorS
		M->E2_BASEISS	:= nValorS
		M->E2_BASEIRF	:= nValorS
		M->E2_BASEINS	:= nValorS

		//Carrega os dados banc rios do fornecedor
		If !Empty(M->E2_FORNECE) .and. !Empty(M->E2_LOJA)
			aFornBco := F050CBCO(M->E2_FORNECE, M->E2_LOJA)
			If !Empty(aFornBco)
				M->E2_FORBCO	:=	aFornBco[1]
				M->E2_FORAGE	:=	aFornBco[2]
				M->E2_FAGEDV	:=	aFornBco[3]
				M->E2_FORCTA	:=	aFornBco[4]
				M->E2_FCTADV	:=	aFornBco[5]
				M->E2_FORMPAG	:=	aFornBco[6]
			Endif
		EndIf

	Endif
	If lF050TPRV
		ExecBlock("F050TPRV",.F.,.F.)
	EndIf

	If nQtdTit == 1
		aAreaSubs:= GetArea("__SUBS")
		dbSelectArea("__SUBS")
		dbGoTop()
		While !Eof() .And. E2_OK <> cMarca
			dbSkip()
		Enddo

		If E2_RATEIO == "S"
			M->E2_RATEIO	:= E2_RATEIO
			M->E2_ARQRAT	:= E2_ARQRAT

			CV4->(dbSetOrder(1))
			If !CV4->(dbSeek(E2_ARQRAT))
				lAchouCV4	:= .F.
			Else
				lAchouCV4	:= .T.
			EndIf

			// Caso o arquivo exista, o sistema apaga e reconstroi vazio.
			If !Eof() .And. lAchouCV4
				// Cria aHeader
				aCampos := F050CmpRat(@aAltera)

				If Select("TMP") > 0
					If nOpc != 3 .Or. (nOpc == 3 .And. !MsgYesNo(STR0130,STR0115)) // "Existe um rateio na memória. Deseja utilizá-lo?"#"Atenção"//Apaga TMP1

						If Select("TMP") > 0
							DbSelectArea( "TMP" )
							DbCloseArea()
						Endif

						If(_oFINA0501 <> NIL)
							_oFINA0501:Delete()
							_oFINA0501 := NIL
						EndIf

						F050Cria(aCampos)
					Endif
				Else
					F050Cria(aCampos)
				EndIf
			Endif

			While CV4->(!Eof()) .And. CV4->CV4_FILIAL == SubStr(E2_ARQRAT,1,02) .And. CV4->CV4_SEQUEN == SubStr(E2_ARQRAT,11,10)

				dbSelectArea("TMP")
				dbAppend()
				TMP->CTJ_DEBITO	:= CV4->CV4_DEBITO
				TMP->CTJ_CREDIT	:= CV4->CV4_CREDIT
				If lCusto
					TMP->CTJ_CCD		:= CV4->CV4_CCD
					TMP->CTJ_CCC		:= CV4->CV4_CCC
				EndIf
				If lItem
					TMP->CTJ_ITEMD		:= CV4->CV4_ITEMD
					TMP->CTJ_ITEMC		:= CV4->CV4_ITEMC
				EndIf
				If lCLVL
					TMP->CTJ_CLVLDB	:= CV4->CV4_CLVLDB
					TMP->CTJ_CLVLCR	:= CV4->CV4_CLVLCR
				EndIf
				TMP->CTJ_HIST		:= CV4->CV4_HIST
				TMP->CTJ_VALOR		:= CV4->CV4_VALOR
				TMP->CTJ_PERCEN	:= CV4->CV4_PERCEN
				TMP->CTJ_FLAG 		:= .F.

				dbSelectArea("CV4")
				dbSkip()
			EndDo
		EndIf
		RestArea(aAreaSubs)
	EndIf

	If Type("bIniciaVal") = "B"// Usado caso a bExecuta # NIL
		EVAL(bIniciaVal)// AWR - AVERAGE - 11/08/2003
	EndIf

	//³ Executa um poss¡vel ponto de entrada, neste caso grava o dese³
	//³ jado no inicializador padr„o.                    		        ³
	If lfa050S
		Execblock("FA050S",.f.,.f.)
	Endif
	If lFA050SUB
		aIniCpos := ExecBlock("FA050SUB",.f.,.f.)    // array com nome de campos a serem inicializados
	Else
		//³ Verifica campos do usuario      			  ³
		dbSelectArea("SX3")
		dbSeek("SE2")
		While !Eof() .and. X3_ARQUIVO == "SE2"
			If sx3->x3_propri == "U" .and. SX3->X3_CONTEXT # "V"
				Aadd(aIniCpos,sx3->x3_campo)
			Endif
			dbSkip()
		Enddo
	Endif
	//³ Validação para desconsiderar o SIGAEIC                     ³
	If Len(aIniCpos) > 0 .And. nModulo <> 17

		If Select("__SUBS") == 0
			ChkFile("SE2",.F.,"__SUBS")
		Endif

		If !(Type("bIniciaVal") = "B") // Não executa na integração com SigaEic
			dbSelectArea("__SUBS")
			nRegAtu := Recno()
			While !Eof()
				If E2_OK == cMarca
					//³ Inicializa array com dados do 1o. registro selecionado p/  ³
					//³ substituicao.                                              ³
					For nInd:= 1 to Len(aIniCpos)
						cCampo := "__SUBS->"+Alltrim(aIniCpos[nInd])
						&("M->"+aIniCpos[nInd]) := &cCampo
					Next
					Exit
				Endif
				dbSkip()
			EndDo
			dbSelectArea("__SUBS")
			dbGoto(nRegAtu)
		EndIf
		RestArea(aArea)
	Endif
Endif
Return .T.

/*/
±±³Fun‡…o	 ³f050VldPa ³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 10/04/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida a modalidade SPB do Pa							 			  ³±±
/*/
Function F050VldPa()
Local lRet := .T.
Local nMoeda	:=	0
Local cNatFor	:= ""
Local aArea		:= GetARea()
Local aAreaSA6 := SA6->(GetArea())
Local aAreaSA2	:= SA2->(GetArea())

If lRet .And. !cPaisLoc $ "BRA|BOL|ANG|PER" .And. M->E2_TIPO $ MVPAGANT
	SA6->(DbSetOrder(1))
	SA6->(MsSeek(xFilial() + cBancoAdt + cAgenciaAdt + cNumCon))
	nMoeda   := Max(IIf(Type("SA6->A6_MOEDAP")=="U",SA6->A6_MOEDA,If(SA6->A6_MOEDAP>0,SA6->A6_MOEDAP,SA6->A6_MOEDA)),1)
	If nMoeda <> M->E2_MOEDA
		Help( " ", 1, "FA050MOEDA")
		lRet	:=	.F.
	Endif
Endif

If lRet .And. cPaisLoc $ "ARG|ANG|MEX|COL"

	If MV_PAR05 != 1 .OR. MV_PAR09 != 2 .Or. Empty(cChequeAdt)
		Help( " ", 1, "FA050CHOB",, STR0154, 4, 0 ) // "É obrigatório emissão de cheque para adiantamento e movimentação sem cheque!"
		lRet := .F.
	EndIf
	If cPaisLoc $ "ARG|ANG"
		cNatFor	:= Posicione("SA2", 1, xFilial("SA2") + M->E2_FORNECE + M->E2_LOJA , "A2_NATUREZ" )
		If lRet .And. Empty(cNatFor)
			Help( " ", 1, "FA050FORNA",, STR0155, 4, 0 ) // "É obrigatório a natureza do fornecedor para geracao do cheque"
			lRet := .F.
		EndIf
	EndIf
EndIf

RestArea(aAreaSA2)
RestArea(aAreaSA6)
RestArea(aArea)

Return lRet

/*
±±³Programa  ³F050ConVal ³Autor  ³Mauricio Pequim Jr    ³ Data ³ 16/04/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Desc.     ³Converte o valor dos campos para a moeda escolhida para     ³±±
±±³          ³apresentacao no MSSelect()                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Substitucao de Titulos                                      ³±±
*/
Function F050ConVal(nMoeda)
Local nValorCpo := Round(NoRound(xMoeda(E2_SALDO+E2_ACRESC-E2_DECRESC,E2_MOEDA,nMoeda,,3),3),2)
Return nValorCpo

/*/
±±³Fun‡…o	 ³Fa050Rateio³ Autor ³ Wagner Mobile Costa  ³ Data ³ 04/08/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Visualizacao do Rateio de Contas a Pagar - > SIGACTB        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³Fa050Rateio(cAlias,nReg,nOpc) 							  ³±±
/*/
Function Fa050Rateio(cAlias,nReg,nOpc)
Local nInss := 0
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local	lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)

Local lCalcIssBx :=	 IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"

RegToMemory("SE2",.F.,.F.)

If ! Empty(SE2->E2_ARQRAT) .AND. CtbInUse()
	CtbRatFin("511","FINA050","",5,SE2->E2_ARQRAT,2)
ElseIf SE2->E2_MULTNAT = "1" .And. !lF050CMNT
	M->E2_VALOR	:= SE2->E2_VALOR
	M->E2_IRRF 	:= SE2->E2_IRRF
	M->E2_INSS 	:= SE2->E2_INSS
	M->E2_ISS 	:= SE2->E2_ISS

	If !lInssBx
		nInss := M->E2_INSS
		IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
			nInss := 0
		Endif
	Endif

	MultNat(	"SE2" /*cAlias*/,;
	0 /*@nHdlPrv*/,;
	SE2->E2_VALOR /*@nTotal*/,;
	"" /*@cArquivo*/,;
	.F. /*lContabiliza*/,;
	2 /*nOpc*/,;
	If(	/*lExpr*/	mv_par06 == 1,;
	/*T*/	If( lIRPFBaixa, 0, SE2->E2_IRRF ) +;
	If( !lCalcIssBx, SE2->E2_ISS, 0 ) +;
	nInss +;
	SE2->E2_RETENC +;
	M->E2_SEST +;
	If( lPccBaixa, 0, E2_PIS + E2_COFINS + E2_CSLL ),;
	/*F*/	0) /*lRatImpostos*/,;
	/*aColsM*/,;
	/*aHeaderM*/,;
	/*aRegs*/,;
	/*lGrava*/,;
	/*lMostraTela*/,;
	/*lRotAuto*/,;
	/*lUsaFlag*/,;
	/*@aFlagCTB*/ )
Else
	Help("",1,	"NoRateio",,	CHR(13)+;
	STR0111 + SE2->E2_NUM + CHR(13),4,0) //"Para o titulo "
Endif

// Verifica o arquivo de rateio, e apaga o arquivo temporario
// para que no proximo rateio seja criado novamente
If Select("TMP") > 0
	DbSelectArea( "TMP" )
	DbCloseArea()
EndIf

If _oFINA0501 <> NIL
	_oFINA0501:Delete()
	_oFINA0501:= NIL
EndIf

Return .T.

/*
±±ºPrograma  ³GERAPARCSE2ºAutor  ³Claudio D. de Souza º Data ³  14/10/02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Gera parcelas no SE2, baseado nas condicoes de pagamento ou  º±±
±±º          ³na quantidade definidade pelo usuario                        º±±
*/
Static Function GeraParcSe2(cAlias, lEnd,nHdlPrv,nTotal,cArquivo,nSavRecA2,nSavRec,lUsaFlag,aFlagCTB)

Local nTamParc		:= TamSx3("E2_PARCELA")[1]
Local cHistSE2		:= IIf(!Empty(cHistDsd),cHistDsd,SE2->E2_HIST)

//Alimentando a parcela inicial com o que foi definido no campo E2_PARCELA ou com o conteudo inicial do parametro MV_1DUP
//Formatando o valor da parcela do titulo originador com o tamanho definido no SX3
Local cTipoPar		:= IIf(SuperGetMV("MV_1DUP")$"0123456789" .OR. (!Empty(SE2->E2_PARCELA) .AND.;
						!Upper(AllTrim(SE2->E2_PARCELA)) $ "ABCDEFGHIJKLMNOPQRSTUVXWYZ"),"N","C")
Local cParcSE2 		:= IIf(cTipoPar == "N",;
						IIf(Empty(SE2->E2_PARCELA),StrZero(Val(SuperGetMV("MV_1DUP")),nTamParc),SE2->E2_PARCELA),;
						IIf(Empty(SE2->E2_PARCELA),SuperGetMV("MV_1DUP"),SE2->E2_PARCELA))

Local nMoedSe2		:= SE2->E2_MOEDA
Local aCampos		:= {}
Local nX			:= 0
Local nI			:= 0
Local a050Desd		:= {}
Local lSpbinUse		:= SpbInUse()
Local cModSpb		:= ""
Local lAcresc		:= .f.
Local lDecresc		:= .f.
Local cPadrao		:= ""
Local lPadrao		:= .F.
Local nValSaldo		:= 0
Local nSomaRateio 	:= 0
Local nTxMoeda		:= SE2->E2_TXMOEDA
Local cMultNat		:= ""
Local cRateio		:= ""
Local lPCCBaixa		:= SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local lIRPFBaixa 	:= IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)

Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

//Rastreamento
Local lRastro 		:= FVerRstFin()
Local aRastroOri	:= {}
Local aRastroDes	:= {}
Local cPrefixo		:= ""
Local cNum			:= ""
Local cTipo			:= ""
Local cFornece		:= ""
Local cLoja			:= ""
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"

//³Parametro que permite ao usuario utilizar o desdobramento da maneira anterior ao implementado com o rastreamento.  ³
Local lNRastDSD		:= SuperGetMV("MV_NRASDSD",.T.,.F.)
Local lAtuSldNat 	:= .T.

//Desdobramento com Imposto
Local nRecOrig 		:= SE2->(RECNO())
Local lCalcImp 		:= F050BSIMP(3,7)
Local aNaoGera 		:= {}
Local lFa050Des		:= ExistBlock("FA050DES")
Local lF050DESD 	:= ExistBlock("F050DESD")
Local lF050DIMP 	:= ExistBlock("F050DESIMP")
Local lF050GRDS		:= ExistBlock("F050GRDS")
Local aRet			:= {}
Local nMCusto:=Val(GetMV("MV_MCUSTO"))
Local nSomaImp        := 0
Local nMaxPar := 0
Local aFKF := {}
Local nProp := 0

PRIVATE lMsErroAuto := .F.

dbselectarea("SE2")

ProcRegua(Len(aParcelas))

// Carrega em aCampos o conteudo dos campos do SE2
For nX := 1 To fCount()
	Aadd(aCampos, {FieldName(nX), FieldGet(nX)})
Next
VALOR := 0
If lSpbInUse
	cModSpb := SE2->E2_MODSPB
Endif
//³ Apaga registro que originou o desdobramento         ³
a050Desd := {}
IF lF050DESD
	a050Desd := ExecBlock( "F050DESD" )
ENDIF

If lNRastDSD .AND. lRastro
	//Desativar o rastreamento ja que o titulo original deixara de existir, o que impossibilitara o rastreamento entre o original e os desdobramentos
	lRastro := .F.
Endif

//Caso não seja base TOP, mantem o processo antigo
If !lRastro
	FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
	Reclock("SE2",.F.,.T.)
	dbDelete()
	msUnLock()
Else
	Reclock("SE2")
	Replace E2_SDACRES With E2_ACRESC
	Replace E2_SDDECRE With E2_DECRESC
	//Incluso novo Status=D (Desdobramento) para que o titulo Pai do desdobramento não seja considerado no calculo de imposto
	Replace E2_STATUS With "D"
	Replace E2_LA With "S"	// Contabilização do Registro Base - Contabiliza pela(s) parcela(s) 
	Replace E2_ORIGEM With IIF(Empty(E2_ORIGEM),"FINA050",E2_ORIGEM)
	MsUnlock()
Endif

//Dados do titulo principal
cPrefixo	:= aCampos[Ascan(aCampos,{|e| e[1] == "E2_PREFIXO"})][1]
cNum		:= aCampos[Ascan(aCampos,{|e| e[1] == "E2_NUM"})][1]
cTipo		:= aCampos[Ascan(aCampos,{|e| e[1] == "E2_TIPO"})][1]
cFornece	:= aCampos[Ascan(aCampos,{|e| e[1] == "E2_FORNECE"})][1]
cLoja		:= aCampos[Ascan(aCampos,{|e| e[1] == "E2_LOJA"})][1]
cMultNat 	:= aCampos[Ascan(aCampos,{|e| e[1] == "E2_MULTNAT"})][2]
cRateio  	:= aCampos[Ascan(aCampos,{|e| e[1] == "E2_RATEIO"})][2]

//Preenche com os dados da FKF posicionada do titulo original
If cPaisLoc == "BRA" .and. AliasInDic("FKF")
	aFKF := { 	{ "FKF_CPRB"  , FKF->FKF_CPRB     , NIL },;
	{ "FKF_CNAE"  , FKF->FKF_CNAE     , NIL },;
	{ "FKF_TPREPA", FKF->FKF_TPREPA   , NIL },;
	{ "FKF_TPSERV", FKF->FKF_TPSERV   , NIL },;
	{ "FKF_INDDEC", FKF->FKF_INDDEC   , NIL },;
	{ "FKF_INDSUS", FKF->FKF_INDSUS   , NIL }}
EndIf
//Rastreamento de titulos em desdobramento
cChvTitDsd := ""
If lRastro
	aAdd(aRastroOri,{E2_FILIAL,;
	E2_PREFIXO,;
	E2_NUM,;
	E2_PARCELA,;
	E2_TIPO,;
	E2_FORNECE,;
	E2_LOJA,;
	E2_VALOR })
	cChvTitDsd:= E2_FILIAL + E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA
Endif

lAcresc	:=	lDecresc := .F.
If Len(aParcelas)== Len(aParcAcre)
	lAcresc := .T.
Endif
If Len(aParcelas)== Len(aParcDecre)
	lDecresc := .T.
Endif

//So deve proporcionalizar quando o valor do titulo for rateado entre as parcelas.
If MV_MULNATP .And. SE2->E2_MULTNAT == "1" .and. Left(cSE2TpDsd,1) == "T"
    nProp := (SE2->E2_VALOR / Len(aParcelas)) / SE2->E2_VALOR
    aEval(aColsSev,{ |e| e[2] *= nProp} ) // Altera o valor conforme a fracao da parcela    
    If Select("SEZTMP") > 0
        SEZTMP->(DbGotop())
        While SEZTMP->(!Eof())
            RecLock("SEZTMP",.F.)
            SEZTMP->EZ_VALOR *= 	nProp
            MsUnlock()
            SEZTMP->(DbSkip())
        End
        DbSelectArea("SE2")
    Endif
Endif
//Verificacao de conflito de parcela independente da gravacao, para evitar interrupcao na gravacao do desdobramento no meio do processo.
//Correcao da baixa indevida do titulo, caso o usuario opte pelo cancelamento do desdobramento
For nI := 1 to Len(aParcelas)
	cParcSE2 := Right("000"+cParcSE2,nTamParc)
	// Para o caso de o titulo que estou incluindo possuir o campo E2_PARCELA preeenchido.
	If Alltrim(M->E2_PARCELA) == Alltrim(cParcSE2)
		cParcSE2 := Soma1(cParcSE2,nTamParc,.T.)
	Endif
	If MsSeek(xFilial("SE2")+&cPrefixo+&cNum+cParcSE2+&cTipo+&cFornece+&cLoja)
		If IW_MsgBox(STR0113 + cParcSe2 + STR0114,STR0115, "YESNO",2) //"Parcela "###" já está cadastrada. Abandona Desdobramento?"###"Atenção"
			lEnd := .T.
			Exit
		Else
			AAdd( aNaoGera, aParcelas[nI,1] )
		Endif
		cParcSE2 := Soma1(cParcSE2,nTamParc,.T.)
	Endif
Next nI

If !EMPTY(aNaoGera)// No caso do campo Parcela em Branco, busca a ultima parcela para a chave.
	dbSelectArea("SE2")

	cQuery := "select MAX(E2_PARCELA) as ParcMax "
	cQuery += "FROM " + RetSqlName("SE2") + " SE2 "
	cQuery += "WHERE E2_FILIAL = '" + xFilial("SE2") + "' AND "
	cQuery += "E2_PREFIXO ='" +  &cPrefixo + "'AND E2_NUM ='" + &cNum + "'AND "
	cQuery += "E2_TIPO ='" + &cTipo + "' AND E2_FORNECE ='" + &cFornece + "' AND "
	cQuery += "E2_LOJA ='" + &cLoja + "' AND D_E_L_E_T_ = ' '"
	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "QueryParc", .F., .T.)
	nMaxPar:= QueryParc->ParcMax
	cParcSE2 := Soma1(nMaxPar,nTamParc,.T.)
	aNaoGera := {}
	dbSelectArea("SE2")
	QueryParc->(dbCloseArea())
Endif

IF lFa050Des
	aRet := ExecBlock("FA050DES",.f.,.f., aParcelas)
	If Valtype(aRet) == "A"
		aParcelas := Aclone(aRet)
	EndIf
Endif
If lEnd
	//Voltando o titulo como aberto, ja que o desdobramento foi cancelado
	If lRastro
		dbSelectArea(cAlias)
		RecLock(cAlias,.F.)
		Replace E2_SALDO	With E2_VALOR
		Replace E2_BAIXA	With CtoD("//")
		Replace E2_VALLIQ	With 0
		Replace E2_STATUS	With "A"
		Replace E2_FILORIG	With xFilial(cAlias)
		Replace E2_DESDOBR	With "N"
		MsUnlock()
	EndIf
	Return
Else
	For  nI := 1 to Len(aParcelas)
		// Somente gera parcela de desdobramento se passou na validacao anterior
		If aScan( aNaoGera, aParcelas[nI,1] ) == 0
			cParcSE2 := Right("000"+cParcSE2,nTamParc)
			If DbSeek(xFilial("SE2")+&cPrefixo+&cNum+cParcSE2+&cTipo+&cFornece+&cLoja)
				//Formatando o valor da parcela de acordo com o seu tamanho para fazer com que a
				//sequencia dos desdobramentos siga a sequencia da parcela declarada em E2_PARCELA,
				//independentemente do tamanho utilizado no campo.
				//Ex: Se parcela for definida como 3, a sequencia sera 04 e nao 31 como estava antes.
				If cTipoPar == "N"
					cParcSE2 := StrZero(Val(cParcSE2),nTamParc)
				Endif
				cParcSE2 := Soma1(cParcSE2,nTamParc,.T.)
			Else
				IncProc(STR0112 + cParcSe2) //"Gerando parcela "
				nValSaldo += aParcelas[nI,2]
				//Desdobramento em método novo com rotina Automatica
				If !lF050Auto .and. lCalcImp
					dbGoto(nRecOrig)
					_aTit := {}
					AADD(_aTit , {"E2_PREFIXO",SE2->E2_PREFIXO					,NIL})
					AADD(_aTit , {"E2_NUM"    ,SE2->E2_NUM						,NIL})
					AADD(_aTit , {"E2_PARCELA",cParcSE2                      	,NIL})
					AADD(_aTit , {"E2_TIPO"   ,SE2->E2_TIPO                    	,NIL})
					AADD(_aTit , {"E2_NATUREZ",SE2->E2_NATUREZ		       		,NIL})
					AADD(_aTit , {"E2_FORNECE",SE2->E2_FORNECE                 	,NIL})
					AADD(_aTit , {"E2_LOJA"   ,SE2->E2_LOJA                     ,NIL})
					AADD(_aTit , {"E2_EMISSAO",SE2->E2_EMISSAO                  ,NIL})
					AADD(_aTit , {"E2_VENCTO" ,aParcelas[nI,1]         			,NIL})
					AADD(_aTit , {"E2_VENCREA",DataValida(aParcelas[nI,1],.T.)  ,NIL})
					AADD(_aTit , {"E2_DATAAGE",DataValida(aParcelas[nI,1],.T.)  ,NIL})
					AADD(_aTit , {"E2_VENCORI",aParcelas[nI,1]      			,NIL})
					AADD(_aTit , {"E2_EMIS1"  ,IIf(Type("dDataEmis1") # "U", IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)	,NIL})
					AADD(_aTit , {"E2_MOEDA" , SE2->E2_MOEDA                  	,NIL})
					AADD(_aTit , {"E2_VALOR" , aParcelas[nI,2]                  ,NIL})
					AADD(_aTit , {"E2_VLCRUZ" ,Round(NoRound(xMoeda(aParcelas[nI,2],nMoedSE2,1,dDataBase,MsDecimais(1)+1,nTxMoeda),MsDecimais(1)+1),MsDecimais(1))	,NIL})
					AADD(_aTit , {"E2_ORIGEM"  ,"FINA050"                 		,NIL})
					AADD(_aTit , {"E2_HIST"		,cHistSE2                 		,NIL})
					If lAcresc
						AADD(_aTit , {"E2_ACRESC",aParcAcre[nI,2]	, NIL})
						AADD(_aTit , {"E2_SDACRES",aParcAcre[nI,2]	, NIL})
					Endif
					If lDecresc
						AADD(_aTit , {"E2_DECRESC",aParcDecre[nI,2]	, NIL})
						AADD(_aTit , {"E2_SDDECRE",aParcDecre[nI,2]	, NIL})
					Endif
					If lSpbInUse
						AADD(_aTit , {"E2_MODSPB",cModSpb, NIL})
					Endif
					AADD(_aTit , {"E2_DIRF"		,SE2->E2_DIRF		, NIL})
					AADD(_aTit , {"E2_CODRET"	,SE2->E2_CODRET		, NIL})

					aAdd(_aTit,{"AUTCMTIT",aFKF,Nil})

					If lF050DIMP
						_aTit := Execblock("F050DESIMP",.F.,.F.,{_aTit})
					Endif

					For nX := 1 To Len(aCampos)
						If aScan(_aTit, { |x| x[1] == aCampos[nX,1]}) <= 0 .And.;
						!aCampos[nX][1] $ "E2_DESDOBR|E2_BASECOF|E2_BASEPIS|E2_BASECSL|E2_BASEIRF|E2_BASEINS|E2_BASEISS|" //Campos que devem ficar fora do array _aTit
							aAdd(_aTit,{aCampos[nX][1],aCampos[nX][2],Nil})
						EndIf
					Next nX
					//Chamada da rotina automatica
					//3 = inclusao
					MSExecAuto({|x, y| FINA050(x, y)}, _aTit, 3)

					If lMsErroAuto
						MOSTRAERRO()
						DisarmTransaction()
						Exit
					Endif

					//Gravacoes complementares
					RecLock("SE2",.F.)
					SE2->E2_MULTNAT := cMultNat
					SE2->E2_DESDOBR := "S"
					MsUnlock()
				Else

					RecLock(cAlias,.T.)

					// Descarrega aCampos no SE2 para que todos os campos preenchidos no titulo principal
					// sejam replicados aos titulos gerados no desdobramento.
					For nX := 1 To fCount()
						If !Empty(aCampos[nX][2])
							FieldPut(nX,aCampos[nX][2])
						Endif
					Next
					// Grava o restante dos campos que variam conforme a parcela
					Replace 	E2_VENCTO 	With aParcelas[nI,1]	,;
					E2_VALOR	With aParcelas[nI,2]	,;
					E2_PARCELA 	With cParcSE2			,;
					E2_HIST    	With cHistSE2			,;
					E2_EMIS1	With IIf(Type("dDataEmis1") # "U", IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)	,;
					E2_VENCORI	With aParcelas[nI,1]	,;
					E2_SALDO	With aParcelas[nI,2]	,;
					E2_ORIGEM  	With "FINA050"			,;
					E2_VENCREA 	With DataValida(aParcelas[nI,1],.T.) ,;
					E2_DATAAGE 	With DataValida(aParcelas[nI,1],.T.) ,;
					E2_VLCRUZ	With Round(NoRound(xMoeda(aParcelas[nI,2],nMoedSE2,1,dDataBase,MsDecimais(1)+1,nTxMoeda),MsDecimais(1)+1),MsDecimais(1))

					If lAcresc
						Replace	E2_ACRESC  with aParcAcre[nI,2],;
						E2_SDACRES With aParcAcre[nI,2]
					Endif
					If lDecresc
						Replace	E2_DECRESC with aParcDecre[nI,2],;
						E2_SDDECRE With aParcDecre[nI,2]
					Endif
					If lSpbInUse
						Replace	E2_MODSPB with cModSpb
					Endif

					If lAtuSldNat .And. SE2->E2_MULTNAT # "1" .And. SE2->E2_FLUXO == 'S'
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "+")
					Endif
				Endif

				IF lfa050Par
					ExecBlock("FA050PAR",.f.,.f., a050Desd)
				Endif

				//Rastreamento de titulos em desdobramento
				If lRastro
					nSomaImp := 	IIf( lIRPFBaixa , 0 , SE2->E2_IRRF	)	+ ;
					IIf( lCalcIssBx , 0 , SE2->E2_ISS	)	+ ;
					IIf( lPCCBaixa  , 0 , SE2->E2_VRETPIS		+ SE2->E2_VRETCOF + SE2->E2_VRETCSL) + ;
					IIf( lInssBx , 0, SE2->E2_INSS)

					aAdd(aRastroDes,{	E2_FILIAL,;
					E2_PREFIXO,;
					E2_NUM,;
					E2_PARCELA,;
					E2_TIPO,;
					E2_FORNECE,;
					E2_LOJA,;
					E2_VALOR,;
					nSomaImp } )
				Endif

				If MV_MULNATP .And. SE2->E2_MULTNAT == "1"
					RegToMemory("SE2",.F.,.F.)
					M->E2_MULTNAT := aCampos[Ascan(aCampos,{|e| e[1] == "E2_MULTNAT"})][2]
					nSomaRateio := 0
					aEval(aColsSev, { |e| nSomaRateio += Round(e[2],2) } ) // Soma o valor das multiplas naturezas
					// Coloca a diferenca entre o valor do titulo e a soma dos rateios na ultima parcela do rateio
					aColsSev[Len(aColsSev)][2] += (SE2->E2_VALOR - nSomaRateio)
					If SELECT("SEZTMP") > 0
						For nX := 1 To Len(aColsSev)
							If aColsSev[nX][4] == "1"
								nSomaRateio := 0
								If SEZTMP->(DbSeek(aColsSev[nX][1]))
									While SEZTMP->(!Eof()) .And.;
									SEZTMP->EZ_NATUREZ == aColsSev[nX][1]
										nSomaRateio +=	Round(SEZTMP->EZ_VALOR,2)
										SEZTMP->(DbSkip())
									Enddo
									SEZTMP->(DbSkip(-1))
									RecLock("SEZTMP")
									SEZTMP->EZ_VALOR += (Round(aColsSev[nX][2],2) - nSomaRateio)
									MsUnlock()
								Endif
							Endif
						Next
					EndIf
					dbSelectArea("SE2")
					GrvSevSez(cAlias,aColsSev,aHeaderSev,,;
					If(mv_par06 == 1,If(lIRPFBaixa,0,M->E2_IRRF)+If(!lCalcIssBx,M->E2_ISS,0)+If(!lInssBx,M->E2_INSS,0)+;
					IIF(lPccBaixa,0,M->E2_PIS+M->E2_COFINS+M->E2_CSLL)+;
					M->E2_RETENC+M->E2_SEST,0),.F.,"FINA050",mv_par04==1,@nHdlPrv,@nTotal,@cArquivo, .T.)
				Endif
				If SE2->E2_RATEIO $ "1S"  .And. Select("TMP") > 0
					If CtbInUse()
						nSomaRateio := 0
						TMP->(DbEval({ || 	TMP->CTJ_VALOR := (TMP->CTJ_PERCEN/100) * SE2->E2_VALOR ,;
						nSomaRateio += Round(TMP->CTJ_VALOR,2) })) // Altera o valor conforme a fracao da parcela
						TMP->(DbGoBottom())
						RecLock("TMP")
						TMP->CTJ_VALOR += (SE2->E2_VALOR - nSomaRateio)
						MsUnlock()
						dbSelectArea("SE2")
					EndIf
				Endif
				RegToMemory("SE2",.F.,.F.)
				// Contabiliza o rateio
				cSeq := Fa050GerLc( "511",cLote, "FINA050", 3, @nHdlPrv, @nTotal )
				If !Empty(cSeq)
					RecLock("SE2")
					Replace E2_ARQRAT		With cSeq
					If mv_par04 != 2
						Replace E2_LA			With "S"
					EndIf
				EndIf
				cSeqCv4 := Nil // Para gerar nova numeracao na proxima parcela
			Endif
		Endif

		Replace SE2->E2_DESDOBR With If(cRateio != "S" .And. cMultNat != "1","S","N") // Se nao rateia desdobramento
		MsUnlock()
		FKCOMMIT()
		//³ Atualiza Saldos do Fornecedor          	  ³
		If lF050Auto .or. !lCalcImp
			// Quando possui imposto o saldo é atualizado no A050DupPag
			dbSelectArea("SA2")
			SA2->(dbGoto(nSavRecA2))
			Reclock("SA2" )
			SA2->A2_SALDUP += Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,3),3),2)
			SA2->A2_SALDUPM+= Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,nMoeda,SE2->E2_EMISSAO,3),3),2)
			If ( SA2->A2_SALDUPM > SA2->A2_MSALDO )
				SA2->A2_MSALDO := SA2->A2_SALDUPM
			EndIf
			SA2->A2_PRICOM  := Iif(SE2->E2_EMISSAO<A2_PRICOM .Or. Empty(SA2->A2_PRICOM),SE2->E2_EMISSAO,SA2->A2_PRICOM)
			SA2->A2_ULTCOM  := Iif(SA2->A2_ULTCOM<SE2->E2_EMISSAO,SE2->E2_EMISSAO,SA2->A2_ULTCOM)
			SA2->A2_NROCOM  := SA2->A2_NROCOM + 1
			If ( SA2->A2_MCOMPRA < Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,nMCusto,SE2->E2_EMISSAO,3),3),2) )
				SA2->A2_MCOMPRA := Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,nMCusto,SE2->E2_EMISSAO,3),3),2)
			EndIf
			SA2->A2_MNOTA   := Max(SA2->A2_MNOTA,Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,nMCusto,SE2->E2_EMISSAO,3),3),2) )
			SA2->(MsUnlock())
		EndIf

		//³ Rotina de contabiliza‡„o do titulo de desdobramento ³
		IF !E2_TIPO $ MVPROVIS .or. mv_par02 == 1
			If SE2->E2_RATEIO != "S" .And. SE2->E2_MULTNAT != "1" // Se nao rateia desdobramento
				cPadrao:="577"
				lPadrao:=VerPadrao(cPadrao)
				If lPadrao .and. mv_par04 == 1 // Contabiliza On-Line
					IF nHdlPrv <= 0
						//³ Inicializa Lancamento Contabil                                   ³
						nHdlPrv := HeadProva( cLote,;
						"FINA050" /*cPrograma*/,;
						Substr(cUsuario,7,6),;
						@cArquivo )
					Endif
					If nHdlPrv > 0
						//³ Prepara Lancamento Contabil                                      ³
						If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
							aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
						Endif
						nTotal += DetProva( nHdlPrv,;
						cPadrao,;
						"FINA050" /*cPrograma*/,;
						cLote,;
						/*nLinha*/,;
						/*lExecuta*/,;
						/*cCriterio*/,;
						/*lRateio*/,;
						/*cChaveBusca*/,;
						/*aCT5*/,;
						/*lPosiciona*/,;
						@aFlagCTB,;
						/*aTabRecOri*/,;
						/*aDadosProva*/ )
					Endif

					If !lUsaFlag
						//³ Atualiza flag de Lan‡amento Cont bil		  ³
						Reclock("SE2")
						Replace E2_LA With "S"
						MsUnLock()
					Endif

				Endif
			Else
				VALOR := 0
				If SE2->E2_MULTNAT == "1"
					SEV->(DbGoto(0)) // Desposiciona SEV para contabilizar as demais sequencias do LP 510
					SEZ->(DbGoto(0)) // Desposiciona SEZ para contabilizar as demais sequencias do LP 510
					If nHdlPrv <= 0
						//³ Inicializa Lancamento Contabil                                   ³
						nHdlPrv := HeadProva( cLote,;
						"FINA050" /*cPrograma*/,;
						Substr(cUsuario,7,6),;
						@cArquivo )
					Endif
					//³ Prepara Lancamento Contabil                                      ³
					If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
						aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
					Endif
					nTotal += DetProva( nHdlPrv,;
					If( cRateio == "S", "511", "510" ) /*cPadrao*/,;
					"FINA050" /*cPrograma*/,;
					cLote,;
					/*nLinha*/,;
					/*lExecuta*/,;
					/*cCriterio*/,;
					/*lRateio*/,;
					/*cChaveBusca*/,;
					/*aCT5*/,;
					/*lPosiciona*/,;
					@aFlagCTB,;
					/*aTabRecOri*/,;
					/*aDadosProva*/ )
				Endif
			Endif
		Endif

		//³ Grava os lancamentos de desdobramento - SIGAPCO ³
		PcoDetLan("000002","03","FINA050")

		cParcSE2 := Soma1(cParcSE2,nTamParc,.F.)

		If GetMv("MV_1DUP") == "A"
			While cParcSE2 <> Upper(cParcSE2) .and. SE2->(MsSeek(xFilial("SE2")+&cPrefixo+&cNum+Upper(cParcSE2)+&cTipo))
				cParcSE2 := Soma1(cParcSE2,nTamParc,.T.)
			EndDo
		EndIf
	Next nI
EndIf

If nTotal > 0
	If SE2->E2_RATEIO != "S" .And. SE2->E2_MULTNAT != "1" // Se nao rateia desdobramento
		dbSelectArea ("SE2")
		dbGoBottom()
		dbSkip()
		VALOR := nValSaldo
		//³ Prepara Lancamento Contabil                                      ³
		//Contabiliza pela variavel VALOR. Nao necessita de controle de flag.
		nTotal += DetProva( nHdlPrv,;
		cPadrao,;
		"FINA050" /*cPrograma*/,;
		cLote,;
		/*nLinha*/,;
		/*lExecuta*/,;
		/*cCriterio*/,;
		/*lRateio*/,;
		/*cChaveBusca*/,;
		/*aCT5*/,;
		/*lPosiciona*/,;
		/*@aFlagCTB*/,;
		/*aTabRecOri*/,;
		/*aDadosProva*/ )
		VALOR := 0
	Endif
Endif
If lF050GRDS
	ExecBlock("F050GRDS",.F.,.F.)
EndIf

//Se existir temporario para rateio c. custo, deleta, pois ele nao foi apagado na rotina que grava o SEV/SEZ para
// nao prejudicar a gravação do rateio para as demais parcelas
If Select("SEZTMP") > 0
	FINXDETMP()
Endif

//³ Caso seja um desdobramento, ir  baixar o	³
//³ titulo gerador do desdobramento				³
F050GrvSE5(1,.T.,nSavRec)

//Gravacao do Rastreamento de titulos em desdobramento FI8
If lRastro
	FINRSTGRV(1,"SE2",aRastroOri,aRastroDes,aRastroOri[1,8])
Endif

Return /*Function GeraParcSe2*/

/*/
±±³Program   ³CtbDigCta ³ Autor ³ Wagner Mobile Costa   ³ Data ³ 06.05.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Habilita/Desabilita objetos para digitacao da conta        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtbDigCta(cRateio, oSayDeb, oDebito, oSayCrd, oCredito)    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T./.F. = Se sim permite a digitacao das contas            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cRateio  = Codigo do Rateio Externo                        ³±±
±±³          ³ oSayDeb  = Objeto say da digitacao a debito                ³±±
±±³          ³ oDebito  = Objeto da digitacao da conta a debito           ³±±
±±³          ³ oSayCrd  = Objeto say da digitacao a credito               ³±±
±±³          ³ oCredito = Objeto da digitacao da conta a credito          ³±±
±±³          ³ lRecFoc  = Caso rateio gerencial seta foco no objeto debito³±±
/*/
Static Function CtbDigCta(	cRateio, oSayDeb, oDebito, oSayCrd, oCredito, cTpEntida,;
lRecFoc)

Local lRetGer 	  := cTpEntida <> Nil
Default cTpEntida := " "
Default lRecFoc	  := .F.

CTJ->(DbSeek(xFilial() + cRateio))

CtjTipoRat("1", @cTpEntida)
CtjTipoRat("2", @cTpEntida)

If lRetGer
	Return cTpEntida > "0"
Endif

If cTpEntida > "0" .And. mv_par03 = 1
	oSayDeb:Enable()
	oDebito:Enable()
	oSayCrd:Enable()
	oCredito:Enable()
	If lRecFoc
		oDebito:SetFocus()
	Endif
Else
	oSayDeb:Disable()
	oDebito:Disable()
	oSayCrd:Disable()
	oCredito:Disable()
Endif

Return .T.

/*
±±³Fun‡„o    ³CtjTipoRat ³ Autor ³ Wagner Mobile Costa  ³ Data ³ 16/09/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna se eh lancamento do tipo solicitado de acordo  com ³±±
±±³          ³ o tipo ou as entidades digitadas                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtjTipoRat(cTipo,cTpEntida,cAlias)           			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T./.F.                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA050                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cTipo = Tipo solicitado para retorno                       ³±±
±±³          ³ cTpEntida = Variavel que identifica validacao por entidade ³±±
±±³          ³ 0 = Identifica que eh um rateio com conta e as demais ent. ³±±
±±³          ³ 1 = Identifica que todos os registro verificara CC         ³±±
±±³          ³ 2 = Identifica que todos os registro verificara Item       ³±±
±±³          ³ 3 = Identifica que todos os registro verificara Classe Val.³±±
*/
Function CtjTipoRat(cTipo, cTpEntida)

Local lRet := .F.

If cTipo = "1"
	If ! lRet
		If 	! Empty(CTJ->CTJ_CCD) .And.;
		(Empty(cTpEntida) .Or. cTpEntida = "1") .And.;
		Empty(CTJ->CTJ_DEBITO)
			lRet := .T.
			cTpEntida := "1"
		Endif
		If 	! lRet .And. ! Empty(CTJ->CTJ_ITEMD) .And.;
		(Empty(cTpEntida) .Or. cTpEntida = "2") .And.;
		Empty(CTJ->CTJ_DEBITO)
			lRet := .T.
			cTpEntida := "2"
		Endif
		If 	! lRet .And. ! Empty(CTJ->CTJ_CLVLDB) .And.;
		(Empty(cTpEntida) .Or. cTpEntida = "3") .And.;
		Empty(CTJ->CTJ_DEBITO)
			cTpEntida := "3"
			lRet := .T.
		Endif
	Endif
ElseIf cTipo = "2"
	If ! lRet
		If 	! Empty(CTJ->CTJ_CCC) .And.;
		(Empty(cTpEntida) .Or. cTpEntida = "1") .And.;
		Empty(CTJ->CTJ_CREDIT)
			lRet := .T.
			cTpEntida := "1"
		Endif
		If 	! lRet .And. ! Empty(CTJ->CTJ_ITEMC) .And.;
		(Empty(cTpEntida) .Or. cTpEntida = "2") .And.;
		Empty(CTJ->CTJ_CREDIT)
			lRet := .T.
			cTpEntida := "2"
		Endif
		If 	! lRet .And. ! Empty(CTJ->CTJ_CLVLCR) .And.;
		(Empty(cTpEntida) .Or. cTpEntida = "3") .And.;
		Empty(CTJ->CTJ_CREDIT)
			lRet := .T.
			cTpEntida := "3"
		Endif
	Endif
Endif

Return lRet

/*/
±±³Funcao    ³Fa050Bar  ³ Autor ³Mauricio Pequim Jr     ³ Data ³15.09.2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Enchoice bar especifica da inclusao de titulos a pagar      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ xValid: 	Validacao do PMS para acrescentar botao           ³±±
/*/
Function FA050Bar(cValidPMS)

Local aButtons := {}
Local aUsButtons
Local lF050BUT	:= ExistBlock( "F050BUT" )

If &(cValidPMS)		// Se usa PMS integrado com o ERP
	AADD(aButtons,{'PROJETPMS',{||Eval(bPmsDlgFI)},STR0094 + " - <F10>",STR0124}) //"Gerenciamento de Projetos"
Endif

//³ Adiciona botoes do usuario na EnchoiceBar                              ³
If lF050BUT
	aUsButtons := ExecBlock( "F050BUT", .F., .F. )
	AEval( aUsButtons, { |x| AAdd( aButtons, x ) } )
EndIf
If cPaisLoc=="BRA"
	aAdd(aButtons, {'CONTAINER'   ,{|| FINA986("SE2") },STR0279,STR0279} )//"Complemento do t­tulo"
EndIf

Return (aButtons)


/*
±±³Fun‡„o    ³FIN050DEL  ³ Autor ³ Simone Mie Sato      ³ Data ³ 17/11/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Altera valores totais quando deleta linha                  ³±±
*/
Function Fin050del()

Local aSaveArea := GetArea()

dbSelectArea("TMP")

If TMP->CTJ_FLAG		// Registro deletado -> eh o contrario pois pressionou <DEL> e o arquivo ainda esta com Flag trocado
	nValRat	+= TMP->CTJ_VALOR
Else
	nValRat	-= TMP->CTJ_VALOR
EndIf

If Type("oValRat")=="O"
	oValRat:Refresh()
Endif


RestArea(aSaveArea)

Return .T.

/*/
±±³Fun‡…o	 ³FA050Pis	³ Autor ³ Claudio D. de Souza   ³ Data ³ 11/12/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza o PIS do t¡tulo.											  ³±±
/*/
Function Fa050PIS()
LOCAL nValor
LOCAL nSaldo
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

If lAltera
	//³ Caso tenha contabilizado, nao posso alterar valores no titulo.     ³
	IF SE2->E2_LA = "S"
		Help(" ",1,"NAOVALOR")
		Return( .F. )
	EndIF
	If SE2->E2_TIPO $ MVPAGANT
		Help( " ",1,"FA040ADTO")
		Return( .F. )
	Endif
	If SE2->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"INA"
		Help( " ",1,"F050IMPOST")
		Return( .F. )
	Endif
Endif

If m->e2_tipo $ MVPAGANT+"/"+MV_CPNEG .and. GetMv("MV_IMPADT") != "S"
	Help( " ",1,"FA040ADTO")
	Return( .F. )
Endif
If m->e2_tipo $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"INA"
	Help( " ",1,"F050IMPOST")
	Return( .F. )
Endif

// Se existir os campos de impostos a pagar, PIS, COFINS, CSLL - MP 135
If nOldPis == m->e2_pis
	Return( .T. )
Else
	lAltValor := .T.
EndIf

//³Guarda valor anterior do PIS para reconstituir valor original ³
//³apenas se for alteracao. Verifica tamb‚m se foi alterada a natu³
//³reza, pois essa alteracao causava problemas na reconstitui‡„o  ³
//³do valor original.                                             ³
If SE2->E2_PIS != 0 .and. m->e2_pis == 0 .and. ;
SE2->E2_NATUREZ == m->e2_naturez .and. lAltera
	nOldPis := SE2->E2_PIS
Endif

dbSelectArea("SED")
dbSeek(cFilial+m->e2_naturez)

// Somente compoe o valor original, caso a geracao dos impostos
// nao sejam pela baixa ou caso seja pagamento antecipado
If !lPccBaixa .Or. m->e2_tipo $ MVPAGANT
	nValor := m->e2_valor + nOldPis
	m->e2_valor := nValor - m->e2_pis

	nSaldo := m->e2_saldo + nOldPis
	m->e2_saldo := nSaldo - m->e2_pis
Endif
M->E2_VLCRUZ:=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))
nOldValor 	:= m->e2_valor
nOldSaldo 	:= m->e2_saldo
nOldPis 		:= m->e2_pis
nVlRetPis := m->e2_pis
lRefresh 	:= .T.

Return .t.

/*/
±±³Fun‡…o	 ³FA050Cofin| Autor ³ Claudio D. de Souza   ³ Data ³ 11/12/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza o COFINS do t¡tulo.										  ³±±
/*/
Function Fa050Cofins()

LOCAL nValor
LOCAL nSaldo
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

If lAltera
	//³ Caso tenha contabilizado, nao posso alterar valores no titulo.     ³
	IF SE2->E2_LA = "S"
		Help(" ",1,"NAOVALOR")
		Return( .F. )
	EndIF
	If SE2->E2_TIPO $ MVPAGANT
		Help( " ",1,"FA040ADTO")
		Return( .F. )
	Endif
	If SE2->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"INA"
		Help( " ",1,"F050IMPOST")
		Return( .F. )
	Endif
Endif

If m->e2_tipo $ MVPAGANT+"/"+MV_CPNEG .and. GetMv("MV_IMPADT") != "S"
	Help( " ",1,"FA040ADTO")
	Return( .F. )
Endif
If m->e2_tipo $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"INA"
	Help( " ",1,"F050IMPOST")
	Return( .F. )
Endif

If nOldCofins == m->e2_cofins
	Return( .T. )
Else
	lAltValor := .T.
EndIf

//³Guarda valor anterior do COFINS p/reconstituir valor original  ³
//³apenas se for alteracao. Verifica tamb‚m se foi alterada a natu³
//³reza, pois essa alteracao causava problemas na reconstitui‡„o  ³
//³do valor original.                                             ³
If SE2->E2_COFINS != 0 .and. m->e2_cofins == 0 .and. ;
SE2->E2_NATUREZ == m->e2_naturez .and. lAltera
	nOldCofins := SE2->E2_COFINS
Endif

dbSelectArea("SED")
dbSeek(cFilial+m->e2_naturez)

// Somente compoe o valor original, caso a geracao dos impostos
// nao sejam pela baixa ou caso seja pagamento antecipado
If !lPccBaixa .Or. m->e2_tipo $ MVPAGANT
	nValor := m->e2_valor + nOldCofins
	m->e2_valor := nValor - m->e2_cofins

	nSaldo := m->e2_saldo + nOldCofins
	m->e2_saldo := nSaldo - m->e2_cofins
Endif
M->E2_VLCRUZ:=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))
nOldValor 	:= m->e2_valor
nOldSaldo 	:= m->e2_saldo
nOldCofins	:= m->e2_cofins
nVlRetCof	:= m->e2_cofins
lRefresh 	:= .T.

Return .t.

/*/
±±³Fun‡…o	 ³FA050Csll	³ Autor ³ Claudio D. de Souza   ³ Data ³ 11/12/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza o CSLL do t¡tulo.											  ³±±
/*/
Function Fa050CSLL()

LOCAL nValor
LOCAL nSaldo
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

If lAltera
	//³ Caso tenha contabilizado, nao posso alterar valores no titulo.     ³
	IF SE2->E2_LA = "S"
		Help(" ",1,"NAOVALOR")
		Return( .F. )
	EndIF
	If SE2->E2_TIPO $ MVPAGANT
		Help( " ",1,"FA040ADTO")
		Return( .F. )
	Endif
	If SE2->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"INA"
		Help( " ",1,"F050IMPOST")
		Return( .F. )
	Endif
Endif

If m->e2_tipo $ MVPAGANT+"/"+MV_CPNEG .and. GetMv("MV_IMPADT") != "S"
	Help( " ",1,"FA040ADTO")
	Return( .F. )
Endif
If m->e2_tipo $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"INA"
	Help( " ",1,"F050IMPOST")
	Return( .F. )
Endif

If nOldCsll == m->e2_csll
	Return( .T. )
Else
	lAltValor := .T.
EndIf

//³Guarda valor anterior do PIS para reconstituir valor original ³
//³apenas se for alteracao. Verifica tamb‚m se foi alterada a natu³
//³reza, pois essa alteracao causava problemas na reconstitui‡„o  ³
//³do valor original.                                             ³
If SE2->E2_CSLL != 0 .and. m->e2_csll == 0 .and. ;
SE2->E2_NATUREZ == m->e2_naturez .and. lAltera
	nOldCsll := SE2->E2_CSLL
Endif

dbSelectArea("SED")
dbSeek(cFilial+m->e2_naturez)

// Somente compoe o valor original, caso a geracao dos impostos
// nao sejam pela baixa ou caso seja pagamento antecipado
If !lPccBaixa .Or. m->e2_tipo $ MVPAGANT
	nValor := m->e2_valor + nOldCsll
	m->e2_valor := nValor - m->e2_csll

	nSaldo := m->e2_saldo + nOldCsll
	m->e2_saldo := nSaldo - m->e2_csll
Endif
M->E2_VLCRUZ:=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))
nOldValor 	:= m->e2_valor
nOldSaldo 	:= m->e2_saldo
nOldCsll		:= m->e2_csll
nVlRetCsl	:= m->e2_csll
lRefresh 	:= .T.

Return .t.

/*/
±±³Fun‡…o	 ³F050VImp  ³ Autor ³ Claudio D. de Souza   ³ Data ³ 11/12/03 		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula a data de vencimento de titulos de impostos IR, PIS		³±±
±±³          ³ COFINS, CSLL                                     		         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ F050VImp(cImposto,dEmissao,dEmis1,dVencRea,cRetencao,cTipoFor,;³±±
±±³			 ³			   lIRPFBaixa)                                           ³±±
/*/
Function F050VImp(cImposto,dEmissao,dEmis1,dVencRea,cRetencao,cTipoFor,lIRPFBaixa) // Calcula o vencimento do imposto

Local nK			:= 0
Local dNextDay 		:= Ctod("//")
Local nTamData 		:= 0
Local nNextMes 		:= 0
Local dDtQuinz 		:= Ctod("//")

Local lLei11196 	:= SuperGetMv("MV_VC11196",.T.,"2") == "1"
Local lMP447    	:= SuperGetMV("MV_MP447",.T.,.F.)
Local nIn480		:= SuperGetMV("MV_IN480",.T.,3)
Local cVencIRPF 	:= GetMv("MV_VCTIRPF",,"")
Local lVencIrrf  	:= (SuperGetMv("MV_VENCIRF",.T.,"V") == "V")
Local lVencPcc  	:= (SuperGetMv("MV_VCPCCP",.T.,1) == 2)
Local dDtFin790	:= dDataBase

Local lAntMP351 	:= .F.
Local lVenctoIN  	:= (SuperGetMv("MV_VENCINS",.T.,"1") == "2")  //1 = Emissao    2= Vencimento Real

Local lVerIRBaixa	:= .F.
Local lEmpPublic	:= SuperGetMv("MV_ISPPUBL" ,.T.,"2") == "1"
Local lINQuinz      := SuperGetMv("MV_IN4815" ,.T.,"Q") == "Q" // Situaçao gerada a partir do chamado SCWLG4, onde foi gerado o boletim tecnico "Vencimento do IRPJ - IN SRF 480"
Local lVencCRet		:= SuperGetMv("MV_CRTVENC" , .T., "2") == "1"
Local aAreaSE2		:= GetArea()
Local nTipo			:= 1
Local lF050MDVC		:= ExistBlock("F050MDVC")
Local lFina631		:= IsinCallStack("FINA631")

Default cRetencao 	:= ""
Default cTipoFor  	:= "J"
Default cImposto	:= ""
Default dEmissao 	:= dDataBase
Default dEmis1		:= dDatabase
Default dVencRea	:= dDatabase
Default lIRPFBaixa := .F.

lVerIRBaixa := Iif(lIRPFBaixa .AND. cImposto == "IRRF",Iif(cTipoFor == "J",.T.,.F.),.T.) // Verifica se IRPJ na Baixa para calcular vencimento de acordo com a regra do PCC

If cImposto == "IRRF" .and. !(lEmpPublic .and. cTipoFor == "J" .AND. lIrpfBaixa)
	//Calculo o Vencimento do IR para Pessoa Fisica
	If cTipoFor == "F" .And. !Empty(cVencIRPF)
		If GetMv("MV_VCTIRPF") == "E"
			dNextDay := dEmissao+1
		Elseif GetMv("MV_VCTIRPF") == "C"
			dNextDay := dEmis1+1
		Else
			dNextDay := dVencRea+1
		EndIf
		//Calculo o Vencimento do IR para Pessoa Juridica
	Else
		If GetMv("MV_VENCIRF") == "E"
			dNextDay := dEmissao+1
		Elseif GetMv("MV_VENCIRF") == "C"
			dNextDay := iIf(lFina631, dEmissao+1 , dEmis1+1)
		Else
			dNextDay := dVencRea+1
		EndIf
	EndIf

	//Fato gerador até 31/12/05
	If (!lLei11196 .or. (dNextDay-1) < CTOD("01/01/06")) .and. ;
	!lMP447 .And.;
	!(AllTrim(cRetencao) $ "8739|8767|6147|6175|6190|6188|9060|8850|5706") .AND. ;
	!Empty(cRetencao)

		For nK:=1 To 7
			If Dow( dNextDay ) = 1
				Exit
			End
			dNextDay++
		Next
		For nK:= 1 to 3
			dNextDay := DataValida(dNextDay+1,.T.)
		Next

	ElseIf AllTrim(cRetencao) $ "8739|8767|6147|6175|6190|6188|9060|8850"

		//Caso seja preenchido com outro valor diferente de 3(3o. dia util) ou 5 (5o. dia util),
		//atribui o valor default 3
		nIn480 := Iif(nIn480 <> 3 .And. nIn480 <> 5,3,nIn480)

		//se aplicar-se o paragrafo II do artigo 5º da IN480, o sistema deverá ir até o final da quinzena
		// para calcular a qtd de dias uteis da semana subsequente.
		If lINQuinz
			dNextDay -= 1 // Retira 1 dia que foi somado
			nTamData := Iif(Len(Dtoc(dNextDay)) == 10, 7, 5)

			If Day(dNextDay) <= 15
				dNextDay := CTOD("16/"+Subs(Dtoc(dVencrea),4,nTamData))
			Else
				nNextMes := Month(dNextDay)+1
				dNextDay := CTOD("01/"+;  //dia
				Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+; //mes
				Substr(Str(Iif(nNextMes==13,Year(dNextDay)+1,Year(dNextDay))),2))    //ano
			EndIf
		EndIf

		For nK:=1 To 7
			If Dow( dNextDay ) = 1
				Exit
			End
			dNextDay++
		Next

		If lINQuinz .and. nIn480 == 5   //ultimo dia útil da semana, se houver somente 4 dias úteis, nao pode cair na semana seguinte
			dNextDay := dNextDay + nIn480
			While DataValida(dNextDay,.T.) <> dNextDay
				dNextDay := dNextDay - 1
			EndDo
		Else
			For nK:= 1 to nIn480
				dNextDay := DataValida(dNextDay+1,.T.)
			Next
		EndIf

	ElseIf (AllTrim(cRetencao) $ "5706#9385#8053#3426")

		dNextDay -= 1 // Retira 1 dia que foi somado
		nNextMes := Month(dNextDay)+1

		If Day(dNextDay) >= 1 .And. Day(dNextDay) <= 10 // Primeiro decendio
			//Posiciono no 1o. dia util do decendio subsequente do fato gerador
			dNextDay := CTOD("11/"+StrZero(Month(dNextDay),2)+"/"+Str(Year(dNextDay)))
		ElseIf Day(dNextDay) >= 11 .And. Day(dNextDay) <= 20 // Segundo decendio
			//Posiciono no 1o. dia util do decendio subsequente do fato gerador
			dNextDay := CTOD("21/"+StrZero(Month(dNextDay),2)+"/"+Str(Year(dNextDay)))
		Else //Terceiro decendio
			//Posiciono no 1o. dia util do decendio subsequente do fato gerador
			dNextDay := CTOD("01/"+If(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+;
			Str(If(nNextMes==13,Year(dNextDay)+1,Year(dNextDay))))
		EndIf

		nI := 1
		While nI <= 3
			If DataValida(dNextday,.T.) == dNextDay
				If nI < 3
					dNextDay += 1
				EndIf
				nI +=1
			Else
				dNextDay += 1
			Endif
		EndDo

	ElseIf AllTrim(cRetencao) $ SuperGetMv("MV_VENCCRC",,"") //Empresas CRC
		//Calculo da data de vencimento do imposto a partir de 26/07/04 - Lei 10925
		nTamData := Iif(Len(Dtoc(dVencrea)) == 10, 7, 5)

		//Calculo com base na Lei 11196 art. 74
		If Day(dVencRea) <= 15
			dNextDay := Ctod(Str(Day(LastDay(dVencRea)),2)+"/"+Subs(Dtoc(dVencrea),4,nTamData))
		Else
			nNextMes := Month(dVencRea)+1
			dNextDay := CTOD("15/"+Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+;
			Substr(Str(Iif(nNextMes==13,Year(dVencRea)+1,Year(dVencRea))),2))
		Endif

		//Acho o ultimo dia util da semana subsequente
		While .T.
			If DataValida(dNextday,.T.) == dNextDay
				Exit
			Else
				dNextDay -= 1
			Endif
		Enddo
		//Media Provisória 447/2008
	ElseIf lMP447 .and. (dNextDay-1) >= CTOD("01/11/08")
		dNextDay -= 1 // Retira 1 dia que foi somado para o calculo anterior.
		//Medida Provisória 447/2008 - Vencimento do IRRF passa a ser no ultimo dia util do segundo decendio
		//do mes subsequente para fatos geradores a partir de 01/11/08
		nNextMes := Month(dNextDay) + 1
		//Monto a data para vigésimo dia do mes subsequente
		dNextDay := CTOD("20/"+Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+ Substr(Str(Iif(nNextMes==13,Year(dNextDay)+1,Year(dNextday))),2))
		//Localiza o ultimo dia util do segundo decenio do mes subsequente
		While .T.
			If DataValida(dNextday,.T.) == dNextDay
				Exit
			Else
				dNextDay -= 1
			Endif
		Enddo
	Else
		dNextDay -= 1 // Retira 1 dia que foi somado para o calculo anterior.
		//Lei 11.196 - Vencimento do IRRF passa a ser no ultimo dia util do primeiro decenio do mes seguinte
		//para fatos geradores a partir de 01/01/06
		nNextMes := Month(dNextDay) + 1
		//Monto a data para decimo dia do mes subsequente
		dNextDay := CTOD("10/"+Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+	Substr(Str(Iif(nNextMes==13,Year(dNextDay)+1,Year(dNextday))),2))
		//Acho o ultimo dia util do primeiro decenio do mes subsequente
		While .T.
			If DataValida(dNextday,.T.) == dNextDay
				Exit
			Else
				dNextDay -= 1
			Endif
		Enddo
	Endif
ElseIf cImposto == "FETHAB"
	nDiaVenc := SuperGetMv("MV_VENCFET",.F.,5)
	nAno := Year(dEmissao)

	nMes     := Month(dEmissao)+1
	If nMes > 12
		nMes := 1
		nAno := Year(dEmissao)+1
	Endif

	dData    := CtoD(StrZero(nDiaVenc,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4))

	If Empty(dData)
		While Empty(dData)
			dData    := CtoD(StrZero(nDiaVenc,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4))
			nDiaVenc--
		EndDo
	Endif

	dNextDay := DataValida(dData,.T.)

ElseIf cImposto == "CIDE"

	nNextMes := Month(dEmissao)+1 // Conforme Legislação o Fator Gerador da CIDE é a Emissão.
	dNextDay := CTOD("15/"+Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+;
	Substr(Str(Iif(nNextMes==13,Year(dEmissao)+1,Year(dEmissao))),2))

	dNextDay	:=	DataValida(dNextday,.F.)


ElseIf cImposto == "INSS"

	//Calculo do Vencto do INSS
	//Por intermedio da Medida Provisoria 351/2007, publicada no DOU 1 de 22.01.2007 (Edicao Extra),
	//foi alterada a data de recolhimento das contribuicoes previdenciarias a cargo da empresa,
	//inclusive as contribuicoes referentes à remuneracao dos empregados, trabalhadores avulsos e a
	//prestacao de servicos do contribuinte individual para o dia 10 do mes seguinte ao da competencia
	//a que se refere.
	If lVenctoIN
		dNextMes := Month(dVencRea)+1
		If dVencRea < CTOD("22/01/07")  //Anterior a MP351
			lAntMP351 := .T.
			dNextVen := CTOD("02/"+IIF(dNextMes==13,"01",StrZero(dNextMes,2))+"/"+;
			Substr(Str(IIF(dNextMes==13,Year(dVencRea)+1,Year(dVencrea))),2))
		Else
			If lMP447 .and. dVencRea > CTOD("01/11/08")
				//Medida Provisória 447/2008 - Vencimento do INSS passa a ser ate o dia 20
				//do mes subsequente ao da competencia.
				//Vencimento para PJ = 20 e PF = 15 (somente para funrural)
				If cTipoFor == "F" .AND. isFunrural()
					dNextVen := CtoD("15/"+IIf(dNextMes==13,"01",StrZero(dNextMes,2))+"/"+;
					Substr(Str(IIF(dNextMes==13,Year(dVencRea)+1,Year(dVencRea))),2))
				Else
					lAntMP351 := .F.
					dNextVen := CTOD("20/"+IIF(dNextMes==13,"01",StrZero(dNextMes,2))+"/"+;
					Substr(Str(IIF(dNextMes==13,Year(dVencrea)+1,Year(dVencrea))),2))
				Endif
			Else
				lAntMP351 := .F.
				dNextVen := CTOD("10/"+IIF(dNextMes==13,"01",StrZero(dNextMes,2))+"/"+;
				Substr(Str(IIF(dNextMes==13,Year(dVencrea)+1,Year(dVencrea))),2))
			Endif
		Endif
	Else
		dNextMes := Month(dEmissao)+1
		If dEmissao < CTOD("22/01/07")  //Anterior a MP351
			lAntMP351 := .T.
			dNextVen := CTOD("02/"+IIF(dNextMes==13,"01",StrZero(dNextMes,2))+"/"+;
			Substr(Str(IIF(dNextMes==13,Year(dEmissao)+1,Year(dEmissao))),2))
		Else
			If lMP447 .and. dEmissao > CTOD("01/11/08")
				//Medida Provisória 447/2008 - Vencimento do INSS passa a ser ate o dia 20
				//do mes subsequente ao da competencia.
				//Vencimento para PJ = 20 e PF = 15 (somente para funrural)
				If cTipoFor == "F" .AND. isFunrural()
					dNextVen := CtoD("15/"+IIf(dNextMes==13,"01",StrZero(dNextMes,2))+"/"+;
					Substr(Str(IIF(dNextMes==13,Year(dEmissao)+1,Year(dEmissao))),2))
				Else
					lAntMP351 := .F.
					dNextVen := CTOD("20/"+IIF(dNextMes==13,"01",StrZero(dNextMes,2))+"/"+;
					Substr(Str(IIF(dNextMes==13,Year(dEmissao)+1,Year(dEmissao))),2))
				Endif
			Else
				lAntMP351 := .F.
				dNextVen := CTOD("10/"+IIF(dNextMes==13,"01",StrZero(dNextMes,2))+"/"+;
				Substr(Str(IIF(dNextMes==13,Year(dEmissao)+1,Year(dEmissao))),2))
			Endif
		Endif
	Endif

	If lMP447
		// Caso seja pessoa física e FUNRURAL a data de vencimento será prorrogada
		If cTipoFor == "F" .AND. isFunrural()

			While .T.
				If DataValida(dNextVen,.T.) == dNextVen
					dNextDay := dNextVen
					Exit
				Else
					dNextVen += 1
				Endif
			Enddo

		Else
			//Caso o dia do vencimento não for util, será considerado antecipado o prazo para o primeiro
			//dia util que o anteceder.
			While .T.
				If DataValida(dNextVen,.T.) == dNextVen
					dNextDay := dNextVen
					Exit
				Else
					dNextVen -= 1
				Endif
			Enddo
		Endif
	Else
		dNextDay := DataValida(dNextVen,.T.)
	Endif

ElseIf !Empty(cImposto)
	If dVencrea < CTOD("16/06/15") .Or. lEmpPublic
		//Calculo da data de vencimento para titulos de PIS, COFINS e CSLL
		//Para o IR na Baixa, segue o mesmo conceito do PCC para o calculo.
		//Verifico se a baixa ou vencimento sao anteriores a Lei 10925 e
		//fato o calculo da data na forma antiga
		If dVencrea < SuperGetMv("MV_RF10925",.t.,CTOD("26/07/04"))
			dNextDay := dVencRea+1
			For nK:=1 To 7
				If Dow( dNextDay ) = 1
					Exit
				Endif
				dNextDay++
			Next
			For nK:= 1 to 3
				dNextDay := DataValida(dNextDay+1,.T.)
			Next
		Else

			//Calculo da data de vencimento do imposto a partir de 26/07/04 - Lei 10925
			nTamData := Iif(Len(Dtoc(dVencrea)) == 10, 7, 5)

			//Lei 11.196 - Vencimento do PIS COFINS e CSLL passa a ser no ultimo dia util da quinzena subsequente
			//para fatos geradores a partir de 01/01/06
			//Art. 74 que altera o art.35 da Lei 10833
			//Alterada pela MP 351 de 21/01/07, art 7 e sequintes:
			// O pagamento da Contribuição para o PIS/PASEP e da COFINS deverá ser efetuado ate o ultimo dia util do
			// segundo decendio subsequente ao mes de ocorrencia dos fatos geradores."


			//Calculo antigo para fatos geradores anteriores a vigencia da Lei ou para onde não se aplique
			If lVerIRBaixa .AND. (!lLei11196 .or. dVencRea < CTOD("01/01/06"))
				//Verifico a quizena do vencimento
				If Day(dVencRea) <= 15
					dDtQuinz := Ctod("15/"+Subs(Dtoc(dVencrea),4,nTamData))
					If Dow(dDtQuinz) == 1   //Se o dia 15 for domingo
						dNextDay := Ctod("27/"+Subs(Dtoc(dVencrea),4,nTamData))
					Else
						dNextDay := Ctod("21/"+Subs(Dtoc(dVencrea),4,nTamData))
					Endif
				Else
					nNextMes := Month(dVencRea)+1
					dDtQuinz := Ctod(Str(Day(LastDay(dVencRea)),2)+"/"+Subs(Dtoc(dVencrea),4,nTamData))
					If Dow(dDtQuinz) == 1   //Se o ultimo dia do mes for domingo
						dNextDay := CTOD("12/"+Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+;
						Substr(Str(Iif(nNextMes==13,Year(dVencRea)+1,Year(dVencRea))),2))
					Else
						dNextDay := CTOD("06/"+Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+;
						Substr(Str(Iif(nNextMes==13,Year(dVencRea)+1,Year(dVencRea))),2))
					Endif
				Endif

				//Acho a Sexta feira da semana subsequente
				nDiaSemana := Dow(dNextDay)
				If nDiaSemana < 6
					dNextDay += 6-nDiaSemana
				ElseIf nDiaSemana > 6
					dNextDay -= 1
				Endif
			ElseIf lLei11196

				//Calculo com base na Lei 11196 art. 74
				If Day(dVencRea) <= 15
					dNextDay := Ctod(Str(Day(LastDay(dVencRea)),2)+"/"+Subs(Dtoc(dVencrea),4,nTamData))

				Else
					nNextMes := Month(dVencRea)+1
					dNextDay := CTOD("15/"+Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+;
					Substr(Str(Iif(nNextMes==13,Year(dVencRea)+1,Year(dVencRea))),2))
				Endif
			Endif
			//Acho o ultimo dia util do periodo desejado
			dNextday := DataValida(dNextday,.F.)
		Endif
	Else
		dNextday := fCRetCal(5, dVencRea)
	EndIf
Endif
//³ Ponto de entrada para que o cliente possa calcular  ³
//³ a data de vencimento                                ³
If lF050MDVC
	dNextDay := ExecBlock("F050MDVC",.F.,.F.,{dNextDay,cImposto,dEmissao,dEmis1,dVencRea,cRetencao})
EndIf

If AliasInDic("FJQ")
	dDtFin790	:= dEmissao
	If cImposto $ "PIS#COFINS#CSLL" .and. lVencPcc
		dDtFin790 := dVencRea
	ElseIf cImposto $ "IRRF" .and. lVencIrrf
		dDtFin790 := dVencRea
	ElseIf cImposto $ "INSS" .and. lVenctoIN
		dDtFin790 := dVencRea
	EndIf
	aAreaSE2	:= GetArea()
	dbSelectArea("FJQ")
	dbSetOrder(1)
	If lVencCRet .and. FJQ->(FieldPos( "FJQ_CODRET" ))>0
		dbSelectArea("FJQ")
		dbSetOrder(1)
		If Iif(Empty(cRetencao), .F., FJQ->(dbSeek(xFilial("FJQ")+cRetencao)))
			nTipo	:= Val(FJQ->FJQ_PERIOD)
			dNextDay	:= fCRetCal(nTipo,dDtFin790)
		EndIf

	EndIF
	RestArea(aAreaSE2)
EndIf

Return dNextDay

/*/
±±³Fun‡…o	 ³F050BxImp ³ Autor ³Mauricio Pequim Jr.    ³ Data ³ 23/01/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se nenhum dos titulos de impostos relacionados a  ³±±
±±³          ³ um titulo em alteração, foram baixados					  ³±±
/*/
Function F050BxImp()

Local lRet 			:= .F.
Local aParc 		:= {SE2->E2_PARCIR,SE2->E2_PARCINS,SE2->E2_PARCISS,SE2->E2_PARCSES,SE2->E2_PARCPIS,SE2->E2_PARCCOF,SE2->E2_PARCSLL}
Local cTaxa 		:= IIF(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA)
Local aTipo 		:= {cTaxa,IF(SE2->E2_TIPO $ MVPAGANT,"INA",MVINSS),MVISS,"SES",cTaxa,cTaxa,cTaxa}
Local cChave 		:= SE2->(E2_PREFIXO+E2_NUM)
Local nX 			:= 1
Local nValImpos 	:= SE2->(E2_IRRF+E2_INSS+E2_ISS+E2_SEST+E2_PIS+E2_COFINS+E2_CSLL)
Local aAreaSE2 		:= SE2->(GetArea())
Local aArea 		:= GetArea()
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa 	:= SuperGetMv("MV_BX10925",.T.,"2") == "1"

If nValImpos > 0
	dbSelectArea("SE2")
	dbSetOrder(1)
	For nX := 1 to Len(aParc)
		If MsSeek(xFilial("SE2")+cChave+aParc[nX]+aTipo[nX])
			While !Eof() .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == xFilial("SE2")+cChave+aParc[nX]+aTipo[nX]
				If( lPCCBaixa == .F. )
					If ( SE2->E2_SALDO == 0)
						//-- Tratamento para o parêmetro MV_BX10925 == 2
						If SE2->E2_TIPO $ aTipo[1] .And. (SE2->E2_PARCELA == aParc[1] .Or. SE2->E2_PARCELA == aParc[5] .Or.;
						   SE2->E2_PARCELA == aParc[6] .Or. SE2->E2_PARCELA == aParc[7] )

							//-- Se existir títulos de PCC baixados não será possível alterar!
							lRet 	:= .T.
							nX		:= Len(aParc)
							Exit
						Else
							DbSkip()
						EndIf
					Else
						DbSkip()
					EndIf
				Else
					If SE2->E2_SALDO == 0
						lRet := .T.
						Exit
					Else
						dbSkip()
					EndIf
				EndIf
			Enddo
			If lRet
				Exit
			Endif
		Endif
	Next
Endif
RestArea(aAreaSE2)
RestArea(aArea)

Return lRet


//------------------------------------------------------------------------------------------
/*/{Protheus.doc} VerInssAcm
Verifica o valor RETIDO de INSS de um fornecedor num determinado periodo.

@author Mauricio PEquim Jr.
@since  11/08/2004
/*/
//------------------------------------------------------------------------------------------
Function VerInssAcm(cFornece,cLoja,cNomeFor,dEmissao,dVencRea,lNFE)

Local nValor	:= 0
Local aArea		:= GetArea()
Local lFilInss	:= SuperGetMV("MV_FILINSS",.T.,.F.)
Local lVencto	:= SuperGetMv("MV_ACMINSS",.T.,"1") == "2"  //1 = Emissao    2= Vencimento Real
Local lTodasFil	:= ExistBlock("F50TFINS")
Local aFilINSS	:= {}
Local nX		:= 0
Local nRegSM0	:= SM0->(RECNO())
Local cEmpAtu	:= SM0->M0_CODIGO
Local cCnpj		:= Substr(SM0->M0_CGC,1,8)
Local cTpAcm	:= SuperGetMv("MV_INSTPAC", .F., "1" ) //Default 1
Local dDataIni	:= CTOD("//")
Local dDataFim	:= CTOD("//")
Local cTablTemp	:= ""
Local LFINA050	:= FUNNAME() == "FINA050"
Local nInssPLS	:= 0

DEFAULT cFornece	:= ""
DEFAULT cLoja		:= ""	
DEFAULT cNomeFor	:= ""
DEFAULT dEmissao	:= CTOD("//")
DEFAULT dVencRea	:= CTOD("//")
DEFAULT lNFE		:= .F.

//Valida se tem a previa de INSS
If __lInssPrev == NIL
	__lInssPrev := AliasInDic("FJW") .And. FindFunction("F027PRINSS")
Endif

//Valida se tem o campo do PLS para obtenção do INSS acumulado no formato antigo
If __lPlOpeLt == NIL
	__lPlOpeLt := __lPlOpeLt := SE2->(FieldPos("E2_PLOPELT")) > 0
Endif

//Verifico todas as filiais apenas quando SA2 compartilhado
If lTodasFil
	aFilINSS := ExecBlock( "F50TFINS", .F., .F. )
Else
	If lFilInss
		dbselectArea ("SM0")
		dbSeek(cEmpAtu)
		While !Eof() .and. SM0->M0_CODIGO == cEmpAtu
			If Substr(SM0->M0_CGC,1,8) == cCnpj
				AADD(aFilINSS,SM0->M0_CODFIL)
			Endif
			dbSkip()
		Enddo
		SM0->(dbGoto(nRegSM0))
	Else
		aFilINSS := { xFilial("SE2") }
	Endif
Endif

If !Empty(cFornece) .and. !Empty(cLoja) .and. !Empty(cNomeFor) .and. If(lVencto, !Empty(dVencRea),!Empty(dEmissao))

	cQuery := "SELECT SUM(E2_INSS) NVALINSS FROM " + RetSQLname("SE2")
	cQuery += " WHERE "
	cQuery += "( "
	For nX:= 1 to Len(aFilINSS)
		cQuery += "E2_FILIAL = '"+ aFilINSS[nX] + "' OR "
	Next nX
	cQuery := Left( cQuery, Len( cQuery ) - 4 )
	cQuery += ") AND "

	cQuery += "E2_FORNECE = '"+ cFornece +"' AND "
	cQuery += "E2_LOJA = '"+ cLoja +"' AND "
	cQuery += "E2_INSS > 0 AND "

	If Type("M->E2_NUM") == "C" .AND. Type("M->E2_PREFIXO") == "C" .AND. ;
		Type("M->E2_PARCELA") == "C" .AND. Type("M->E2_TIPO") == "C"

		If !lFilInss
			cQuery += "NOT(E2_NUM = '"+ M->E2_NUM +"' AND "
			cQuery += "E2_PREFIXO = '"+ M->E2_PREFIXO +"' AND "
			cQuery += "E2_PARCELA = '"+ M->E2_PARCELA +"' AND "
			cQuery += "E2_TIPO = '"+ M->E2_TIPO +"') AND "
		EndIf

	EndIf

	//Cumulatividade para fornecedores pessoa fisica ou juridica
	//http://tdn.totvs.com/pages/viewpage.action?pageId=271413168
	If cTpAcm == "2"	// MV_INSTPAC = '2' - Cumulativo por cinco anos
		dDataIni :=  CTOD('01/'+STR(MONTH(dEmissao))+'/'+STR(YEAR(dEmissao)-5))
		dDataFim :=  LastDay(dEmissao)

		cQuery += "E2_EMISSAO  BETWEEN '" + Dtos(dDataIni) + "' AND '" + Dtos(dDataFim)+ "' AND "
	Else				// MV_INSTPAC = '1' - Cumulativo mensal
		If lVencto
			cQuery += "E2_VENCREA  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
		Else
			cQuery += "E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
		Endif
	Endif

	cQuery += "D_E_L_E_T_ <> '*' "
	cQuery := ChangeQuery(cQuery)
	cTablTemp := GetNextAlias()
	dbUseArea( .T. , "TOPCONN" , TCGenQry(,,cQuery), cTablTemp , .F. , .T. )
	TcSetField( cTablTemp , "NVALINSS" , "N" , 17 , 2 )
	nValor := (cTablTemp)->NVALINSS
	(cTablTemp)->( dbCloseArea() )

	RestArea(aArea)

	//Retorna o saldo de INSS acumulado pelo PLS - Prévias de INSS
	If  __lPlOpeLt .and. !Empty(M->E2_PLOPELT)
		nInssPLS := PlsInssAcm(M->E2_PLOPELT,M->E2_CODRDA,M->E2_ANOBASE,M->E2_MESBASE)
	Else
		If __lInssPrev
			If lNFE
				nInssPLS := F027PRINSS(SA2->A2_COD, SA2->A2_LOJA, dEmissao, dVencrea)
			ElseIf (!M->E2_TIPO $ MVPAGANT) .Or. (LFINA050 .And. M->E2_TIPO $ MVPAGANT )
				nInssPLS := F027PRINSS(SA2->A2_COD,SA2->A2_LOJA,M->E2_EMISSAO,M->E2_VENCREA)
			EndIf
		EndIf
	Endif

	nValor += nInssPLS
Endif

Return (nValor)


//------------------------------------------------------------------------------------------
/*/{Protheus.doc} VerInssCalc
Verifica o valor CALCULADO de INSS de um fornecedor num determinado periodo.

@author Adrianne Furtado
@since  11/08/2004
/*/
//------------------------------------------------------------------------------------------
Function VerInssCalc(cFornece,cLoja,cNomeFor,dEmissao,dVencRea,aRecINSS,nInsRest)

Local nValor 	:= 0
Local aArea 	:= GetArea()
Local aAreaSA2	:= {}
Local lVencto 	:= SuperGetMv("MV_ACMINSS",.T.,"1") == "2"  //1 = Emissao    2= Vencimento Real
Local lTodasFil	:= ExistBlock("F50TFINS")
Local aFilINSS 	:= {}
Local nX		:= 0
Local dDataIni	:= CTOD("//")
Local dDataFim	:= CTOD("//")
Local cTpAcm	:= SuperGetMv("MV_INSTPAC", .F., "1" ) //Default 1

Default aRecINSS := {}
Default nInsRest := 0

//Verifico todas as filiais apenas quando SA2 compartilhado
If lTodasFil
	aFilINSS := ExecBlock( "F50TFINS", .F., .F. )
Else
	aFilINSS := { xFilial("SE2") }
Endif

If !Empty(cFornece) .and. !Empty(cLoja) .and. !Empty(dEmissao) .and. !Empty(cNomeFor)

	//Valida se o fornecedor calcula acumulado - PF
	dbSelectArea("SA2")
	aAreaSA2 := SA2->(GetArea())
	SA2->(dbSetOrder(1))
	If SA2->(dbSeek(xFilial("SA2")+cFornece+cLoja))
		cTpForn := SA2->A2_TIPO
	EndIf
	SA2->(RestArea(aAreaSA2))

	cQuery := "SELECT SUM(E2_VRETINS) NVALINSS FROM " + RetSQLname("SE2")
	cQuery += " WHERE "
	cQuery += "( "
	For nX:= 1 to Len(aFilINSS)
		cQuery += "E2_FILIAL = '"+ aFilINSS[nX] + "' OR "
	Next nX
	cQuery := Left( cQuery, Len( cQuery ) - 4 )
	cQuery += ") AND "

	cQuery += "E2_FORNECE = '"+ cFornece +"' AND "
	cQuery += "E2_LOJA = '"+ cLoja +"' AND "
	cQuery += "E2_VRETINS > 0 AND "
	cQuery += "E2_PRETINS = '1' AND "	//E2_PRETINS = '1' -> Pendente de retenção.

	If Type("M->E2_NUM") == "C" .AND. Type("M->E2_PREFIXO") == "C" .AND. ;
		Type("M->E2_PARCELA") == "C" .AND. Type("M->E2_TIPO") == "C"
		cQuery += "NOT(E2_NUM = '"+ M->E2_NUM +"' AND "
		cQuery += "E2_PREFIXO = '"+ M->E2_PREFIXO +"' AND "
		cQuery += "E2_PARCELA = '"+ M->E2_PARCELA +"' AND "
		cQuery += "E2_TIPO = '"+ M->E2_TIPO +"') AND "
	Elseif Type("SE2->E2_NUM") == "C" .AND. Type("SE2->E2_PREFIXO") == "C" .AND. ;
		Type("SE2->E2_PARCELA") == "C" .AND. Type("SE2->E2_TIPO") == "C"
		cQuery += "NOT(E2_NUM = '"+ SE2->E2_NUM +"' AND "
		cQuery += "E2_PREFIXO = '"+ SE2->E2_PREFIXO +"' AND "
		cQuery += "E2_PARCELA = '"+ SE2->E2_PARCELA +"' AND "
		cQuery += "E2_TIPO = '"+ SE2->E2_TIPO +"') AND "
	Endif

	//Cumulatividade para fornecedores pessoa fisica ou juridica
	//http://tdn.totvs.com/pages/viewpage.action?pageId=271413168
	If cTpForn $ "F;J"
		If cTpAcm == "2"	// MV_INSTPAC = '2' - Cumulativo por cinco anos
			dDataIni :=  CTOD('01/'+STR(MONTH(dEmissao))+'/'+STR(YEAR(dEmissao)-5))
			dDataFim :=  LastDay(dEmissao)

			cQuery += "E2_EMISSAO  BETWEEN '" + Dtos(dDataIni) + "' AND '" + Dtos(dDataFim)+ "' AND "
		Else				// MV_INSTPAC = '1' - Cumulativo mensal
			If lVencto
				cQuery += "E2_VENCREA  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
			Else
				cQuery += "E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
			Endif
		EndIf
	EndIf

	cQuery += "D_E_L_E_T_ <> '*' "
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBCALC", .F., .T.)
	TcSetField("TRBCALC","NVALINSS"  ,"N", 17,2)
	nValor := nValInss
	dbCloseArea()

	If nValor > 0
		cQuery := "SELECT R_E_C_N_O_ RECNO FROM " + RetSQLname("SE2")
		cQuery += " WHERE "
		cQuery += "( "
		For nX:= 1 to Len(aFilINSS)
			cQuery += "E2_FILIAL = '"+ aFilINSS[nX] + "' OR "
		Next nX
		cQuery := Left( cQuery, Len( cQuery ) - 4 )
		cQuery += ") AND "

		cQuery += "E2_FORNECE = '"+ cFornece +"' AND "
		cQuery += "E2_LOJA = '"+ cLoja +"' AND "
		cQuery += "E2_VRETINS > 0 AND "

		If Type("M->E2_NUM") == "C" .AND. Type("M->E2_PREFIXO") == "C"
			cQuery += "NOT(E2_NUM = '"+ M->E2_NUM +"' AND "
			cQuery += "E2_PREFIXO = '"+ M->E2_PREFIXO +"') AND "
		Elseif Type("SE2->E2_NUM") == "C" .AND. Type("SE2->E2_PREFIXO") == "C"
			cQuery += "NOT(E2_NUM = '"+ SE2->E2_NUM +"' AND "
			cQuery += "E2_PREFIXO = '"+ SE2->E2_PREFIXO +"') AND "
		Endif

		If FwIsInCallStack("FGRVINSS")
			cQuery += "E2_PRETINS = '1' AND "	//E2_PRETINS = '1' -> Pendente de retenção.
		Else
			//Cumulatividade para fornecedores pessoa fisica ou juridica
			//http://tdn.totvs.com/pages/viewpage.action?pageId=271413168
			If cTpAcm == "2"	// MV_INSTPAC = '2' - Cumulativo por cinco anos
				dDataIni :=  CTOD('01/'+STR(MONTH(dEmissao))+'/'+STR(YEAR(dEmissao)-5))
				dDataFim :=  LastDay(dEmissao)

				cQuery += "E2_EMISSAO  BETWEEN '" + Dtos(dDataIni) + "' AND '" + Dtos(dDataFim)+ "' AND "
			Else				// MV_INSTPAC = '1' - Cumulativo mensal
				If lVencto
					cQuery += "E2_VENCREA  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
				Else
					cQuery += "E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
				Endif
			EndIf
		EndIf
		cQuery += "D_E_L_E_T_ <> '*' "
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBCALC", .F., .T.)
		While !TRBCALC->(EOF())
			aaDD(aRecINSS,TRBCALC->RECNO)
			TRBCALC->(DbSkip())
		EndDo
		dbCloseArea()
	Endif

	//Verifico os valores retidos e que não foram calculados
	cQuery := "SELECT SUM(E2_INSS) NVLINSCAL, SUM(E2_VRETINS) NVLINSRET FROM " + RetSQLname("SE2")
	cQuery += " WHERE "
	cQuery += "E2_FILIAL = '"+ xFilial("SE2") + "' AND "
	cQuery += "E2_FORNECE = '"+ cFornece +"' AND "
	cQuery += "E2_LOJA = '"+ cLoja +"' AND "
	cQuery += "E2_VRETINS > 0 AND "
	cQuery += "(E2_PRETINS = '2' OR E2_PRETINS ='') AND "

	If Type("M->E2_NUM") == "C" .AND. Type("M->E2_PREFIXO") == "C"
		cQuery += "NOT(E2_NUM = '"+ M->E2_NUM +"' AND "
		cQuery += "E2_PREFIXO = '"+ M->E2_PREFIXO +"') AND "
	Elseif Type("SE2->E2_NUM") == "C" .AND. Type("SE2->E2_PREFIXO") == "C"
		cQuery += "NOT(E2_NUM = '"+ SE2->E2_NUM +"' AND "
		cQuery += "E2_PREFIXO = '"+ SE2->E2_PREFIXO +"') AND "
	Endif

	//Cumulatividade para fornecedores pessoa fisica ou juridica
	//http://tdn.totvs.com/pages/viewpage.action?pageId=271413168
	If cTpAcm == "2"	// MV_INSTPAC = '2' - Cumulativo por cinco anos
		dDataIni :=  CTOD('01/'+STR(MONTH(dEmissao))+'/'+STR(YEAR(dEmissao)-5))
		dDataFim :=  LastDay(dEmissao)

		cQuery += "E2_EMISSAO  BETWEEN '" + Dtos(dDataIni) + "' AND '" + Dtos(dDataFim)+ "' AND "
	Else				// MV_INSTPAC = '1' - Cumulativo mensal
		If lVencto
			cQuery += "E2_VENCREA  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
		Else
			cQuery += "E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
		Endif
	EndIf

	cQuery += "D_E_L_E_T_ <> '*' "
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBCALC", .F., .T.)
	nInsRest := TRBCALC->NVLINSRET - TRBCALC->NVLINSCAL
	dbCloseArea()

	RestArea(aArea)
Endif

Return (nValor)


//-------------------------------------------------------------------
/*/{Protheus.doc} FCalcInsPF
Calcula o INSS de Pessoa Fisica respeitando os limites de retencao.

@author Mauricio Pequim Jr
@since  11/08/2004
/*/
//-------------------------------------------------------------------
Function FCalcInsPF(nValTit, nCalcInss, nINSSTot, lRegra, nDedValor,lNFE,dEmissao,dVencrea)

Local nLimInss   := GetMv("MV_LIMINSS",.F.,0)
Local nInssAcum  := 0
Local nInssCalc  := 0
Local nValMaxIns := 0
Local lRoundIns	 := GetNewPar("MV_RNDINS",.F.)
Local nVlMinINSS := SuperGetMv("MV_MININSS",.F.,0) //Esse parametro deve estar preenchido com o valor mínimo para recolhimento de INSS o conteúdo padrão "0" (zero) foi utilizado para manter o legado.
Local lPaBruto	 := GetNewPar("MV_PABRUTO","2") == "1"  //Indica se o PA terá o valor dos impostos descontados do seu valor
Local lPrImPA    := !lPaBruto .And. SuperGetMv("MV_PAPRIME",.T.,"2") == "1"
Local nValInss   := 0
Local nInsRest   := 0
Local lOk	     := .F.
Local nDedBase	 := 0
Local lFina377	 :=	FUNNAME() == "FINA377"

Default nDedValor := 0
Default nCalcInss := 0
Default nINSSTot  := 0
Default lRegra    := .T. // se ao calcular o INSS, considera as regras de impostos
Default lNFE      := .F.     
Default dEmissao  := M->E2_EMISSAO
Default dVencrea  := M->E2_VENCREA

INCLUI:= IF(Type("INCLUI") == "U", .F., INCLUI)
ALTERA:= IF(Type("ALTERA") == "U", .T., ALTERA)

If cPaisLoc=="BRA"
	nDedBase := Fa986regra("SE2","INSS","1" )
	If lRegra
		nDedValor := Fa986regra("SE2","INSS","2" )
	EndIf
EndIf

nValTit := nValTit + nDedBase

If nValTit < 0
	nValTit := 0
EndIf

If lRoundIns
	nValInss := Round((nValTit * (SED->ED_PERCINS/100)),2)
Else
	nValInss := NoRound((nValTit * (SED->ED_PERCINS/100)),2)
EndIf

nValInss := nValInss + nDedValor

If nValInss < 0
	nValInss := 0
EndIf

If !Empty(nCalcInss) .AND. IsInCallStack("MATA103")
	nValInss := nCalcInss //valor do INSS para ESSE título.
Else
	nCalcInss := nValInss //valor do INSS para ESSE título.nCalcInss := nValInss //valor do INSS para ESSE título.
EndIf

nValInss := FRetOTits(nValInss) //na alteracao, verifica se tem impostos de outros titulos

//Retornar o saldo de INSS acumulado do fornecedor, do mes de emissao ou vencimento do titulo originador
nInssAcum := VerInssAcm(SA2->A2_COD, SA2->A2_LOJA, SA2->A2_NREDUZ, dEmissao, dVencrea,lNFE)

nValMaxIns := (nLimInss - nInssAcum)     //Saldo do que pode ser retido no mes

//Retornar o saldo de INSS calculado para o fornecedor, do mes de emissao ou vencimento do titulo originador
nINSSCalc := VerInssCalc(SA2->A2_COD, SA2->A2_LOJA, SA2->A2_NREDUZ, dEmissao, dVencrea,,@nInsRest)

nINSSTot := (nInssCalc + nValINSS) + Iif(nInsRest > 0 .AND. !ALTERA ,nInsRest,0)

If !lNFE
	lOk :=	!(m->e2_tipo == MVPAGANT .and. lPrImPA)
Else
	lOk := .T.
Endif

If nVlMinINSS > 0 .And. lOk //Se o valor devido de INSS do título for menor que o valor mínimo. Ele será zerado.
	If nINSSTot+nInssAcum < nVlMinINSS
		nValINSS := 0
		nINSSTot := 0
		If nLimInss <> 0 .and. nValMaxIns == 0
			nCalcInss := 0
		EndIf
	EndIf
EndIf

If nLimInss > 0 .and. nValINSS <> 0 .and. nINSSTot <> 0
	//Retornar o saldo de INSS acumulado do fornecedor, do mes de emissao ou vencimento do titulo originador
	If nValMaxIns <= 0
		nValInss := 0
		nINSSTot := 0
		nCalcInss := 0
	ElseIf nValMaxIns < nVlMinINSS
		//Se o valor retido (retencao por nao atingir o minimo de retencao e/ou por haver ultrapassado o maximo) for um saldo,
		//verificar se o seu valor nao eh igual ou maior ao do saldo calculado, para evitar duplicidade de retencao de INSS
		If nINSSCalc < nVlMinINSS
			If nINSSCalc >= nValMaxIns
				nCalcInss := 0
			Else
				nCalcInss := nValMaxIns - nINSSCalc
			Endif
		Else
			nCalcInss := nValMaxIns
		Endif
		nValInss := 0
		nINSSTot := 0
	Else
		//Atribuir ao INSS calculado do titulo, as retencoes pendentes
		nValInss += nINSSCalc
		If nValMaxIns < nValInss
			nValInss  := nCalcInss :=  nValMaxIns
		EndIf
		If nValMaxIns < nINSSTot
			nINSSTot :=  IIf(nValMaxIns > nValInss, nValInss, nValMaxIns)
		EndIf
	Endif
Endif

Return nValInss


//-------------------------------------------------------------------
/*/{Protheus.doc} FCalcInsPJ
Calcula o INSS de Pessoa Jurídica respeitando os limites de retencao.

@author Mauricio Pequim Jr
@since  11/08/2004
/*/
//-------------------------------------------------------------------
Function FCalcInsPJ(nValTit, nCalcInss, nINSSTot, lRegra, nDedValor, lNFE, dEmissao, dVencrea)

Local nInssAcum 	:= 0
Local lRoundIns		:= GetNewPar("MV_RNDINS",.F.)
// Esse parametro deve estar preenchido com o valor mínimo para recolhimento de INSS o conteúdo padrão "0" (zero) foi utilizado para manter o legado.
Local nVlMinINSS	:= SuperGetMv("MV_VLRETIN",.F.,0)
Local lAcmPJ		:= SuperGetMv("MV_INSACPJ",.T.,"2") == "1"  //1 = Acumula    2= Não acumula
Local aRecINSS		:= {}
Local lPaBruto		:= GetNewPar("MV_PABRUTO","2") == "1"  //Indica se o PA terá o valor dos impostos descontados do seu valor
Local lPrImPA		:= !lPaBruto .And. SuperGetMv("MV_PAPRIME",.T.,"2") == "1"	//Variavel indica se irá provisionar os impostos de INSS e ISS na inclusão da PA, deduzindo-os do valor de adiantamento.
Local nInsRest		:= 0
Local lFinVldIns	:= Existblock("FinVldIns")
Local lOk			:=	.F.
Local nDedBase		:= 0
Local lFina377		:=	FUNNAME() == "FINA377"

Default nDedValor	:= 0
Default nCalcInss	:= 0
Default nINSSTot	:= 0
Default lRegra		:= .T. // se ao calcular o INSS, considera as regras de impostos
Default lNFE		:= .F.
Default dEmissao := M->E2_EMISSAO
Default dVencrea := M->E2_VENCREA

INCLUI:= IF(Type("INCLUI") == "U", .F., INCLUI)
ALTERA:= IF(Type("ALTERA") == "U", .T., ALTERA)

If cPaisLoc=="BRA"
	nDedBase := Fa986regra("SE2","INSS","1" )
	If lRegra
		nDedValor := Fa986regra("SE2","INSS","2" )
	EndIf
EndIf

nValTit := nValTit + nDedBase

If nValTit < 0
	nValTit := 0
EndIf

If lRoundIns
	nValInss := Round((nValTit * (SED->ED_PERCINS/100)),2)
Else
	nValInss := NoRound((nValTit * (SED->ED_PERCINS/100)),2)
EndIf

nValInss := nValInss + nDedValor

If  nValInss < 0
	nValInss := 0
EndIf

/*
---------------------------------------------------------------------------------------
Orientação do artigo 120 da IN 971/2009

Fica dispensada a retenção quando o valor correspondente a 11% do valor dos serviços
prestados for inferior ao limite mínimo estabelecido para recolhimento.

Este tratamento deve considerar individualmente cada documento.
---------------------------------------------------------------------------------------
*/
If !Empty(nCalcInss) .AND. IsInCallStack("MATA103")
	nValInss := nCalcInss //valor do INSS para ESSE título.
Else
	nCalcInss := nValInss //valor do INSS para ESSE título.nCalcInss := nValInss //valor do INSS para ESSE título.
EndIf

If !lFina377
	If FWIsInCallStack("FINA050")
		lOk :=	!(M->E2_TIPO == MVPAGANT .and. lPrImPA)
	Else
		lOk :=	!(SE2->E2_TIPO == MVPAGANT .and. lPrImPA)
	EndIf
Endif

If lOk
	If nVlMinINSS > 0 
		If lAcmPJ
			nINSSAcum := VerInssCalc(SA2->A2_COD, SA2->A2_LOJA, SA2->A2_NREDUZ, dEmissao, dVencrea, @aRecINSS,@nInsRest)
		EndIf
		
		nINSSTot := nINSSAcum + nValINSS + Iif(nInsRest > 0,nInsRest,0)
		
		If nINSSTot < nVlMinINSS .AND. (IIF(lFinVldIns, Execblock("FinVldIns",.F.,.F., {} ), .T. ))
			nValINSS := 0
			nINSSTot := 0
			
			If !lAcmPJ
				nCalcInss := 0
			EndIf
		EndIf
	Else
		nINSSTot := nValINSS
	EndIf
EndIf

Return nValInss

/*/
±±³Fun‡…o	 ³FVerMinImp³ Autor ³ Mauricio PEquim Jr.   ³ Data ³ 02/02/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica o valor minimo de retencao dos impostos IR, PIS   ³±±
±±³          ³ COFINS, CSLL                                               ³±±
/*/
Function FVerMinImp(nValor,lButMenu)
Local nVlMinImp := GetNewPar("MV_VL10925",5000)
Local nCond := 0
Local lContrRet := .T.

Local nRecAtuSE2 := SE2->(RECNO())
Local nValNdf := 0
Local nPisNdf := 0
Local nCofNdf := 0
Local nCslNdf := 0
Local nValorTit := 0
Local nTotImp := 0
Local nX := 0
Local aRecSE2 := {}

//1-Cria NCC/NDF referente a diferenca de impostos entre emitidos (SE2) e retidos (SE5)
//2-Nao Cria NCC/NDF, ou seja, controla a diferenca num proximo titulo
//3-Nao Controla
Local cNccRet  := SuperGetMv("MV_NCCRET",.F.,"1")
Local nRetOriPIS := 0
Local nRetOriCOF := 0
Local nRetOriCSL := 0
Local lBaseSE2 := cPaisLoc == 'BRA' .and. SuperGetMv("MV_BS10925",.T.,"1") == "1"

// Caso nao esteja sendo chamado atraves da enchoicebar na tela de inclusao
Default lButMenu := .F.

//Verificacao para outros modulos
cModRetPIS	:= If (Type("cModRetPis") != "C",GetNewPar( "MV_RT10925", "1" ), cModRetPIS )
nIndexSE2	:= If (Type("nIndexSE2") != "N","",nIndexSE2)
aDadosRet   := If (Type("aDadosRet") != "A",Array(5),aDadosRet)
cIndexSE2	:= If (Type("cIndexSE2") != "C","",cIndexSE2)
cOldNaturez	:= If (Type("cOldNaturez") != "C","",cOldNaturez)
nRecnoNdf 	:= If (Type("nRecnoNdf") != "N",0,nRecnoNdf)
nDifPcc		:= If (Type("nDifPcc") != "N",0,nDifPcc)
aDadosImp   := If (Type("aDadosImp") != "A",Array(3),aDadosImp)

dbSelectArea("SE2")
If lAltera
	lAlterNat := .T.
	aRecSE2 := FImpExcTit("SE2",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
	For nX := 1 to Len(aRecSE2)
		SE2->(MSGoto(aRecSE2[nX]))
		If SE2->E2_TIPO $ MV_CPNEG
			If STR(SE2->E2_SALDO,17,2) != STR(SE2->E2_VALOR,17,2)
				nValNdf := 0
				nRecnoNdf := 0
			Else
				nValNdf := SE2->E2_SALDO
				nRecnoNdf := aRecSE2[nX]
				Exit
			Endif
		Endif
	Next
	SE2->(dbGoTo(nRecAtuSE2))
Endif

DEFAULT nValor := M->E2_VALOR

nPisOri := IIf(Type("nPisOri") != "N" , 0, nPisOri)
nCofOri := IIf(Type("nCofOri") != "N" , 0, nCofOri)
nCslOri := IIf(Type("nCslOri") != "N" , 0, nCslOri)

If lContrRet .and. (m->e2_pis + m->e2_cofins + m->e2_csll > 0 ) .and. cPaisLoc == 'BRA'
	//Nao retem Pis,Cofins,CSLL
	If cModRetPis == "3"  //Nao retem PIS
		nVlRetPis := M->E2_PIS
		nVlRetCof := M->E2_COFINS
		nVlRetCsl := M->E2_CSLL
		M->E2_PIS := 0
		M->E2_COFINS := 0
		M->E2_CSLL := 0
	Else
		aDadosRet := F050TotMes(M->E2_VENCREA,@nIndexSE2,@cIndexSE2)
		//³ Guarda os valores originais                           ³
		nRetOriPIS := M->E2_PIS
		nRetOriCOF := M->E2_COFINS
		nRetOriCSL := M->E2_CSLL
		If !lAltera
			//PIS
			If M->E2_PIS > 0 .And. aDadosImp[1] <> aDadosRet[2]
				If cNCCRet == "2"
					M->E2_PIS += aDadosImp[1]
				EndIf
			EndIf
			//COFINS
			If M->E2_COFINS > 0  .And. aDadosImp[2] <> aDadosRet[3]
				If cNCCRet == "2"
					M->E2_COFINS += aDadosImp[2]
				EndIf
			EndIf
			//CSLL
			If M->E2_CSLL > 0  .And. aDadosImp[3] <> aDadosRet[4]
				If cNCCRet == "2"
					M->E2_CSLL += aDadosImp[3]
				EndIf
			EndIf
		EndIf
		//Calculo do Sistema
		IF cModRetPis == "1"
			If lAltera .and. nValor > nVlMinImp//.and. Month(M->E2_VENCREA)==Month(SE2->E2_VENCREA)
				nCond := aDadosRet[1]+nValor

				//Tratamento para base de impostos diferenciado
				If lBaseSE2 .and. SE2->E2_BASEPIS > 0
					nCond -= SE2->E2_BASEPIS
				Else
					nCond -= (SE2->(E2_VALOR+E2_IRRF+E2_INSS+E2_ISS+E2_VRETPIS+E2_VRETCOF+E2_VRETCSL+E2_SEST))
				Endif
			Else
				nCond := aDadosRet[1]+nValor
			Endif
			If (nCond <= nVlMinImp .And. nValor  <= nVlMinImp) .Or. lButMenu
				nVlRetPis := M->E2_PIS
				nVlRetCof := M->E2_COFINS
				nVlRetCsl := M->E2_CSLL
				M->E2_PIS := 0
				M->E2_COFINS:= 0
				M->E2_CSLL 	:= 0
			Endif
		Endif
		If M->E2_PIS+M->E2_COFINS+M->E2_CSLL > 0
			nVlRetPis		 := M->E2_PIS
			nVlRetCof		 := M->E2_COFINS
			nVlRetCsl		 := M->E2_CSLL
			M->E2_PIS 		 := nVlRetPis	+ If(aDadosImp[1] <> aDadosRet[2] .and. lAltera,aDadosImp[1], aDadosRet[2])
			M->E2_COFINS 	 := nVlRetCof	+ If(aDadosImp[2] <> aDadosRet[3] .and. lAltera,aDadosImp[2], aDadosRet[3])
			M->E2_CSLL		 := nVlRetCsl	+ If(aDadosImp[3] <> aDadosRet[4] .and. lAltera,aDadosImp[3], aDadosRet[4])

			If lAltera

				//Proporcionalizar o valor da NDF para os impostos
				If nValNdf > 0
					nValorTit := SE2->(E2_VALOR+E2_PIS+E2_COFINS+E2_CSLL+E2_IRRF+E2_INSS+E2_ISS+E2_SEST)
					nTotImp := SE2->(E2_PIS+E2_COFINS+E2_CSLL)
					nPisNdf := Round((SE2->E2_PIS * nValNdf)/nTotImp , 2)
					nCofNdf := Round((SE2->E2_COFINS * nValNdf)/nTotImp , 2)
					nCslNdf := nValNdf - (nPisNdf + nCofNdf)
					M->E2_PIS += nPisNdf
					M->E2_COFINS += nCofNdf
					M->E2_CSLL += nCslNdf
				Endif
			Endif
			f050VerVlr(nValor)
		Else
			//Natureza nao calculou Pis/Cofins/Csll
			AFill( aDadosRet, 0 )
		Endif
		//³ Restauro os valores originais                         ³
		nVlRetPis := nRetOriPIS
		nVlRetCof := nRetOriCOF
		nVlRetCsl := nRetOriCSL
		If lAltera .And. IIf(Type("nOldValor")== "N", nOldValor == M->E2_VALOR, .T.)
			If SE2->E2_BASEPIS+aDadosRet[1] > nVlMinImp .And. Month(SE2->E2_VENCREA)<>Month(M->E2_VENCREA) .And. SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL) > 0
				M->E2_PIS := SE2->E2_VRETPIS
				M->E2_COFINS := SE2->E2_VRETCOF
				M->E2_CSLL := SE2->E2_VRETCSL
			ElseIf Month(SE2->E2_VENCREA)==Month(M->E2_VENCREA)
				M->E2_PIS := SE2->E2_PIS
				M->E2_COFINS := SE2->E2_COFINS
				M->E2_CSLL := SE2->E2_CSLL
			ElseIf !(Month (SE2->E2_EMISSAO) == Month (M->E2_VENCREA))
				M->E2_PIS := 0
				M->E2_COFINS := 0
				M->E2_CSLL := 0
			EndIf
		EndIf
	Endif
Else
	//Natureza nao calculou Pis/Cofins/Csll
	AFill( aDadosRet, 0 )
	AFill( aDadosImp, 0 )
	nVlRetPis := M->E2_PIS
	nVlRetCof := M->E2_COFINS
	nVlRetCsl := M->E2_CSLL
Endif

Return

/*
±±³Funcao    ³F050TotMes³ Autor ³Mauricio Pequim Jr     ³ Data ³23/08/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica o total de notas do Fornecedor que vencem no mesmo ³±±
±±³          ³mes.                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpD1 - Data de referencia                                  ³±±
*/
Function F050TotMes(dReferencia,nIndexSE2,cIndexSE2)
Local aAreaSE2  := SE2->( GetArea() )
Local aDadosRef := Array( 5 )
Local aRecnos   := {}
Local dDataIni  := FirstDay( dReferencia )
Local dDataFim  := LastDay( dReferencia )
Local cModTot   := GetNewPar( "MV_MT10925", "1" )
Local lBaseSE2	:= cPaisLoc == 'BRA' .and. SuperGetMv("MV_BS10925",.T.,"1") == "1"
Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)
Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local lLojaAtu  := ( GetNewPar( "MV_LJ10925", "1" ) == "1" )
Local lCalcPa := .F.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
Local aStruct   := {}
Local aCampos   := {}
Local cAliasQry := ""
Local cSepNeg   := If("|"$MV_CPNEG,"|",",")
Local cSepProv  := If("|"$MVPROVIS,"|",",")
Local cSepRec   := If("|"$MVPAGANT,"|",",")
Local cQuery    := ""
Local nLoop     := 0

Local	lAplVlMin := .T.
Local lCpoVlMin := .T.
Local lTodasFil := ExistBlock("FA050RTF")
Local aFil10925 := {}
Local lTodosFor	:= ExistBlock("FA050FOR")
Local aFornece	:= {}

//--- Tratamento Gestao Corporativa
Local lGestao   := Iif( lFWCodFil, FWSizeFilial() > 2, .F. )	// Indica se usa Gestao Corporativa
//
Local cFilFwSE2 := IIF( lGestao , FwFilial("SE2") , xFilial("SE2") )

//Verificar ou nao o limite de 5000 para Pis cofins Csll
// 1 = Verifica o valor minimo de retencao
// 2 = Nao verifica o valor minimo de retencao
If lCpoVlMin .and. M->E2_APLVLMN == "2"
	lAplVlMin := .F.
Endif

If M->E2_TIPO $ MVPAGANT
	lCalcPa := .T.
EndIf

aDadosRef := If (Type("aDadosRef") != "A",Array(7),aDadosRef)
aDadosRet := If (Type("aDadosRet") != "A",Array(7),aDadosRet)
aDadosImp := If (Type("aDadosImp") != "A",Array(3),aDadosImp)

AFill( aDadosRef, 0 )
AFill( aDadosImp, 0 )

If lAplVlMin

	//Verifico todas as filiais apenas quando SA2 compartilhado
	If lTodasFil
		aFil10925 := ExecBlock( "FA050RTF", .F., .F. )
	Else
		aFil10925 := { cFilant }
	Endif

	//FNC 00000020498/2009
	If lTodosFor
		aFornece := ExecBlock("FA050FOR", .F., .F.)
		If ValType(aFornece) <> "A"
			lTodosFor := .F.
		Endif
	Endif
	//FIM
	aCampos := { "E2_VALOR","E2_IRRF","E2_ISS","E2_INSS","E2_PIS","E2_COFINS","E2_CSLL","E2_VRETPIS","E2_VRETCOF","E2_VRETCSL" }
	aStruct := SE2->( dbStruct() )

	SE2->( dbCommit() )
	cAliasQry := GetNextAlias()

	cQuery := "SELECT E2_VALOR,E2_PIS,E2_COFINS,E2_EMISSAO,E2_CSLL,E2_ISS,E2_INSS,E2_IRRF,E2_VRETPIS,E2_VRETCOF,E2_VRETCSL,E2_PRETPIS,E2_PRETCOF,E2_PRETCSL,E2_VRETIRF,"
	If lBaseSe2
		cQuery += "E2_BASEPIS,"
	Endif
	If lCpoVlMin
		cQuery += "E2_APLVLMN,"
	Endif
	cQuery += "E2_PREFIXO,E2_NUM,E2_PARCELA,E2_TIPO, R_E_C_N_O_ RECNO FROM "
	cQuery += RetSqlName( "SE2" ) + " SE2 "
	cQuery += "WHERE "
	If Len(aFil10925) == 1 .Or. Empty( cFilFwSE2 )   //Compartilhado
		cQuery += "E2_FILIAL='"    + xFilial("SE2")       + "' AND "
	Else	//Multifiliais
		cQuery += "( "
		For nLoop := 1 to Len(aFil10925)
			cQuery += "E2_FILIAL ='"   + aFil10925[nLoop]  + "' OR "
		Next
		//Retiro o ultimo OR
		cQuery := Left( cQuery, Len( cQuery ) - 4 )
		cQuery += ") AND "
	Endif

	//³Verifica se utiliza o ponto de Entrada FA050FOR para analise de imposto atraves de outras filiais SA2³
	If ! lTodosFor
		cQuery += "E2_FORNECE = '"+M->E2_FORNECE+"' AND "
		If lLojaAtu  //Considero apenas a loja atual
			cQuery += "E2_LOJA = '"+M->E2_LOJA+"' AND "
		Endif
	Else
		cQuery += "( "
		For nLoop := 1 To Len(aFornece)
			cQuery += "E2_FORNECE = '"+aFornece[nLoop,1]+"' AND E2_LOJA = '"+aFornece[nLoop,2]+"'"+IIF(nLoop < Len(aFornece)," OR "," ")
		Next
		cQuery += ") AND "
	Endif

	cQuery += "E2_VENCREA >= '" + DToS( dDataIni )      + "' AND "
	cQuery += "E2_VENCREA <= '" + DToS( dDataFim )      + "' AND "
	If !lPccBaixa .And. lCalcPa
		cQuery += "E2_TIPO IN " + FormatIn(MVPAGANT,cSepRec)  + " AND "
	Else
		cQuery += "E2_TIPO NOT IN " + FormatIn(MVABATIM,"|") + " AND "
		cQuery += "E2_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)  + " AND "
		cQuery += "E2_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv) + " AND "
		cQuery += "E2_TIPO NOT IN " + FormatIn(MVPAGANT,cSepRec)  + " AND "
	EndIf

	//Se existe o campo de valor aplicacao de valor minimo dos impostos e
	//se aplico o valor minimo, devo considerar apenas os titulos nesta situacao para verificacao
	//de retencoes anteriores, pendencias de retencao etc.
	//Titulos em que E2_APLVLMN = 2 (nao aplica o valor minimo de R$ 5000) nao compoem a base do PCC
	If lCpoVlMin
		cQuery += "	E2_APLVLMN = '1' AND "
	Endif
	cQuery += "(E2_DESDOBR <> 'S' OR ( E2_DESDOBR = 'S' AND E2_STATUS <> 'D')) AND " // não considera titulo pai de desdobramento para imposto
	cQuery += "D_E_L_E_T_=' '"

	cQuery := ChangeQuery( cQuery )

	dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasQry, .F., .T. )

	For nLoop := 1 To Len( aStruct )
		If !Empty( AScan( aCampos, AllTrim( aStruct[nLoop,1] ) ) )
			TcSetField( cAliasQry, aStruct[nLoop,1], aStruct[nLoop,2],aStruct[nLoop,3],aStruct[nLoop,4])
		EndIf
	Next nLoop

	While !( cAliasQRY )->( Eof())

		If BuscaSE5("BA",( cAliasQRY )->E2_PREFIXO,( cAliasQRY )->E2_NUM,( cAliasQRY )->E2_PARCELA,( cAliasQRY )->E2_TIPO,"DSD")
			//Se o titulo for Pai do desdobramento, desconsiderar no calculo de imposto
			( cAliasQRY )->( DBSkip() )
			Loop
		EndIf

		// Desconsidera se o titulo encontrado for o mesmo que está sendo alterado
		If lAltera .and.  ( cAliasQRY )->RECNO == SE2->(Recno())
			( cAliasQRY )->( DBSkip() )
			Loop
		EndIf

		//Armazeno os valores calculados por titulo.
		If ( cAliasQRY )->E2_PIS > 0 .and. (!(SuperGetMv("MV_BX10925",.T.,"2") == "2" .and. ( cAliasQRY )->E2_PRETPIS == "2") .or. !lPccBaixa)
			aDadosImp[1] += ( cAliasQRY )->E2_PIS
		EndIf

		If ( cAliasQRY )->E2_COFINS > 0 .and. (!(GetMv("MV_BX10925",.T.,"2") == "2" .and. ( cAliasQRY )->E2_PRETCOF == "2") .or. !lPccBaixa)
			aDadosImp[2] += ( cAliasQRY )->E2_COFINS
		EndIf

		If ( cAliasQRY )->E2_CSLL > 0 .and. (!(GetMv("MV_BX10925",.T.,"2") == "2" .and. ( cAliasQRY )->E2_PRETCSL == "2") .or. !lPccBaixa)
			aDadosImp[3] += ( cAliasQRY )->E2_CSLL
		EndIf

		If cModTot == "1"

			//Verifico se utiliza a base de imposto ou o valor do titulo
			//para totalizar a retencao no mes
			If !lBaseSe2
				adadosref[1] += ( ( cAliasQRY )->E2_VALOR + Iif(lCalcIssBx,0,( cAliasQRY )->E2_ISS)+ ( cAliasQRY )->E2_INSS + Iif(lIRPFBaixa, 0,( cAliasQRY )->E2_IRRF) )
			Else
				If Empty( ( cAliasQRY )->E2_BASEPIS )
					adadosref[1] += ( ( cAliasQRY )->E2_VALOR + ( cAliasQRY )->E2_ISS + ( cAliasQRY )->E2_INSS +  ( cAliasQRY )->E2_IRRF )
				Else
					adadosref[1] += (cAliasQRY)->E2_BASEPIS
				Endif
			Endif

			If Empty( ( cAliasQRY )->E2_PRETPIS )
				If !lBaseSE2 .or. Empty( ( cAliasQRY )->E2_BASEPIS )
					// se foi atribuido pela basePIS então já está com o valor cheio, senao deve recompor os impostos no valor
					aDadosRef[1] += If( Empty( ( cAliasQRY )->E2_VRETPIS ), ( cAliasQRY )->E2_PIS, ( cAliasQRY )->E2_VRETPIS )
				EndIf
				//Armazeno os valores calculados por titulo, retirando os valores retidos
				If ( cAliasQRY )->E2_VRETPIS + ( cAliasQRY )->E2_VRETCOF + ( cAliasQRY )->E2_VRETCSL + IF(lIRPFBaixa, ( cAliasQRY )->E2_VRETIRF , 0 ) > 0
					aDadosImp[1] -= (cAliasQRY)->E2_VRETPIS
				Endif
			EndIf

			If Empty( ( cAliasQRY )->E2_PRETCOF )
				If !lBaseSE2 .or. Empty( ( cAliasQRY )->E2_BASEPIS )
					// se foi atribuido pela basePIS então já está com o valor cheio, senao deve recompor os impostos no valor
					aDadosRef[1] += If( Empty( ( cAliasQRY )->E2_VRETCOF ), ( cAliasQRY )->E2_COFINS, ( cAliasQRY )->E2_VRETCOF )
				EndIf
				//Armazeno os valores calculados por titulo, retirando os valores retidos
				If ( cAliasQRY )->E2_VRETPIS + ( cAliasQRY )->E2_VRETCOF + ( cAliasQRY )->E2_VRETCSL + IF(lIRPFBaixa, ( cAliasQRY )->E2_VRETIRF , 0 ) > 0
					aDadosImp[2] -= (cAliasQRY)->E2_VRETCOF
				Endif
			EndIf

			If Empty( ( cAliasQRY )->E2_PRETCSL )
				If !lBaseSE2 .or. Empty( ( cAliasQRY )->E2_BASEPIS )
					// se foi atribuido pela basePIS então já está com o valor cheio, senao deve recompor os impostos no valor
					aDadosRef[1] += If( Empty( ( cAliasQRY )->E2_VRETCSL ), ( cAliasQRY )->E2_CSLL, ( cAliasQRY )->E2_VRETCSL )
				EndIf
				//Armazeno os valores calculados por titulo, retirando os valores retidos
				If ( cAliasQRY )->E2_VRETPIS + ( cAliasQRY )->E2_VRETCOF + ( cAliasQRY )->E2_VRETCSL + IF(lIRPFBaixa, ( cAliasQRY )->E2_VRETIRF , 0 ) > 0
					aDadosImp[3] -= (cAliasQRY)->E2_VRETCSL
				Endif
			EndIf

			If ( !Empty( ( cAliasQRY )->E2_PIS ) .Or. !Empty( ( cAliasQRY )->E2_COFINS ) .Or. !Empty( ( cAliasQRY )->E2_CSLL ) ) ;
				.And. ( Empty( ( cAliasQRY )->E2_VRETPIS ) .Or. Empty( ( cAliasQry )->E2_VRETCOF ) .Or. Empty( ( cAliasQry )->E2_VRETCSL ) ) ;
				.And. ( ( cAliasQRY )->E2_PRETPIS == "1" .Or. ( cAliasQry )->E2_PRETCOF == "1" .Or. ( cAliasQry )->E2_PRETCSL == "1" )

				If Empty( ( cAliasQRY )->E2_VRETPIS ) .And. ( cAliasQRY )->E2_PRETPIS == "1"
					aDadosRef[2] += ( cAliasQRY )->E2_PIS
				EndIf

				If Empty( ( cAliasQRY )->E2_VRETCOF )	.And. ( cAliasQRY )->E2_PRETCOF == "1"
					aDadosRef[3] += ( cAliasQRY )->E2_COFINS
				EndIf

				If Empty( ( cAliasQRY )->E2_VRETCSL ) .And. ( cAliasQRY )->E2_PRETCSL == "1"
					aDadosRef[4] += ( cAliasQRY )->E2_CSLL
				EndIf
				AAdd( aRecnos, ( cAliasQRY )->RECNO )
			EndIf
		Else
			If ( !Empty( ( cAliasQRY )->E2_PIS ) .Or. !Empty( ( cAliasQRY )->E2_COFINS ) .Or. !Empty( ( cAliasQRY )->E2_CSLL ) )

				//Verifico se utiliza a base de imposto ou o valor do titulo
				//para totalizar a retencao no mes
				If !lBaseSe2
					aDadosRef[1] += ( ( cAliasQRY )->E2_VALOR + Iif(lCalcIssBx,0,( cAliasQRY )->E2_ISS) + ( cAliasQRY )->E2_INSS + Iif(lIRPFBaixa,0,( cAliasQRY )->E2_IRRF) )
				Else
					If Empty( ( cAliasQRY )->E2_BASEPIS )
						aDadosRef[1] += ( ( cAliasQRY )->E2_VALOR + Iif(lCalcIssBx,0,( cAliasQRY )->E2_ISS) + ( cAliasQRY )->E2_INSS + Iif(lIRPFBaixa,0,( cAliasQRY )->E2_IRRF) )
					Else
						adadosref[1] += (cAliasQRY)->E2_BASEPIS
					Endif
				Endif

				If Empty( ( cAliasQRY )->E2_PRETPIS )
					If !lBaseSE2 .or. Empty( ( cAliasQRY )->E2_BASEPIS )
						aDadosRef[1] += If( Empty( ( cAliasQRY )->E2_VRETPIS ), ( cAliasQRY )->E2_PIS, ( cAliasQRY )->E2_VRETPIS )
					Endif
					//Armazeno os valores calculados por titulo, retirando os valores retidos
					If ( cAliasQRY )->E2_VRETPIS + ( cAliasQRY )->E2_VRETCOF + ( cAliasQRY )->E2_VRETCSL + IF(lIRPFBaixa, ( cAliasQRY )->E2_VRETIRF , 0 ) > 0
						aDadosImp[1] -= (cAliasQRY)->E2_VRETPIS
					Endif
				EndIf

				If Empty( ( cAliasQRY )->E2_PRETCOF )

					If !lBaseSE2 .or. Empty( ( cAliasQRY )->E2_BASEPIS )
						aDadosRef[1] += If( Empty( ( cAliasQRY )->E2_VRETCOF ), ( cAliasQRY )->E2_COFINS, ( cAliasQRY )->E2_VRETCOF )
					Endif

					//Armazeno os valores calculados por titulo, retirando os valores retidos
					If ( cAliasQRY )->E2_VRETPIS + ( cAliasQRY )->E2_VRETCOF + ( cAliasQRY )->E2_VRETCSL + IF(lIRPFBaixa, ( cAliasQRY )->E2_VRETIRF , 0 ) > 0
						aDadosImp[2] -= (cAliasQRY)->E2_VRETCOF
					Endif
				EndIf

				If Empty( ( cAliasQRY )->E2_PRETCSL )

					If !lBaseSE2 .or. Empty( ( cAliasQRY )->E2_BASEPIS )
						aDadosRef[1] += If( Empty( ( cAliasQRY )->E2_VRETCSL ), ( cAliasQRY )->E2_CSLL, ( cAliasQRY )->E2_VRETCSL )
					Endif

					//Armazeno os valores calculados por titulo, retirando os valores retidos
					If ( cAliasQRY )->E2_VRETPIS + ( cAliasQRY )->E2_VRETCOF + ( cAliasQRY )->E2_VRETCSL + IF(lIRPFBaixa, ( cAliasQRY )->E2_VRETIRF , 0 ) > 0
						aDadosImp[3] -= (cAliasQRY)->E2_VRETCSL
					Endif
				EndIf

				If ( !Empty( ( cAliasQRY )->E2_PIS ) .Or. !Empty( ( cAliasQRY )->E2_COFINS ) .Or. !Empty( ( cAliasQRY )->E2_CSLL ) ) ;
					.And. ( Empty( ( cAliasQRY )->E2_VRETPIS ) .Or. Empty( ( cAliasQry )->E2_VRETCOF ) .Or. Empty( ( cAliasQry )->E2_VRETCSL ) ) ;
					.And. ( ( cAliasQRY )->E2_PRETPIS == "1" .Or. ( cAliasQry )->E2_PRETCOF == "1" .Or. ( cAliasQry )->E2_PRETCSL == "1" )

					If Empty( ( cAliasQRY )->E2_VRETPIS ) .And. ( cAliasQRY )->E2_PRETPIS == "1"
						aDadosRef[2] += ( cAliasQRY )->E2_PIS
					EndIf

					If Empty( ( cAliasQRY )->E2_VRETCOF )	.And. ( cAliasQRY )->E2_PRETCOF == "1"
						aDadosRef[3] += ( cAliasQRY )->E2_COFINS
					EndIf

					If Empty( ( cAliasQRY )->E2_VRETCSL ) .And. ( cAliasQRY )->E2_PRETCSL == "1"
						aDadosRef[4] += ( cAliasQRY )->E2_CSLL
					EndIf
					AAdd( aRecnos, ( cAliasQRY )->RECNO )
				EndIf
			Endif
		Endif
		( cAliasQRY )->( dbSkip())
	EndDo

	// Fecha a area de trabalho da query
	( cAliasQRY )->( dbCloseArea() )
	dbSelectArea( "SE2" )
Endif

aDadosRef[ 5 ] := AClone( aRecnos )

SE2->( RestArea( aAreaSE2 ) )

Return( aDadosRef )

/*
±±³Fun‡„o    ³A103CalcRt³ Autor ³ Sergio Silveira       ³ Data ³17/08/2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Totalizacao do array financeiro                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: aHeader do array de duplicatas                        ³±±
±±³          ³ExpA2: aCols do array de duplicatas                          ³±±
±±³          ³ExpL3: Habilita o Help (DEFAULT .T.)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: O Documento de entrada esta coerente com as parcelas  ³±±
±±³          ³       financeiras                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo verificar se o somatorio das   ³±±
±±³          ³parcelas eh total de duplicatas do documento de Entrada      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
*/
Function F050CalcRt()

Local cAcessRad:= GetNewPar( "MV_AC10925", "1" )

Local nRadio   := Val(cModRetPis)
Local nOpca    := 0
Local nLoop    := 0
Local oOk      := LoadBitmap( GetResources(), "LBOK" )
Local oNOk     := LoadBitmap( GetResources(), "LBNO" )
Local oDlgRet
Local oRadio
Local oBold
Local oBmp
Local oBut1
Local oBut2
Local nRadioOld := nRadio

//Base de imposto Variavel
Local lBaseImp	:= F050BSIMP(2)	//Verifica a existência dos campos e o calculo de impostos

//Somente permito a alteracao quando os dados estiverem preenchidos
If Empty(M->E2_VALOR) .OR. Empty(M->E2_NATUREZ) .OR. Empty(M->E2_FORNECE) .OR. Empty(M->E2_LOJA) .OR. ;
	Empty(M->E2_VENCREA)
	Return( .T. )
Endif

DEFINE MSDIALOG oDlgRet TITLE STR0127 FROM 09,0 TO 25.8,60 OF oMainWnd 	//"Calculo de retencao"

DEFINE FONT oBold NAME "Arial" SIZE 0, -13 BOLD

@  0, -25 BITMAP oBmp RESNAME "PROJETOAP" oF oDlgRet SIZE 55, 1000 NOBORDER WHEN .F. PIXEL

@ 03, 40 SAY STR0125 FONT oBold PIXEL // "Modalidade de retencao do PIS/COFINS/CSLL"

@ 14, 30 TO 16 ,400 LABEL '' OF oDlgRet   PIXEL

@ 25, 40 RADIO oRadio VAR nRadio 3D SIZE 70, 11 PROMPT STR0128,STR0129,STR0130 of oDlgRet PIXEL  //"Calculado pelo sistema"###"Efetua retencao"###"Nao efetua retencao"

oRadio:SetEnable( cAcessRad == "1" )

DEFINE SBUTTON oBut1 FROM 100, 169 TYPE 1 ACTION ( nOpca := 1, oDlgRet:End() )  ENABLE of oDlgRet
DEFINE SBUTTON oBut2 FROM 100, 202 TYPE 2 ACTION ( nOpca := 0, oDlgRet:End() )  ENABLE of oDlgRet

ACTIVATE MSDIALOG oDlgRet CENTERED

If nOpca == 1
	cModRetPis := Str( nRadio, 1 )
	If nRadio != nRadioOld
		Do Case
			Case nRadio == 1
				Fa050Natur()
			Case nRadio == 2
				Fa050Natur(,,,.T.)
			Case nRadio == 3
				M->E2_VALOR += M->E2_PIS + M->E2_COFINS + M->E2_CSLL
				If lBaseImp .and. m->e2_basepis > 0
					FVerMinImp(m->e2_basepis,.T.)
				Else
					FVerMinImp(m->e2_valor,.T.)
				Endif
				M->E2_VLCRUZ:=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
		EndCase
	Endif
EndIf

Return( .T. )

/*
±±³Fun‡„o    ³F050VerVlr³ Autor ³ Mauricio Pequim Jr    ³ Data ³17/08/2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se valor será menor que zero                        ³±±
*/
Function	f050VerVlr(nValorTit)
Local nTotARet	:= 0
Local nSobra 	:= 0

//³ Guarda os valores originais                           ³
nValorTit := nValorTit - m->e2_irrf - m->e2_iss - m->e2_inss - m->e2_sest - m->e2_pis - m->e2_cofins - m->e2_csll
nDifPcc := 0

If nValorTit < 0
	nValorTit += m->e2_irrf + m->e2_iss + m->e2_inss + m->e2_sest + m->e2_pis + m->e2_cofins + m->e2_csll

	nTotARet := m->e2_pis+m->e2_cofins+m->e2_csll

	nSobra := nValorTit - nTotARet

	If nSobra < 0

		nFatorRed := 1 - ( Abs( nSobra ) / nTotARet )

		m->e2_pis  := NoRound( m->e2_pis * nFatorRed, 2 )
		m->e2_cofins := NoRound( m->e2_cofins * nFatorRed, 2 )
		m->e2_csll := nValorTit - ( m->e2_pis + m->e2_cofins ) - 0.01
		If lAltera
			nDifPCC := nSobra
		Endif
	Endif
EndIf

Return

/*/
±±³Fun‡…o	 ³FCalcIr   ³ Autor ³ Mauricio PEquim Jr.   ³ Data ³ 11/08/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calculo do IRRF de Pessoa Fisica	e Juridica				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ FBaseIr(nBaseIrrf,cTipo)							          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Base Irrf          								  ³±±
±±³			 ³ ExpC1 = Tipo de Pessoa (Juridica ou Fisica				  ³±±
/*/
Function FCalcIr(nBaseIrrf,cTipo,lFinanceiro,lIrfRetAnt,lSRefSE2,lComiss)
Local aArea			:= GetArea()
Local nTotTit		:= 0
Local nTotInss		:= 0
Local nTotIrrf		:= 0
Local nValor		:= 0
Local lSest			:= cPaisLoc == 'BRA'  //Verifica campo de SEST

// Carrega variavel de verificacao de consideracao de valor minimo de retencao de IR.
Local lAplMinIR 	:= .F.
Local nVenctoPF 	:= SuperGetMv("MV_ACMIRPF",.T.,"3")  //1 = Emissao    2= Vencimento Real	3=Data Contabilizacao
Local nVenctoPJ 	:= SuperGetMv("MV_ACMIRPJ",.T.,"3")  //1 = Emissao    2= Vencimento Real	3=Data Contabilizacao
Local lVencto	 	:= .F.
Local lCalcIr	 	:= .F.
Local lNatIr	 	:= .F.
Local lContrRet := .T.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa 	:= SuperGetMv("MV_BX10925",.T.,"2") == "1"

// Controla IRPF na Baixa
Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)

Local lEmpPub		:= IsEmpPub()

Local lVretIrf		:= .T.
Local nTotRtIr		:= 0
Local nRecAtual		:= SE2->(RECNO())
Local lNumDep		:= .T.
Local nBaseDep		:= GetMV("MV_TMSVDEP",,0)
Local cAglImPJ		:= SuperGetMv("MV_AGLIMPJ",.T.,"1")
Local aFilial		:= {}
Local aCliFor		:= {}
Local cQuery		:= ""
Local nLoop			:= 0
Local nBaseSED		:= 1
Local cArqTmp		:= ""
Local nInssRA		:=	0
Local lPaBruto		:= GetNewPar("MV_PABRUTO","2") == "1"  //Indica se o PA terá o valor dos impostos descontados do seu valor
//Variavel indica se irá provisionar os impostos de INSS e ISS na inclusão da PA, deduzindo-os do valor de adiantamento.
Local lPrImPA := !lPaBruto .And. SuperGetMv("MV_PAPRIME",.T.,"2") == "1"
Local aAreaSED := SED->(GetArea())
Local nValtit  :=0
Local lDedInSS := (SuperGetMv("MV_INSIRF",.F.,"2") == "1" .and. SED->ED_BASEIRC == 0) .And. cTipo != "J"
Local nTotInCar:= 0
Local lDelTrbIR	:= .T.
Local aStru		:= SE2->(dbStruct())
Local cSepNeg	:= If("|"$MV_CPNEG,"|",",")
Local cSepProv	:= If("|"$MVPROVIS,"|",",")
Local cSepRec	:= If("|"$MVPAGANT,"|",",")
Local nX 		:= 0
Local cDbMs		:= UPPER(TcGetDb())

Local bSEDCompart	:= { || Empty(xFilial("SED")) }
Local lGestao		:= TamSx3("E5_FILIAL")[1] > 2
Local cFilFwSA2     := IIF( lGestao , FwFilial("SA2") , xFilial("SA2") )
Local cFilFwSA1     := IIF( lGestao , FwFilial("SA1") , xFilial("SA1") )
Local lF050Auto2	:= Iif( TYPE("lF050Auto") == "U" , .F. , lF050Auto )
Local lBaseDif		:= cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN"
Local lBaseCar		:= cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
Local lFIN050IR 	:= Existblock("FIN050IR")
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
Local lDesdob		:= lFinanceiro .And. SE2->E2_DESDOBR == "S"
Local cAcmIrrf 		:= SuperGetMv("MV_ACMIRRF",.T.,"1")  //1 = Acumula    2= Não acumula
Local nNroFil 		:= 0
Local lE2FilComp := FwModeAccess("SE2",3) == "C"
Local lNRastDSD		:= SuperGetMV("MV_NRASDSD",.T.,.F.)
Local nMoeda		:= 0
Local nTxMoeda		:= 0
Local dEmiss		:= dDataBase
Local lRtInssPA		:= .F.
Local cCodRet		:= ""

DEFAULT nBaseIrrf	:= 0
DEFAULT cTipo		:= "F" // Pessoa Fisica
DEFAULT lFinanceiro	:= .F. //Indica que o calculo foi chamado pelo modulo Financeiro
DEFAULT lIrfRetAnt	:= .F. //Controle de retencao anterior no mesmo periodo
DEFAULT lSRefSE2	:= .F. //Define se a pesquisa deve acontecer sem a referencia de um titulos na SE2
DEFAULT lComiss		:= .F. //Define se a rotina de pagto comissoes chamou esta funcao

INCLUI:= IF(Type("INCLUI") == "U", .T., INCLUI)
ALTERA:= IF(Type("ALTERA") == "U", .F., ALTERA)

If	IsBlind() .And. !lInssBx
	If Type("M->E2_INSS")=="U"
		If SE2->E2_INSS>0
			nInssRA	:= SE2->E2_INSS
		Endif
	Elseif	M->E2_INSS > 0
		nInssRA	:= M->E2_INSS
	Endif
Endif

If FunName() = "FINA050" .or. lF050Auto2
	lSRefSE2	:=	.F.
Endif
//Ponto de entrada para verificar se Acumula ou não os valores de IR no calculo
//Alteracao efetuada para atender a Pinheiro Neto Advogados
If lAcumIr
	lCalcIr := ExecBlock("F050CALIR",.F.,.F.)
EndIf

// Verifica se o fornecedor trata o valor minimo de retencao.
// 1 - Não considera  2 - Considera o parâmetro MV_VLRETIR
If cPaisLoc == "BRA" .and. SA2->A2_MINIRF == "2"
	lAplMinIR := .T.
Endif

//Se for Gestao utilizo outra funcao para verificar filial compartilhada
If lFWCodFil .And. lGestao
	bSEDCompart := { ||  Empty(FWFilial("SED")) }
Endif

If !lFinanceiro .AND. !lSRefSE2
	RegToMemory("SE2",.F.,.F.)
Endif

If !lSRefSE2 .AND. lFinanceiro

	If IsBlind()
		If Type("M->E2_NUM") == "U"
			RegToMemory("SE2",.F.,.F.)
		Endif
	Else
		RegToMemory("SE2",.F.,.F.,,Funname())
	Endif

	nLastDay := Day(LastDay(M->E2_EMISSAO))
	nTamData := Iif(Len(Dtoc(M->E2_EMISSAO)) == 10, 7, 5)
	dDataImp := M->E2_EMISSAO
Else
	nLastDay := Day(LastDay(dDataBase))
	nTamData := IIf(Len(DtoC(dDataBase)) == 10, 7, 5)
	dDataImp := dDataBase
	//Ignorar a configuracao do parametro MV_ACMIRPF, forcando a cumulatividade trabalhar com a database
	//ja que nao ha referencia do SE2 quanto a emissao ou vencimento real
	nVenctoPF := "3"
Endif

//Valida se a natureza corrente calcula IR
//Se não, desconsidera retenção de pendências (Caso não seja do Financeiro)
If !lFinanceiro
	dbSelectArea("SED")
	aAreaSED := SED->(GetArea())
	SED->(dbSetOrder(1))
	If SED->(dbSeek(xFilial("SED")+M->E2_NATUREZ))
		If SED->ED_CALCIRF == "S"
			lNatIr := .T.
		Endif
		If SED->ED_RINSSPA == "1"
			lRtInssPA := .T.
		EndIf
	Endif
	SED->(RestArea(aAreaSED))
Else
	//natureza do Financeiro é validadada antes da chamada desta função
	lNatIr := .T.
	If SED->ED_RINSSPA == "1"
		lRtInssPA := .T.
	EndIf
Endif


If lNatIr

	//Verifico a combinacao de filiais (SM0) e lojas de fornecedores a serem considerados
	//na montagem da base do IRRF
	If cAglImPJ != "1"
		aRet := FLOJASIRRF("2")
		aFilial := aClone(aRet[1])
		aCliFor := aClone(aRet[2])
		cArqTMP := aRet[3]
	Endif

	If cAcmIrrf	==	"1" .And. (!lAcumIr .Or. (lAcumIr .and. lCalcIr))//Acumula o valor do IRRF

		cQuery := "SELECT	DISTINCT SE2.E2_FILIAL,SE2.E2_PREFIXO,SE2.E2_NUM,SE2.E2_PARCELA,SE2.E2_TIPO,SE2.E2_FORNECE,SE2.E2_LOJA, "
		cQuery += "SE2.E2_EMIS1,SE2.E2_VENCREA,SE2.E2_EMISSAO,SE2.E2_NATUREZ,SE2.E2_VALOR,SE2.E2_IRRF,SE2.E2_INSS,SE2.E2_ISS,SE2.E2_FATURA, "
		cQuery += "SE2.E2_ORIGEM, SE2.E2_BASEIRF, SE2.E2_SALDO, SE2.E2_DESDOBR "

		If lSest
			cQuery += ",SE2.E2_SEST"
		Endif

		If lContrRet
			cQuery += ",SE2.E2_PRETPIS,SE2.E2_PRETCOF,SE2.E2_PRETCSL,SE2.E2_VRETPIS,SE2.E2_VRETCOF,SE2.E2_VRETCSL "
		Endif
		IF lVRetIrf
			cQuery += ",SE2.E2_VRETIRF, SE2.E2_PRETIRF "
		Endif

		cQuery += "FROM " + RetSQLname("SE2") + " SE2, "
		cQuery +=           RetSQLname("SED") + " SED "
		cQuery += " WHERE "

		If lVretIrf
			nNroFil := Len(aFilial)

			//Se verifica base apenas na filial corrente e fornecedor corrente
			If cAglImPJ == "1"
				If lE2FilComp
					cQuery += "SE2.E2_FILORIG = '" + cFilAnt + "' AND "
				Else
					cQuery += "SE2.E2_FILIAL = '" + xFilial("SE2") + "' AND "
				EndIf

				cQuery += "SE2.E2_FORNECE = '" + SA2->A2_COD + "' AND "
				cQuery += "SE2.E2_LOJA = '" + SA2->A2_LOJA + "' AND "
			ElseIf nNroFil > 0
				If Empty( cFilFwSA2 )
					cQuery += If(lE2FilComp, "SE2.E2_FILORIG IN( ", "SE2.E2_FILIAL IN ( ")

					For nLoop := 1 to nNroFil
						cQuery += "'" + aFilial[nLoop] + "',"
					Next nLoop

					//Retiro a ultima virgula
					cQuery := Left(cQuery, Len(cQuery) - 1)
					cQuery += ") AND "

					//Verificar determinados fornecedores (raiz do CNPJ)
					If "MSSQL" $ cDbMs
						cQuery += " (E2_FORNECE+E2_LOJA IN (SELECT CODIGO+LOJA FROM " + cArqTMP + ")) AND "
					Else
						cQuery += " (E2_FORNECE||E2_LOJA IN (SELECT CODIGO||LOJA FROM " + cArqTMP + ")) AND "
					Endif
				Else//Se cadastro de Clientes EXCLUSIVO
					If "MSSQL" $ cDbMs
						cQuery += " (E2_FILIAL+E2_FORNECE+E2_LOJA IN (SELECT FILIALX+CODIGO+LOJA FROM "+ cArqTMP + ")) AND "
					Else
						cQuery += " (E2_FILIAL||E2_FORNECE||E2_LOJA IN (SELECT FILIALX||CODIGO||LOJA FROM " + cArqTMP + ")) AND "
					Endif
				Endif
			Endif
		Else
			cQuery += "SE2.E2_FILIAL = '" + xFilial("SE2") + "' AND "
			cQuery += "SE2.E2_FORNECE = '"+ SA2->A2_COD + "' AND "
			cQuery += "SE2.E2_LOJA = '" + SA2->A2_LOJA + "' AND "
		Endif

		// Para Pessoa fisica totaliza os titulos emitidos no mes
		If cTipo == "F"
			If nVenctoPF == "2"
				If Type("M->E2_VENCREA")=="U"
					cQuery += "SE2.E2_VENCREA  BETWEEN '" + Dtos(FirstDay(SE2->E2_VENCREA)) + "' AND '" + Dtos(LastDay(SE2->E2_VENCREA))+ "' AND "
				Else
					cQuery += "SE2.E2_VENCREA  BETWEEN '" + Dtos(FirstDay(M->E2_VENCREA)) + "' AND '" + Dtos(LastDay(M->E2_VENCREA))+ "' AND "
				EndIf
				lVencto := .T.
			ElseIf nVenctoPF == "1"
				If Type("M->E2_EMISSAO")=="U"
					cQuery += "SE2.E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(SE2->E2_EMISSAO)) + "' AND '" + Dtos(LastDay(SE2->E2_EMISSAO))+ "' AND "
				Else
					cQuery += "SE2.E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(M->E2_EMISSAO)) + "' AND '" + Dtos(LastDay(M->E2_EMISSAO))+ "' AND "
				EndIf
			Else // nVenctoPF == "3"
				cQuery += "SE2.E2_EMIS1  BETWEEN '" + Dtos(FirstDay(dDataBase)) + "' AND '" + Dtos(LastDay(dDataBase))+ "' AND "
			Endif
		Else
			// Para Pessoa juridica totaliza os titulos emitidos no dia
			If nVenctoPJ == "2"
				If Type("M->E2_VENCREA")=="U"
					cQuery += "SE2.E2_VENCREA  = '" + Dtos(SE2->E2_VENCREA) + "' AND "	//Totaliza pelo vencimento real
				Else
					cQuery += "SE2.E2_VENCREA  = '" + Dtos(M->E2_VENCREA) + "' AND "	//Totaliza pelo vencimento real
				EndIf
				lVencto := .T.
			ElseIf nVenctoPJ == "1"
				If Type("M->E2_EMISSAO")=="U"
					cQuery += "SE2.E2_EMISSAO  = '" + Dtos(SE2->E2_EMISSAO) + "' AND "
				Else
					cQuery += "SE2.E2_EMISSAO  = '" + Dtos(M->E2_EMISSAO) + "' AND "
				EndIf
			ElseIf nVenctoPJ == "3" .OR. EMPTY(nVenctoPJ)
				cQuery += "SE2.E2_EMIS1  = '" + Dtos(dDataBase) + "' AND "
			Endif
		Endif
		cQuery += "SE2.E2_TIPO NOT IN " + FormatIn(MVABATIM,"|") 	  + " AND "
		cQuery += "SE2.E2_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)  + " AND "
		cQuery += "SE2.E2_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv) + " AND "
		cQuery += "SE2.D_E_L_E_T_ = ' ' AND "

		//Verifico a filial do SED

		If cAglImPJ == "1" .or. (Eval(bSEDCompart)) //SED Compartilhado
			cQuery += "SED.ED_FILIAL = '"+ xFilial("SED") + "' AND "
		Elseif len(aFilial) >0
			cQuery += "SED.ED_FILIAL IN ( "
			For nLoop := 1 to Len(aFilial)
				cQuery += "'"  + aFilial[nLoop] + "',"
			Next
			//Retiro a ultima virgula
			cQuery := Left( cQuery, Len( cQuery ) - 1 )
			cQuery += ") AND "

		Endif

		cQuery += "SE2.E2_NATUREZ = SED.ED_CODIGO AND "
		
		cCodRet := If(Type("M->E2_CODRET")=="U", SE2->E2_CODRET, M->E2_CODRET) 
		cQuery += "SE2.E2_CODRET = '" + cCodRet + "' AND "
		
		cQuery += "SED.ED_CALCIRF = 'S' AND "
		cQuery += "SED.ED_JURCAP <> '1' AND "
		cQuery += "SED.D_E_L_E_T_ = ' ' "
		If lFIN050IR
			cQuery += ExecBlock("FIN050IR", .F. , .F. , cQuery)
		Endif

		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBIRF", .F., .T.)
		For nX := 1 to Len(aStru)
			If aStru[nX,2] != 'C' .And. FieldPos(aStru[nX,1]) > 0 // Se existir o campo na Query
				TCSetField('TRBIRF', aStru[nX,1], aStru[nX,2],aStru[nX,3],aStru[nX,4])
			Endif
		Next
		dbSelectArea("TRBIRF")
		While !(TRBIRF->(Eof()))
			//Se for inclusao, somo todos os titulos
			//Se for alteração, somo todos os titulos exceto o que esta sendo alterado.
			If (INCLUI .AND. lFinanceiro) .OR. ((ALTERA .OR. !lFinanceiro) .and. SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)!= ;
				TRBIRF->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))

				//desconsidera titulo gerado pela rotina Faturas a pagar, devemos considerar sempre a nota fiscal original
				If !Empty(TRBIRF->E2_FATURA) .AND. ALLTRIM(TRBIRF->E2_ORIGEM) == "FINA290" .AND. (Alltrim(TRBIRF->E2_FATURA) == "NOTFAT")
					TRBIRF->(dbSkip())
					Loop
				Endif

				//Desconsiderar titulo originador de desdobramento
				dbSelectArea("FI8")
				FI8->(DbSetOrder(1))
				If !lNRastDSD .AND. (dbSeek(xFilial("FI8")+TRBIRF->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)) .or.;
					cChvTitDsd == xFilial("SE2")+TRBIRF->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
					TRBIRF->(dbSkip())
					Loop
				Endif

				//Tratamento efetuado para tratar E2_BASEIRF sem gravação de redução de base, pois o ajuste da gravação E2_BASEIRF, ocorreu em Mar/2013
				nValtit:= TRBIRF->(E2_VALOR+E2_IRRF+ Iif(lInssBx,0,E2_INSS)+E2_ISS+E2_SEST)
				If lContrRet .And. !lPccBaixa .And. TRBIRF->(E2_PRETPIS == " " .And. E2_PRETCOF == " " .And. E2_PRETCSL == " ")
					nValtit	+= TRBIRF->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL)
				Endif
				dbSelectArea("SED")
				dbSeek(xFilial("SED")+TRBIRF->E2_NATUREZ)
				If (lBaseDif .and. SED->ED_BASEIRF > 0  .AND. TRBIRF->(E2_BASEIRF)<> nValtit) .or. (lBaseCar .and. SED->ED_BASEIRC > 0 .AND. TRBIRF->(E2_BASEIRF)<> nValtit)
					nTotTit	+= TRBIRF->(E2_BASEIRF)
				Else
					If lBaseDif .and. SED->ED_BASEIRF > 0
						nTotTit	+= nValtit*(SED->ED_BASEIRF/100)
					Elseif lBaseCar .and. SED->ED_BASEIRC > 0
						nTotTit	+= nValtit*(SED->ED_BASEIRC/100)
					Else
						nTotTit	+= nValtit
					Endif
				Endif

				If !lInssBx
					If !lDedInSS .and. SED-> ED_IRRFCAR== "S"
						nTotInCar+= TRBIRF->E2_INSS
					Else
						nTotInss += TRBIRF->E2_INSS
					Endif
				Endif

				nTotIrrf += TRBIRF->E2_IRRF

				//Soma os valores que deveriam ter sido retidos
				//Retidos e os pendentes (menor que valor minimo)
				If lVRetIrf
					nTotRtIr += TRBIRF->E2_VRETIRF
				Endif

				If (lAcumIr .and. !lCalcIr) .Or. cAcmIrrf	==	"2"
					nTotRtIr := 0
				Endif
			Endif
			TRBIRF->(dbSkip())
		Enddo
	EndIf

	If Select("TRBIRF") > 0
		dbSelectArea("TRBIRF")
		dbCloseArea()
	Endif
	RestArea(aAreaSED)

	//Quando a rotina for utilizada pelo Financeiro, tenho a necessidade de calcular o IRRF do titulo presente
	//Nao ocorre com o Compras pois o mesmo já efetuou calculos
	If lFinanceiro
		If nBaseIrrf == 0
			If Type("M->E2_VALOR")=="U"
				nTotTit += SE2->E2_VALOR
			Else
				nTotTit += M->E2_VALOR
			EndIf
		Else
			If !lSRefSE2 .and. (cTipo != "F" .Or. (cPaisLoc == "BRA" .And. cTipo == "F" .And. SED->ED_JURCAP=="1"))
				nTotTit := nBaseIrrf
			Else
				nTotTit += nBaseIrrf
			Endif
		Endif

		If !lInssBx
			If Type("M->E2_INSS")=="U"
				If !(SuperGetMv("MV_INSIRF",.F.,"2") == "1") .and. SED-> ED_IRRFCAR== "S"
					nTotInCar+= SE2->E2_INSS
				Else
					nTotInss += SE2->E2_INSS
				Endif

			Else
				If !lDedInSS .and. SED-> ED_IRRFCAR== "S"
					nTotInCar+= M->E2_INSS
				Else
					nTotInss += M->E2_INSS
				Endif
			Endif
		Endif

		If	nTotInss == 0 .And. IsBlind() .And. nInssRA > 0
			nTotInss	:=	nInssRA
		Endif

		//Com o controle de retenção de IRRF, nao necessito somar titulo a titulo
		//Apenas calcular o IRRF do titulo presente
		//nBaseIrrf > 0 -> Base pre definida pelo SIGAPLS
		If lBaseDif .and. SED->ED_BASEIRF > 0 .and. cTipo != "F"
			nBaseSED := SED->ED_BASEIRF/100
		Endif

		If lVRetIrf .and. cTipo != "F" .and. nBaseIrrf == 0
			If !lSRefSE2
				If Type("M->E2_VALOR")=="U"
					nBaseIrrf := IIF(lDedInSS, (SE2->E2_VALOR * nBaseSED) - Iif(lInssBx,0,SE2->E2_INSS) , (SE2->E2_VALOR * nBaseSED) )
				Else
					nBaseIrrf := IIF(lDedInSS, (m->e2_valor * nBaseSED) - Iif(lInssBx,0,m->e2_inss) , (m->e2_valor * nBaseSED) )
				EndIf
			Else
				nBaseIrrf := IIF(lDedInSS, nTotTit - nTotInss , nTotTit)
			Endif
		Else
			nTotTit -= nTotInCar
			nBaseIrrf := IIF(lDedInSS, nTotTit - nTotInss , Iif(!lDesdob, nTotTit,nBaseIrrf))
			lParc := cTipo == "F" .And. lDesdob .And. FwIsInCallStack("GeraParcSe2")
			If  lPrImPA .and.  Type("M->E2_TIPO")<>"U" .and. !lRtInssPA
				If M->E2_TIPO $ MVPAGANT
					nBaseIrrf := IIF(lDedInSS, nTotTit - M->E2_PRINSS , nTotTit)
				EndIf
			EndIf
		Endif
	Endif

	//Fecha arquivo temporario
	If cAglImPJ != "1" .and. lDelTrbIR .and. (UPPER(Alltrim(TCGetDb()))!="POSTGRES")
		If InTransact()
			StartJob( "DELTRBIR" , GetEnvServer() , .T. , SM0->M0_CODIGO, IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL ),.T.,ThreadID(),cArqTmp,TCGetDb())
		Else
			DELTRBIR(SM0->M0_CODIGO, IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL ),.F.,0,cArqTmp,TCGetDb())
		Endif
	Endif
	dbSelectArea("SE2")

Else
	If lFinanceiro
		If nBaseIrrf == 0
			nTotTit := If( Type("M->E2_VALOR")=="U" , SE2->E2_VALOR , M->E2_VALOR )
		Else
			If !lSRefSE2
				nTotTit := nBaseIrrf
			Else
				nTotTit += nBaseIrrf
			Endif
		Endif

		nTotInss  := If( Type("M->E2_INSS")=="U" , Iif(lInssBx,0,SE2->E2_INSS) , Iif(lInssBx,0,M->E2_INSS) )

		If lBaseDif .and. SED->ED_BASEIRF > 0
			nBaseSED := SED->ED_BASEIRF / 100
		Endif
		nBaseIrrf := IIF(lDedInSS, (nTotTit * nBaseSED) - nTotInss , (nTotTit * nBaseSED) )
	Endif
EndIf

If lFinanceiro
	//Abato os dependentes dos Fornecedores Pessoa Fisica
	If lNumDep .and. cTipo == "F"
		nBaseIrrf -= (nBaseDep * SA2->A2_NUMDEP)
	Endif

	//Ponto de entrada para manipulacao da base de calculo.
	//Deve ser utilizado para tratamento de reducao da base por numero de dependentes
	//Retornar Base de Calculo
	IF lF50CIRFF
		nBaseIrrf := ExecBlock("F50CIRFF",.f.,.f.,nBaseIrrf)
	Endif

	nMoeda	:= If( Type("M->E2_MOEDA")=="U", SE2->E2_MOEDA, M->E2_MOEDA )
	dEmiss	:= If( Type("M->E2_EMISSAO")=="U", SE2->E2_EMISSAO, M->E2_EMISSAO )
	nTxMoeda := If( Type("M->E2_TXMOEDA")=="U", SE2->E2_TXMOEDA, M->E2_TXMOEDA )

	//Calculo o IRRF devido no mes
	If cTipo == "F"
		If !lComiss
			nValor	:= Round(NoRound(fa050TabIR(Round(xMoeda(nBaseIrrf,nMoeda,1,dEmiss,MsDecimais(1)+1,nTxMoeda),MsDecimais(1))),3),2)
		Else
			nValor	:= Round(NoRound(fa050TabIR(Round(xMoeda(nBaseIrrf,1,1,dDataBase,MsDecimais(1)+1,RecMoeda(dDataBase,1)),MsDecimais(1))),3),2)
		EndIf
	Else
		If !lSRefSE2
			nValor 	:= (nBaseIrrf * Iif(AllTrim(Str(nMoeda,2)) $ "01",1,IIf( nTxMoeda > 0,nTxMoeda,RecMoeda(dEmiss,nMoeda)))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100
		Else
			nValor 	:= nBaseIrrf  * IIF(SED->ED_PERCIRF > 0, SED->ED_PERCIRF, GetMV("MV_ALIQIRF")) / 100
		Endif

		If GetNewPar("MV_RNDIRF",.F.)
			nValor	:= Round(nValor,2)
		Else
			nValor	:= NoRound(nValor,2)
		EndIf
	Endif
Else
	dbSelectArea("SE2")
	SE2->(dbGoto(nRecAtual))
	nValor := SE2->E2_IRRF
Endif

//Se verifico a retencao atraves de campo
//Guardo o valor que deveria ser retido
//Atualizo o valor pendente de retencao mais o IRRF do titulo
//Se for chamada pelo rotina de pagamento de comissões, nao faz tratamento de reclock
//pois a função MT530Nat() está dentro de transaction.
If cPaisLoc == "BRA" .And. !lComiss
	If lVRetIrf
		// Se nao for IR na baixa, grava o valor retido de IR
		// caso contrario o campo deve ser gravado gradativamente
		// a cada baixa
		If !lIRPFBaixa
			If Type("M->E2_NUM")=="U"
				RecLock("SE2",.F.)
				SE2->E2_VRETIRF	:= nValor
				SE2->( MsUnLock() )
			Else
				M->E2_VRETIRF	:= nValor
			Endif
		EndIf

		If (SED->ED_JURCAP <> '1')
			If cTipo == "F"  //Pessoa Fisica
				If SA2->A2_TIPO =="F"
					nValor -= nTotIrrf  //Diminuo do valor calculado, o IRRF já retido
					M->E2_VRETIRF	:= nValor
				Else
					nValor -= nTotIrrf
				Endif
			ElseIf cAcmIrrf	<>	"2"
				nValor += nTotRtIr - nTotIrrf
			Endif
		EndIf
	Else
		nValor -= nTotIrrf  //Diminuo do valor calculado, o IRRF já retido
	Endif
EndIf

//Controle de retencao anterior no mesmo periodo
lIrfRetAnt := IIF(nTotIrrf > 0, .T., .F.)

// Verifica se o fornecedor trata o valor minimo de retencao.- FINANCEIRO
If (lFinanceiro .and. lAplMinIR .And. (nValor <= GetMv("MV_VLRETIR") .and. !lIrfRetAnt)) .OR. nValor < 0
	nValor := 0
Endif
RestArea(aArea)

Return (nValor)

/*/
±±³Fun‡…o	 ³Fa050Filho³ Autor ³ Claudio Donizete de Souza³ Data ³ 11/08/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se existe titulo filho (titulo de taxa) e se este	  ³±±
±±³          ³ sofreu baixa            											 	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ Fa050Filho(lVerBaixa)								                 ³±±
/*/
Function Fa050Filho(lVerBaixa)
Local lRet := .T.
Local aTps := {}
Local aParc := {}
Local nX
Local cPrefixo	:= SE2->E2_PREFIXO
Local cNum		:= SE2->E2_NUM
Local aAreaSe2 := SE2->(GetArea())
Local lRotBaixa := FwIsInCallStack("FINA080")
Local lCb10925 := GetNewPar("MV_CB10925","2") == "1"
//Verifica se os campos utilizados para o imposto CIDE.
Local lCIDE  := cPaisLoc == "BRA"
Local lTitPai := .T.
Local cTitPai := Alltrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
Local lFornLjIss := !Empty(SE2->(E2_FORNISS+E2_LOJAISS))
Local cOrigem  := FunName()

Local cAliasAtu := "SE2"
Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.) .And. ;
!SE2->E2_TIPO $ MVPAGANT
Local lRotBordero := FwIsInCallStack("FINA241")
Local cNatPCC := GETMV("MV_PISNAT",,"") + "|" + GETMV("MV_CSLL",,"") + "|" + GETMV("MV_COFINS",,"")
Local lBx10925 := GetNewPar("MV_BX10925","2") == "1"
Local AreaAtu := {}
Local lCancBaixa := IsInCallStack("FA080CAN")
Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

Default lVerBaixa := .F.

If !lRotBaixa
	aTps := {"TX ","INS","ISS","SES"}
	aParc := {SE2->E2_PARCIR,SE2->E2_PARCINS,SE2->E2_PARCISS,SE2->E2_PARCSES}
	If lCIDE
		Aadd(aTps,"CID")
		Aadd(aParc,SE2->E2_PARCCID)
	EndIf
Endif

Aadd(aParc, SE2->E2_PARCPIS)
Aadd(aParc, SE2->E2_PARCCOF)
Aadd(aParc, SE2->E2_PARCSLL)
Aadd(aTps , "TX ")
Aadd(aTps , "TX ")
Aadd(aTps , "TX ") // aTps deve ter o mesmo tamanho de aParc

If lIRPFBaixa
	Aadd(aParc, SE2->E2_PARCIR)
	Aadd(aTps , "TX ")
EndIf

If lCalcIssBx
	Aadd(aParc, SE2->E2_PARCISS)
	Aadd(aTps , "ISS")
EndIf
SE2->(DbSetOrder(1))

If Select("__SE2") == 0 .And. cOrigem == "FINR195"
	AreaAtu := GetArea()
	ChkFile("SE2",.F.,"__SE2")
	RestArea(AreaAtu)
EndIf

For nX := 1 to Len(aTps)
	// Se encontrou o titulo filho (titulo de tributo) e este sofreu baixa
	// Não permite a exclusao do titulo pai (titulo principal).
	If !lRotBaixa

		If nX == 3 .and. lFornLjIss .and. cOrigem != "FINA590"
			cAliasAtu := Alias()
			dbSelectArea("__SE2")
			__SE2->(DbSetOrder(1))
			If !Empty(aParc[nx]) .And. __SE2->(Msseek(xFilial("SE2")+cPrefixo+cNum+aParc[nX]+aTps[nX]))
				While __SE2->(!Eof()) .And. __SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO) == ;
				xFilial("SE2")+cPrefixo+cNum+aParc[nX]+aTps[nX]
					//Se nao existir E2_TITPAI, valida da forma antiga
					//Se E2_TITPAI vazio (titulos antigos), valida da forma antiga
					//Se E2_TITPAI preenchido, pre-valida com a chave do titulo principal
					If !lTitPai .OR. (lTitPai .AND. If(!Empty(__SE2->(E2_TITPAI)),Alltrim(__SE2->(E2_TITPAI)) == cTitPai,.T.)) .and. ;
					(!lVerBaixa .Or. __SE2->E2_SALDO != __SE2->E2_VALOR) .And. !lCb10925
						lRet := .F.
						Exit
					Endif
					__SE2->(dbSkip())
				Enddo
			Endif
			dbSelectArea(cAliasAtu)
			If !lRet
				Exit
			Endif

		ElseIf !Empty(aParc[nx]) .And. SE2->(Msseek(xFilial("SE2")+cPrefixo+cNum+aParc[nX]+aTps[nX])) .And.;
		(!lVerBaixa .Or. SE2->E2_SALDO != SE2->E2_VALOR) .And. ( Iif( !lRotBordero,(!lCb10925).and.(ALLTRIM(SE2->E2_NATUREZ) $ ALLTRIM(GETMV("MV_IRF",,"")) .AND. lIRPFBaixa) .OR. (ALLTRIM(SE2->E2_NATUREZ)  $ cNatPcc .AND. lBx10925) ,;
		(ALLTRIM(SE2->E2_NATUREZ) $ ALLTRIM(GETMV("MV_IRF",,"")) .AND. lIRPFBaixa) .OR.;
		(ALLTRIM(SE2->E2_NATUREZ)  $ cNatPcc .AND. lBx10925) .OR.;
		(ALLTRIM(SE2->E2_NATUREZ) $ GETMV("MV_ISS",,"") .and. GETMV("MV_MRETISS",,"") == "2") ) )
			lRet := .F.
			Exit
		Endif
	Else
		//Se vier do FINA080#FINA750 não verifico o lCb10925, pois será feito a validação no cancelamento/exclusão da baixa.
		If !Empty(aParc[nx]) .And. SE2->(Msseek(xFilial("SE2")+cPrefixo+cNum+aParc[nX]+aTps[nX])) .And.;
		(!lVerBaixa .Or. SE2->E2_SALDO != SE2->E2_VALOR)
			If !( Alltrim(SE2->E2_ORIGEM) == "FINA241" .and. lCancBaixa )
				lRet := .F.
				Exit
			Endif
			Exit
		Endif
	EndIf
Next

SE2->(RestArea(aAreaSe2))

Return lRet

/*/
±±³Fun‡…o	 ³Fa050FDarf³ Autor ³ Adrianne Furtado Andrade ³ Data ³ 15/07/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se existe titulo filho (titulo de taxa) e se este	 ³±±
±±³          ³ está em alguma DARF											 ³±±
/*/
Function Fa050FDarf()
Local lRet := .T.
Local aTps := {}
Local aParc := {}
Local nX
Local cPrefixo	:= SE2->E2_PREFIXO
Local cNum		:= SE2->E2_NUM
Local aAreaSe2 := SE2->(GetArea())
//Verifica se os campos utilizados para o imposto CIDE.
Local lCIDE  := cPaisLoc == "BRA"
Local lTitPai := .T.
Local cTitPai := Alltrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
Local lFornLjIss := !Empty(SE2->(E2_FORNISS+E2_LOJAISS))

Local cAliasAtu := "SE2"


aTps := {"TX ","INS","ISS","SES"}
aParc := {SE2->E2_PARCIR,SE2->E2_PARCINS,SE2->E2_PARCISS,SE2->E2_PARCSES}
If lCIDE
	Aadd(aTps,"CID")
	Aadd(aParc,SE2->E2_PARCCID)
EndIf

Aadd(aParc, SE2->E2_PARCPIS)
Aadd(aParc, SE2->E2_PARCCOF)
Aadd(aParc, SE2->E2_PARCSLL)
Aadd(aTps , "TX ")
Aadd(aTps , "TX ")
Aadd(aTps , "TX ") // aTps deve ter o mesmo tamanho de aParc

SE2->(DbSetOrder(1))

cAliasAtu := Alias()
If Select("__SE2") == 0
	ChkFile("SE2",.F.,"__SE2")
EndIf
DbSelectArea("__SE2")
__SE2->(DbSetOrder(1))
For nX := 1 to Len(aTps)

	If nX == 3 .and. lFornLjIss
		If !Empty(aParc[nx]) .And. __SE2->(Msseek(xFilial("SE2")+cPrefixo+cNum+aParc[nX]+aTps[nX]))
			While __SE2->(!Eof()) .And. __SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO) == ;
			xFilial("SE2")+cPrefixo+cNum+aParc[nX]+aTps[nX]
				//Se nao existir E2_TITPAI, valida da forma antiga
				//Se E2_TITPAI vazio (titulos antigos), valida da forma antiga
				//Se E2_TITPAI preenchido, pre-valida com a chave do titulo principal
				If !lTitPai .OR. (lTitPai .AND. If(!Empty(__SE2->(E2_TITPAI)),Alltrim(__SE2->(E2_TITPAI)) == cTitPai,.T.)) .and. ;
				If(cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN",(AllTrim(__SE2->E2_IDDARF) != ""),.F.)
					lRet := .F.
					Exit
				Endif
				__SE2->(dbSkip())
			Enddo
		Endif
		If !lRet
			Exit
		Endif

	ElseIf !Empty(aParc[nx]) .And. __SE2->(Msseek(xFilial("SE2")+cPrefixo+cNum+aParc[nX]+aTps[nX])) .And.;
	If(cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN",(AllTrim(__SE2->E2_IDDARF) != ""),.F.)
		lRet := .F.
		Exit
	Endif
Next
dbSelectArea(cAliasAtu)
SE2->(RestArea(aAreaSe2))

Return lRet

/*/
±±³Fun‡…o	 ³F050GrvFI2  ³Autor  ³ Marcelo Pimentel    ³ Data ³ 23/11/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava a tabela FI2 com as justificativas                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ F050GrvFI2: O SE2 deve estar poscionado, os dados que serao³±±
±±³          ³    gravados devem estar na variavel publica aItemsFI2.     ³±±
±±³          ³    aItemsFI2[x][1]: Justificativa                          ³±±
±±³          ³    aItemsFI2[x][2]: Titulo do campo (nao utilizado)        ³±±
±±³          ³    aItemsFI2[x][3]: Valor anterior                         ³±±
±±³          ³    aItemsFI2[x][4]: Novo valor                             ³±±
±±³          ³    aItemsFI2[x][5]: Nome do campo                          ³±±
±±³          ³    aItemsFI2[x][6]: Tipo do campo                          ³±±
/*/
Function F050GrvFI2(lGravaLog)
Local nX		:=	1
Local aArea 	:= GetArea()
Local cJustific	:= ""
Local lCposJust := CposJust()
DEFAULT lGravaLog := .F.
If lGravaLog
	lCposJust := .T.
EndIf

If lCposJust .and. Type('aSE2FI2') == "A" .And. Len(aSE2FI2) > 0
	FI2->(DbSetOrder(3))
	For nX:=1 To Len(aSE2FI2)
		If !Empty(aSE2FI2[nX][2])
			cChave	:=	xFilial("FI2")+"2"+SE2->(E2_NUMBOR+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)+aSE2FI2[nX][1]+"2"
			// Pesquisa pela ocorrencia nao gerada (FI2_GERADO = 2 - Ja esta na chave)
			If FI2->(DbSeek(cChave))
				RecLock('FI2',.F.)
				Replace FI2_DTGER WITH dDataBase
				MsUnLock()
			Else
				RecLock('FI2',.T.)
				Replace FI2_FILIAL 	WITH xFilial("FI2")
				Replace FI2_CARTEI  WITH "2"
				Replace FI2_GERADO  WITH "2"
				Replace FI2_NUMBOR 	WITH SE2->E2_NUMBOR
				Replace FI2_PREFIX	WITH SE2->E2_PREFIXO
				Replace FI2_TITULO	WITH SE2->E2_NUM
				Replace FI2_PARCEL	WITH SE2->E2_PARCELA
				Replace FI2_TIPO  	WITH SE2->E2_TIPO
				Replace FI2_CODFOR	WITH SE2->E2_FORNECE
				Replace FI2_LOJFOR	WITH SE2->E2_LOJA
				Replace FI2_DTOCOR	WITH dDataBase
				Replace FI2_VALANT	WITH aSE2FI2[nX][3]
				Replace FI2_VALNOV	WITH aSE2FI2[nX][4]
				Replace FI2_CAMPO 	WITH aSE2FI2[nX][5]
				Replace FI2_TIPCPO	WITH aSE2FI2[nX][6]
				Replace FI2_SEQ  	WITH aSE2FI2[nX][1]
				cJustific := __CUSERID + " -  " + Dtoc(dDatabase) + " / " + Substr(Time(),1,5) + If( _Opc==3,STR0135,STR0136 ) 	//" - Inclusao " ### " - Alteracao "
				MsUnLock()

				MSMM(FI2_HISTOR,,,cJustific+aSE2FI2[nX][2],1,,,"FI2","FI2_HISTOR")
			Endif
		Endif
	Next nX
Endif
RestArea(aArea)
Return(.T.)

/*/
±±³Fun‡…o	 ³Fa050JUST   ³Autor  ³ Marcelo Pimentel    ³ Data ³ 23/11/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Desc.     ³Historico para Alteracao em titulos e inclusoes do tipo AB  ³±±
±±³          ³Abatimento e Alteracao                                      ³±±
/*/
Function Fa050JUST()
Local lRet			:= .T.
Local nMaxLenAnt	:= 10
Local nMaxLenAtu	:= 10
Local nOpcA			:= 0
Local cTipoTit		:= M->E2_TIPO
Local oGetDados
Local lCposJust := CposJust()
Local aCpos     := {}
Private aHead	:= {}

If _Opc == 3
	//Na inclusao verificar se o tipo do titulo pertence a AB-
	If cTipoTit <> "AB-"
		Return .T.
	Endif
EndIf

//Rotina automatica nao abre tela de justificativa
If lF050Auto
	Return .T.
Endif
If lCposJust
	If Empty(aSE2FI2)
		//Para inclusao de titulos do tipo abatimento.
		If Empty(aCposAlter)
			AADD(aCposAlter,"E2_TIPO")
		EndIF

		aSE2FI2	:= BuildSE2FI2( aCposAlter )
	Endif

	If Len(aSE2FI2) > 0
		aHead	:=	{}
		AAdd(aHead, {STR0137,"SEQ","",2 ,0,,Nil,"C",,,,,".F.",,,,})				//"Seq"
		AAdd(aHead, {STR0134,"HISTOR" ,"",80,0,,Nil,"M",,,,,"FA050MEMO()",,,,})	//"Justificativa"
		AAdd(aHead, {STR0138,"VALANT","",nMaxLenAnt,0,,Nil,"C",,,,,".F.",,,,})	//"Valor Anterior"
		AAdd(aHead, {STR0139,"VALATU","",nMaxLenAtu,0,,Nil,"C",,,,,".F.",,,,})	//"Valor Atual"
		AAdd(aHead, {STR0140,"NOMCPO","",10,0,,Nil,"C",,,,,".F.",,,,})			//"Nome Campo "
		AAdd(aHead, {STR0141,"TIPCPO","",1 ,0,,Nil,"C",,,,,".F.",,,,})			//"Tipo Campo "
		DEFINE FONT oBold NAME "Arial" SIZE 0, -13 BOLD
		DEFINE MSDIALOG oDlg FROM 88 ,22  TO 350,619 TITLE STR0062 Of oMainWnd PIXEL	//"Histórico"
		@ 14 ,03   TO 40 ,296 LABEL '' OF oDlg PIXEL
		@ 19 ,10   SAY STR0142 Of oDlg PIXEL SIZE 280 ,30 FONT oBold COLOR CLR_BLUE		//"A justificativa deverá conter no mínimo 5 caracteres."

		oGetDados := MsNewGetDados():New(45,3,120,296,IIf(_Opc==2,0,GD_UPDATE),"fa050juLok","fa050juTOk",,,,Len(aSE2FI2),,,,oDlg,aHead,aSE2FI2)

		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,If(oGetDados:TudoOk(),oDlg:End(),nOpca := 0)},{||oDlg:End()})

		If nOpca==1
			aSE2FI2:=aClone(oGetDados:aCols)
		Else
			lRet := .F.
		EndIf
	EndIf
Endif

Return lRet

/*/
±±³Fun‡…o	 ³BuildSE2FI2 ³Autor  ³ Marcelo Pimentel    ³ Data ³ 23/11/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna os dados do array aSE2FI2                     ³±±
±±³          ³                                                            ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ BuildSE2FI2                                                ³±±
±±³          ³    aCpos  : nomes dos campos que serao avaliados           ³±±
±±³          ³    aDados : dados dos campos de acpos                      ³±±
/*/
Static Function BuildSE2FI2( aCpos )
Local aItems 		:= {}
Local nMaxLenAnt	:=	10
Local nMaxLenAtu	:=	10
Local nX			:=	0
Local cDadoAnt		:=	""
Local cDadoAtu		:=	""
Local xValAnt		:=	""
Local cTipo  		:=  ""
Local cRet			:=  ""
Local cItems		:=  ""
Local lCposJust 	:= CposJust()
Local lF050JUST 	:= ExistBlock("F050JUST")

If lCposJust
	//Monta Interface para incluir as JUSTIFICATIVAS
	dbSelectArea("FI2")
	DbSetOrder(3)
	If DbSeek(xFilial("FI2")+"2"+M->E2_NUMBOR+M->E2_PREFIXO+M->E2_NUM+M->E2_PARCELA+M->E2_TIPO+M->E2_FORNECE+M->E2_LOJA)
		While !Eof() .and. FI2->FI2_NUMBOR+FI2->FI2_PREFIX+FI2->FI2_TITULO+FI2->FI2_PARCEL+FI2->FI2_TIPO+FI2->FI2_CODFOR+FI2->FI2_LOJFOR == ;
		M->E2_NUMBOR+M->E2_PREFIXO+M->E2_NUM+M->E2_PARCELA+M->E2_TIPO+M->E2_FORNECE+M->E2_LOJA .AND. ;
		xFilial("FI2") == FI2->FI2_FILIAL
			cRet := MSMM(FI2->FI2_HISTOR,80)
			Aadd(aItems,{FI2->FI2_SEQ,cRet,FI2->FI2_VALANT,FI2->FI2_VALNOV,FI2->FI2_CAMPO,FI2->FI2_TIPCPO,.F.})
			dbSkip()
		EndDo
	EndIf

	If lF050JUST
		aItems := ExecBlock("F050JUST",.f.,.f.,{aItems})
	Else
		For nX := 1 To Len(aCpos)
			xValAnt	:=	&("M->"+aCpos[nX])
			If xValAnt <> SE2->(FieldGet(FieldPos(aCpos[nX])))
				cTipo	:=	ValType(SE2->(FieldGet(FieldPos(aCpos[nX]))))
				Do Case
					Case  cTipo == "L"
					cDadoAnt	:=	AlltoChar(SE2->(FieldGet(FieldPos(aCpos[nX]))))
					cDadoAtu	:=	AlltoChar(xValAnt)
					Case  cTipo == "D"
					cDadoAnt	:=	DtoC(SE2->(FieldGet(FieldPos(aCpos[nX]))))
					cDadoAtu	:=	DtoC(xValAnt)
					Case  cTipo == "N"
					cDadoAnt	:=	TransForm(SE2->(FieldGet(FieldPos(aCpos[nX]))),PesqPict('SE2',aCpos[nX]))
					cDadoAtu	:=	TransForm(xValAnt,PesqPict('SE2',aCpos[nX]))
					OtherWise
					cDadoAnt	:=	SE2->(FieldGet(FieldPos(aCpos[nX])))
					cDadoAtu	:=	xValAnt
				EndCase
				cItems	:= StrZero(Len(aItems)+1,2)
				Aadd(aItems,{cItems," " ,cDadoAnt,cDadoAtu,aCpos[nX],cTipo,.F.})
				nMaxLenAnt	:=	Max(nMaxLenAnt,Len(cDadoAnt))
				nMaxLenAtu	:=	Max(nMaxLenAtu,Len(cDadoAtu))
			Endif
		Next
	EndIf
Endif
Return aItems

/*/
±±³Fun‡…o	 ³fa050juLok³ Autor ³ Marcelo Pimentel      ³ Data ³ 23.11.05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida a linha da getdados                                  ³±±
/*/
Function fa050juLok()
Local nPosMemo := Ascan(aHead, {|x| x[2] == "HISTOR"})
//³ Nao valida linha deletada                          ³
If aCols[n][Len(aHead)+1]
	Return .T.
Endif

If Empty(aCols[n][nPosMemo])
	Aviso( STR0026, STR0143, {"Ok"} )		//"Atencao" ### "Obrigatório o preenchimento da justificativa."
	Return .F.
Endif

If Len(aCols[n][nPosMemo]) < 5
	Aviso( STR0026, STR0144, {"Ok"} )		//"Atencao" ### "Justificativa inválida, favor redigitá-la."
	Return .F.
Endif

Return .T.

/*/
±±³Fun‡…o	 ³fa050juTOk³ Autor ³ Marcelo Pimentel      ³ Data ³ 23.11.05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida todas as linhas da getdados                          ³±±
/*/
Function fa050juTOk()
Local lRet := .T.
Local nX   := 0

For nX := 1 To Len(aCols)
	If !fa050juLok()
		lRet := .F.
		Exit
	Endif
Next

Return lRet

/*/
±±³Fun‡…o	 ³FA050MEMO ³ Autor ³ Marcelo Pimentel      ³ Data ³ 23.11.05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida se campo MEMO para modo de alteracao ou visualizacao ³±±
/*/
Function FA050MEMO()
Local lRet	:= .T.
FI2->(dbsetorder(3))
If FI2->(DbSeek(xFilial("FI2")+"2"+M->E2_NUMBOR+M->E2_PREFIXO+M->E2_NUM+M->E2_PARCELA+M->E2_TIPO+M->E2_FORNECE+M->E2_LOJA+StrZero(n,2)))
	lRet := .F.
EndIf
Return lRet

/*/
±±³Fun‡…o	 ³CPOSJUST  ³ Autor ³ Mauricio Pequim Jr    ³ Data ³ 29.11.05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida existencia dos campos para justificativa             ³±±
/*/
Function CposJust()
Local lCposJust := .T.
//Liga Justificativa Instrucoes Bancarias
// 1 = Receber
// 2 = Pagar
// 3 = Liga Ambas
// 4 = Nao Utiliza
Local lJustCP   := SuperGetMv("MV_INCOBBC",.T.,"4") $ "2/3"

Return lCposJust .And. lJustCP

/*/
±±³Fun‡…o	 ³F050PcoLan³ Autor ³ Bruno Sobieski        ³ Data ³ 19.01.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Executa validacaso de saldos do PCO                         ³±±
/*/
Function F050PcoLan()
Local lRet	:=	.T.
If !PcoVldLan("000002",IIF(M->E2_TIPO$MVPAGANT,"02","01"),"FINA050")
	lRet	:=	.F.
	//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
	If SE2->E2_TIPO $ MVPAGANT
		PcoDetLan("000002","02","FINA050")
	Else
		PcoDetLan("000002","01","FINA050")
	EndIf
Endif

Return lRet

/*/
±±³Fun‡…o	 ³Fa050bAval³ Autor ³ Claudio Donizete      ³ Data ³ 27.03.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Avalia se o titulo pode ser seleciona na substituicao de    ³±±
±±³          ³titulos provisorios                                         ³±±
/*/
Function Fa050bAval(cMarca,oValor,oQtdtit,nValorS,nQtdTit,oMark,nMoedSubs,aChaveLbn,nRegSel)
Local lRet 		:= .T.
Local cChaveLbn

cChaveLbn := "SUBS" + xFilial("SE2")+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
// Verifica se o registro nao esta sendo utilizado em outro terminal
//-- Parametros da Funcao LockByName() :
//   1o - Nome da Trava
//   2o - usa informacoes da Empresa na chave
//   3o - usa informacoes da Filial na chave
If LockByName(cChaveLbn,.T.,.F.)
	Fa050Inverte(cMarca,oValor,oQtdtit,@nValorS,@nQtdTit,@oMark,nMoedSubs,aChaveLbn,cChaveLbn,.F.,@nRegSel) // Marca o registro e trava
	lRet := .T.
Else
	IW_MsgBox(STR0147,STR0115,"STOP") // "Este titulo está sendo utilizado em outro terminal, não pode ser utilizado para substituição"##Atenção
	lRet := .F.
Endif
oMark:oBrowse:Refresh(.t.)
Return lRet

//-------------------------------------------------------------------
/*{Protheus.doc} MenuDef
Utilizacao de menu Funcional

Parametros do array aRotina
1. Nome a aparecer no cabecalho
2. Nome da Rotina associada
3. Reservado
4. Tipo de Transação a ser efetuada:
	1 - Pesquisa e Posiciona em um Banco de Dados
	2 - Simplesmente Mostra os Campos
	3 - Inclui registros no Bancos de Dados
	4 - Altera o registro corrente
	5 - Remove o registro corrente do Banco de Dados
5. Nivel de acesso
6. Habilita Menu Funcional

@author Ana Paula N. Silva
@version P12
@since   29/11/2006
@return  Array com opcoes da rotina.
*/
//-------------------------------------------------------------------
Static Function MenuDef(nOpcion)
Local aRotina
Local lF050ROT 	:= ExistBlock("F050ROT")

If cPaisLoc $ "ARG|POR|EUA" .And. nOpcion # Nil
	aRotina := {{ OemToAnsi(STR0001),"FA050PesInd"	, 0 , 1, ,.F.},; //"Pesquisar"
				{ OemToAnsi(STR0002),"FA050Visua"	, 0 , 2},; //"Visualizar"
				{ OemToAnsi(STR0003),"FA050Inclu"	, 0 , 3},; //"Incluir"
				{ OemToAnsi(STR0004),"FA050Alter"	, 0 , 4},; //"Alterar"
				{ OemToAnsi(STR0005),"FA050Delet"	, 0 , 5},; //"Excluir"
				{ OemToAnsi(STR0133),"MSDOCUMENT"	, 0 , 4},; //"Conhecimento"
				{ OemToAnsi(STR0252),"FN50Log"   	, 0 , 7},; //"historico do titulo"
				{ OemToAnsi(STR0098),"FA040Legenda" , 0 , 6 ,,.F.} } //"Legenda"
Else
	aRotina := {{ OemToAnsi(STR0001),"AxPesqui"    , 0 , 1, ,.F.},; //"Pesquisar"
				{ OemToAnsi(STR0002),"FA050Visua"  , 0 , 2},; //"Visualizar"
				{ OemToAnsi(STR0003),"FA050Inclu"  , 0 , 3},; //"Incluir"
				{ OemToAnsi(STR0004),"FA050Alter"  , 0 , 4},; //"Alterar"
				{ OemToAnsi(STR0005),"FA050Delet"  , 0 , 5},; //"Excluir"
				{ OemToAnsi(STR0006),"FA050Subst"  , 0 , 6},; //"Substituir"
				{ OemToAnsi(STR0165),"FaCanDsd"    , 0 , 5},; //"Canc.Desdobr."
				{ OemToAnsi(STR0110),"FA050Rateio" , 0 , 2},; //"Vis Rateio"
				{ OemToAnsi(STR0159),"FA050AGEND"  , 0 , 6},;
				{ OemToAnsi(STR0133),"MSDOCUMENT"  , 0 , 4},;//"Conhecimento"
				{ OemToAnsi(STR0098),"FA040Legenda", 0 , 7,,.F.},;// "Legenda"
				{ OemToAnsi(STR0252),"FN50Log"     , 0 , 9} }// "historico do titulo"

Endif

aAdd( aRotina, { OemToAnsi(STR0231),"CTBC662"   , 0, 8}) //"Tracker Contábil"
aAdd( aRotina, { OemToAnsi(STR0187),"FA050Docs" , 0, 6}) //"Documentos"
aAdd( aRotina, { OemToAnsi(STR0201),"FA050Contr", 0, 2}) // Rastr. Contratos
aAdd( aRotina, { OemToAnsi(STR0247),"FINA689"   , 0, 4}) //"Conversão em Lote de Adtos Viagem"

If cPaisLoc == "RUS"
	aAdd( aRotina, { OemToAnsi(STR0311),"FIN50PQBrw",0,4})		//"Track PRs"
EndIf

If cPaisLoc == "BRA"
	aAdd( aRotina, { STR0279,"FINA986('SE2',.T.)",0,4}) //"Complemento do ti­tulo"
EndIf

// Consulta multinatureza
If lF050CMNT .and. MV_MULNATP
	aAdd( aRotina, { STR0277 ,"F050CMNT()", 0 , 2})	//"Consulta Rateio Multi Naturezas - Emissão"
Endif

If lIntPFS // Integração SIGAPFS x SIGAFIN
	aAdd( aRotina , { STR0299, "JURA247(4)", 0, 0, 0, NIL } ) //"Desdobramento Pós Pagamento"
Endif

//Motor de Retenções
If lTemMR
	aAdd( aRotina, { OemToAnsi(STR0300),"FINCRET('SE2')"   , 0, 9}) //'Consulta de Retenções'
Endif

If __lFINA050VA .And. __lExisFKD
	aAdd( aRotina, { OemToAnsi( STR0313 ), "FINA050VA", 0, 4 } ) //###STR0313 "Valores Acessórios"
EndIf

//³Ponto de entrada para inclusão de novos itens no menu aRotina³
If lF050ROT
	aRotinaNew := ExecBlock("F050ROT",.F.,.F.,aRotina)
	If (ValType(aRotinaNew) == "A")
		aRotina := aClone(aRotinaNew)
	EndIf
EndIf

Return(aRotina)

/*/
±±³Program   ³F050CmpRat³ Autor ³ Adrianne Furtado      ³ Data ³ 13.12.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna Campos do Rateio                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Matriz com campos alteraveis                       ³±±
/*/
Function F050CmpRat(aAltera)

Local aSaveArea:= GetArea()
Local aCampos	:= {}
Local aFora		:= {	"CTJ_FILIAL", "CTJ_RATEIO","CTJ_DESC","CTJ_MOEDLC","CTJ_TPSALD",;
							"CTJ_SEQUEN", "CTJ_QTDTOT"}

dbSelectArea("SX3")
dbSetOrder(1)
dbSeek("CTJ")
While !EOF() .And. (X3_ARQUIVO == "CTJ")
	If Ascan(aFora,TRIM(X3_CAMPO)) <= 0
		AADD(aHeader,{ TRIM(X3Titulo()), X3_CAMPO, X3_PICTURE,;
							X3_TAMANHO, X3_DECIMAL, X3_VALID,;
							X3_USADO, X3_TIPO, "TMP", X3_CONTEXT } )
		AADD(aCampos, { SX3->X3_CAMPO, SX3->X3_TIPO, SX3->X3_TAMANHO,;
							 SX3->X3_DECIMAL } )
		If Alltrim(x3_campo) <> "CTJ_QTDDIS"
			Aadd(aAltera,Trim(X3_CAMPO))
		EndIf
	EndIf
	dbSkip()
EndDO
Aadd(aCampos,{"CTJ_FLAG","L",1,0})

//Ponto de Entrada para inclusao de novos campos.
If lF050HEAD
	aCampos := 	ExecBlock("F050HEAD",.f.,.f.,{aCampos})
EndIf

RestArea(aSaveArea)

Return aCampos

/*
±±³Fun‡„o	 ³F050MovBco³ Autor ³ Marcel Borges Ferreira³ Data ³ 05/02/07  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Verifica se um PA gerou movimentacao bancária                ³±±
*/
Static Function F050MovBco()
Local aArea := GetArea()
Local lMovBco

dbSelectArea("SE5")
dbSetOrder(7)
If MsSeek(xFilial("SE5")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
	lMovBco := .T.
Else
	lMovBco := .F.
EndIf

RestArea(aArea)
Return lMovBco

/*/
±±³Fun‡…o    ³F040SelPR  ³ Autor ³ Marcelo Celi Marques ³ Data ³ 19.05.08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Markbrowse da Substituição							              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ F040SelPR(oDlg,cOutMoeda,nValorS,nQtdTit,cMarca,			  ³±±
±±³			 ³					 oValor,oQtdTit,nMoedSubs)							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpO1 = Objeto onde se encaixara a MarkBrowse				  ³±±
±±³			 ³ ExpC1 = Tratamento aplicado a outras moedas (<>1)			  ³±±
±±³			 ³ ExpN1 = Valor dos titulos selecionados							  ³±±
±±³			 ³ ExpN2 = Quantidade de titulos selecionados					  ³±±
±±³			 ³ ExpC2 = Marca (GetMark())				 							  ³±±
±±³			 ³ ExpO2 = Objeto Valor dos titulos selecionados p/ refresh	  ³±±
±±³			 ³ ExpO3 = Objeto Quantidade de titulos selecionados p/refresh³±±
±±³			 ³ ExpN3 = Moeda da Substituicao             					  ³±±
±±³			 ³ ExpO4 = Objeto Painel superior a ser desabilitado			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA040                                                    ³±±
/*/
Function F050SelPR(oDlg,cOutMoeda,nValorS,nQtdTit,cMarca,oValor,oQtdTit,nMoedSubs,oButton,a1stRow,a2ndRow,nRegSel)
Local nRecno := 0
Local lInverte 	:= .F.
Local lRet := .T.
Local cTipoProvis := ""
Local lFA050Fil := ExistBlock( "FA050Fil" )
Local lFA050BRO := ExistBlock( "FA050BRO" )

//³ Cria indice condicional												  ³
If Select("__SUBS") == 0
	ChkFile("SE2",.F.,"__SUBS")
EndIF
cAlias := "__SUBS"

cIndex := CriaTrab(nil,.f.)
cChave := IndexKey()

If cPaisLoc == "EQU"
	cTipoProvis := MVPROVIS
	cTipoProvis += "|NF "
Else
	cTipoProvis := MVPROVIS
EndIf

cFor :=	'E2_SALDO==E2_VALOR .And.E2_TIPO $ "'+cTipoProvis+'" .And. '
cFor +=	'E2_FORNECE == "'+cCodFor+'".and. E2_LOJA == "'+cLojaFor+'" .And. '
cFor += 'DTOS(E2_EMISSAO) <= "' + Dtos(dDatabase) + '" .And. '	//titulos com emissao futura serao desconsiderados
cFor += '!(Alltrim(E2_ORIGEM) $ "FINA171|FINI055") '						//titulos emitidos por Emprestimos com geracao de parcelas	//aqui kco

If cOutMoeda == "1" // Nao considera outras moedas
	cFor +=  '.and. E2_MOEDA=='+Alltrim(STR(nMoedSubs))
Endif

// Complemento de filtro Siafi
cFor += FinTemDH(.T. /*lFiltro*/,/*cAlias*/,.F. /*lHelp*/, .F./*lTop*/)

//³ Execblock para incluir filtragem na IndRegua                       ³
//³ Devera retornar uma string para ser incluida na condicao.          ³
If lFA050Fil
	cFor += ExecBlock("FA050Fil",.f.,.f.)
Endif

If lFA050BRO
	cChave := ExecBlock("FA050BRO",.F.,.F.,{cChave})
Endif

IndRegua(cAlias,cIndex,cChave,,cFor, OemToAnsi(STR0019) ) // "Selecionando Registros..."
nIndex := RetIndex("SE2","__SUBS")
dbSelectArea(cAlias)
dbSetOrder(nIndex+1)
dbGoTop()
If (BOF() .and. EOF()) .or. Deleted()
	Help(" ",1,"RECNO")
	dbSelectArea("__SUBS")
	dbCloseArea()
	Ferase(cIndex+OrdBagExt())
	cIndex:=""
	dbSelectArea("SE2")
	dbGoTop()
	lRet := .F.
EndIf

If lRet
	//³ Monta array com campos a serem visualizados na MsSelect.	  ³
	//³ Se torna necess rio pois o arquivo para montar a MSelect ‚	  ³
	//³ a area auxiliar (SUBS).      	                          	  ³
	fa050DesMarca(aChaveLbn)
	AADD(aCampos,{"E2_OK","","  ",""})
	dbSelectArea("SX3")
	dbSetOrder(1)
	dbSeek ("SE2")
	nRecno:=Recno()
	dbSetOrder(2)
	If dbSeek("E2_FILIAL")
		AADD(aCampos,{X3_CAMPO,"",X3_TITULO,X3_PICTURE})
	EndIf
	dbSetOrder(1)
	dbGoto(nRecno)
	While !EOF() .And. (x3_arquivo == "SE2")
		IF ((X3USO(x3_usado)  .AND. cNivel >= x3_nivel .and. SX3->X3_context # "V") .Or.;
			(X3_PROPRI == "U" .and. SX3->X3_context # "V")) .And. (X3_CAMPO # "E2_FILIAL")
			AADD(aCampos,{X3_CAMPO,"",X3_TITULO,X3_PICTURE})
		Endif
		dbSkip()
	Enddo
	AADD(aCampos,{{ || F050ConVal(nMoedSubs)},"",STR0024,"@E 999,999,999.99"})
	//³ Mostra a tela de Titulos Provisorios - WINDOWS					  ³
	nOpcA := 0
	dbSelectArea("__SUBS")
	dbGoTop()
	cSimb := Pad(Getmv("MV_SIMB"+Alltrim(STR(nMoedSubs))),4)+":"

	@ a1stRow[1] + 016,a1stRow[1] + 155 Say oQtdTit VAR nQtdTit Picture "999" FONT oDlg:oFont PIXEL Of oDlg
	@ a1stRow[1] + 016,a1stRow[1] + 290 Say oValor	VAR nValorS Picture PesqPict("SE2","E2_VALOR",14) FONT oDlg:oFont PIXEL Of oDlg

	oMark := MsSelect():New("__SUBS","E2_OK","!E2_SALDO",aCampos,@lInverte,@cMarca,a2ndRow,,,oDlg)
	oMark:oBrowse:lhasMark := .T.
	oMark:oBrowse:lCanAllmark := .T.
	oMark:oBrowse:bAllMark := { || FA050Inverte(cMarca,oValor,oQtdtit,@nValorS,@nQtdTit,@oMark,nMoedSubs,aChaveLbn,,.T.,@nRegSel) }
	oMark:bMark := {||Fa050Exibe(@nValorS,@nQtdTit,@aDeletar,&(IndexKey()),oValor,oQtdTit,nMoedSubs)}
	oMark:bAval	:= {||Fa050bAval(cMarca,oValor,oQtdtit,@nValorS,@nQtdTit,@oMark,nMoedSubs,aChaveLbn,@nRegSel)}

	oMark:oBrowse:SetFocus()

	CursorArrow()

	oButton:Disable()

Endif

Return lRet

/*/
±±³Fun‡…o    ³FinA050T   ³ Autor ³ Marcelo Celi Marques ³ Data ³ 26.03.08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Chamada semi-automatica utilizado pelo gestor financeiro   ³±±
/*/
Function FinA050T(aParam)
	cRotinaExec := "FINA050"

	ReCreateBrow("SE2",FinWindow)

	FinA050(,,aParam[1])

	ReCreateBrow("SE2",FinWindow, , .T.)

	dbSelectArea("SE2")

	INCLUI := .F.
	ALTERA := .F.
Return .T.

/*/
±±³Fun‡…o	 ³F050GrvSE5³ Autor ³ Mauricio Pequim Jr	  ³ Data ³ 20/04/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gravacao de registros do SE5 na inclusao C.Pagar			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ F050GrvSE5()		 										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Controle de operacao								  ³±±
±±³			 ³ ExpL2 = Controle de desdobramento						  ³±±
±±³			 ³ ExpN3 = Recno do Registro                              	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA040													  ³±±
/*/
Function F050GrvSE5(nOpc,lDesdobr,nRecSE2)
Local nProxRec		:= 0
Local aAreaGrv		:= GetArea()
Local lRastro		:= FVerRstFin()

//Nova estrutura SE5
Local oModel
Local cLog := ""
Local oSubFK2
Local oSubFK3
Local oSubFK4
Local oSubFK5
Local oSubFK6
Local oSubFKA
Local aAreaAnt
Local cOrig:=Funname()
Local cCamposE5:=""

//³Parametro que permite ao usuario utilizar o desdobramento³
//³da maneira anterior ao implementado com o rastreamento.  ³
Local lNRastDSD		:= SuperGetMV("MV_NRASDSD",.T.,.F.)

DEFAULT lDesdobr	:= .F.

If nOpc == 1  //Inclusao

	If (lDesdobr .AND. lRastro .AND. !lNRastDSD)

		//Em caso de rastreamento, posiciono no registro do titulo gerador do desdobramento
		SE2->(dbGoto(nRecSE2))

		aAreaAnt := GetArea()
		oModel :=  FWLoadModel('FINM020')//Bx Contas a Pagar
		oModel:SetOperation(3) // Inclusao
		oModel:Activate()
		oModel:SetValue( "MASTER", "E5_GRV", .T. )
		oModel:SetValue( "MASTER", "NOVOPROC", .T. )
		oSubFK2  := oModel:GetModel("FK2DETAIL")
		oSubFK3  := oModel:GetModel("FK3DETAIL")
		oSubFK4  := oModel:GetModel("FK4DETAIL")
		oSubFK5  := oModel:GetModel("FK5DETAIL")
		oSubFK6  := oModel:GetModel("FK6DETAIL")
		oSubFKA  := oModel:GetModel("FKADETAIL")

		cChaveTit := xFilial("SE2") + "|" + SE2->E2_PREFIXO + "|" + SE2->E2_NUM     + "|" + SE2->E2_PARCELA + "|" + ;
		SE2->E2_TIPO    + "|" + SE2->E2_FORNECE + "|" + SE2->E2_LOJA
		cChaveFK7 := FINGRVFK7("SE2", cChaveTit)
		cIdDoc	:= FWUUIDV4()
		cCamposE5:="{"

		cCamposE5 += "{'E5_TIPO'    , '"+SE2->E2_TIPO+"'}"
		cCamposE5 += ",{'E5_PREFIXO' , '"+SE2->E2_PREFIXO+"'}"
		cCamposE5 += ",{'E5_NUMERO'  , '"+SE2->E2_NUM+"'}"
		cCamposE5 += ",{'E5_PARCELA' , '"+SE2->E2_PARCELA+"'}"
		cCamposE5 += ",{'E5_CLIFOR'  , '"+SE2->E2_FORNECE+"'}"
		cCamposE5 += ",{'E5_FORNECE' , '"+SE2->E2_FORNECE+"'}"
		cCamposE5 += ",{'E5_LOJA'    , '"+SE2->E2_LOJA+"'}"
		cCamposE5+= ",{'E5_DTDIGIT', 	dDataBase  }"
		cCamposE5 += ",{'E5_BENEF'   , '"+SE2->E2_NOMFOR+"' }"
		cCamposE5 += ",{'E5_DTDISPO' , CTOD('"+DTOC(SE5->E5_DATA)+"') } "

		// Grava ID do titulo
		If !oSubFKA:IsEmpty()
			oSubFKA:AddLine()
		EndIf

		oSubFKA:SetValue( "FKA_IDORIG", cIdDoc )
		oSubFKA:SetValue( "FKA_TABORI", "FK2" )
		oSubFK2:SetValue( "FK2_IDDOC"  , cChaveFK7 )
		oSubFK2:SetValue( "FK2_DATA", SE2->E2_EMISSAO )
		oSubFK2:SetValue( "FK2_NATURE",  SE2->E2_NATUREZ )
		oSubFK2:SetValue( "FK2_LA", "S")
		oSubFK2:SetValue( "FK2_MOTBX", "DSD" )
		oSubFK2:SetValue( "FK2_RECPAG","P" )
		oSubFK2:SetValue( "FK2_HISTOR",  Rtrim(SubStr(SE2->E2_HIST,1,TAMSX3("FK2_HISTOR")[1])))
		oSubFK2:SetValue( "FK2_FILORI", SE2->E2_FILORIG )
		oSubFK2:SetValue( "FK2_ORIGEM", cOrig )
		oSubFK2:SetValue( "FK2_TPDOC", "BA" )

		If cPaisLoc <> "BRA"
			SA6->(DbSetOrder(1))
			SA6->(DbSeek(xFilial()+cBancoAdt+cAgenciaAdt+cNumCon))
			If( Max(IIf(Type("SA6->A6_MOEDAP")=="U",SA6->A6_MOEDA,SA6->A6_MOEDAP),1) )== 1

				oSubFK2:SetValue( "FK2_VALOR", SE2->E2_VLCRUZ)
				oSubFK2:SetValue( "FK2_VLMOE2", SE2->E2_VALOR)
				oSubFK2:SetValue( "FK2_MOEDA", Strzero(Max(IIf(Type('SA6->A6_MOEDAP')=='U',SA6->A6_MOEDA,SA6->A6_MOEDAP),1),2) )
			Else

				oSubFK2:SetValue( "FK2_VALOR", SE2->E2_VALOR)
				oSubFK2:SetValue( "FK2_VLMOE2", SE2->E2_VLCRUZ  )
				oSubFK2:SetValue( "FK2_MOEDA", Strzero(Max(IIf(Type('SA6->A6_MOEDAP')=='U',SA6->A6_MOEDA,SA6->A6_MOEDAP),1),2) )
			Endif
		Else
			oSubFK2:SetValue( "FK2_MOEDA", "01" )
			oSubFK2:SetValue( "FK2_VALOR", SE2->E2_VLCRUZ )
			oSubFK2:SetValue( "FK2_VLMOE2",  SE2->E2_VALOR  )
		Endif

		oSubFK2:SetValue( "FK2_TXMOED", SE2->E2_TXMOEDA)

		cCamposE5+="}"

		oModel:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )
		If oModel:VldData()
			oModel:CommitData()
			oModel:DeActivate()
		Else
			cLog := cValToChar(oModel:GetErrorMessage()[4]) + ' - '
			cLog += cValToChar(oModel:GetErrorMessage()[5]) + ' - '
			cLog += cValToChar(oModel:GetErrorMessage()[6])

			If (Type("lF050Auto") == "L" .and. !lF050Auto)
				Help( ,,"M050VALID",,cLog, 1, 0 )
			EndIf
		EndIf

		RestArea(aAreaAnt )
		Reclock("SE2", .F. )
		nSE2Rec := Recno()
		SE2->E2_BAIXA		:= dDatabase
		SE2->E2_MOVIMEN	:= dDatabase
		SE2->E2_DESCONT	:= SE2->E2_SDDECRE
		SE2->E2_JUROS		:= SE2->E2_SDACRES
		SE2->E2_VALLIQ		:= SE2->(E2_VLCRUZ+E2_SDACRES-E2_SDDECRE)
		SE2->E2_SALDO		:= 0
		SE2->E2_SDACRES	:= 0
		SE2->E2_SDDECRE	:= 0
		SE2->E2_STATUS		:= "D"
		MsUnlock()
	EndIf

ElseIf nOpc == 2  //Exclusao de titulo

	//Limpa chaves de relacionamento (SE5 e SEF)
	dbSelectArea("SE5")
	dbSetOrder(7)
	If dbSeek(xFilial("SE5")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
		While !Eof() .and. xFilial("SE5") == SE5->E5_FILIAL .and. ;
		SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_FORNECE+E5_LOJA) == ;
		SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
			nAtuRec := SE5->(RECNO())
			SE5->(DbSkip())
			nProxRec := SE5->(Recno())
			SE5->(dbGoto(nAtuRec))
			dbSelectArea( "FK2" )//limpando dados de estorno
			FK2->( DbSetOrder( 1 ) )//FK2_FILIAL+FK2_IDMOV
			If SE5->E5_TABORI== "FK2" .AND. MsSeek( xFilial("FK2") + SE5->E5_IDORIG )
				cCamposE5:="{"
				cCamposE5+="{'E5_KEY',E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA } "
				cCamposE5+= ",{'E5_PREFIXO', '' }"
				cCamposE5+= ",{'E5_NUMERO', '' }"
				cCamposE5+= ",{'E5_PARCELA', '' }"
				cCamposE5+= ",{'E5_TIPO', '' }"
				cCamposE5+= ",{'E5_LA', 'S' }"
				cCamposE5+="}"

				aAreaAnt := GetArea()

				oModel :=  FWLoadModel('FINM020')//Baixas a Pagar
				oModel:SetOperation( 4 ) //Alteração
				oModel:Activate()
				oModel:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
				oModel:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK5

				oSubFK2  := oModel:GetModel("FK2DETAIL")
				oSubFKA  := oModel:GetModel("FKADETAIL")
				oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )

				//Dados do movimento
				oSubFK2 := oModel:GetModel( "FK2DETAIL" )
				oSubFK2 :SetValue( "FK2_LA", "S" )

				If oModel:VldData()
					oModel:CommitData()
					oModel:DeActivate()
				Else
					cLog := cValToChar(oModel:GetErrorMessage()[4]) + ' - '
					cLog += cValToChar(oModel:GetErrorMessage()[5]) + ' - '
					cLog += cValToChar(oModel:GetErrorMessage()[6])

					Help( ,,"M050VALID",,cLog, 1, 0 )
				EndIf

				RestArea(aAreaAnt)
			EndIf
			FKCOMMIT()
			SE5->(dbGoto(nProxRec))
		Enddo
	EndIf
EndIf

RestArea(aAreaGrv)

Return

/*
±±ºPrograma  ³FA050VLSUBºAutor  ³Eduardo Ramalho     º Data ³  11/26/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Valida a Tela da Substituicao de provisorios                º±±
±±º          ³Retorno logico. (.T. ou .F.)                                º±±
*/
Static Function FA050VLSUB()
Local lRet := .T.
Local lFA050VLS:= ExistBlock("FA050VLS")

If nQtdTit < 1
	lRet := .F.
	Aviso(STR0115, STR0151, {"Ok"}) //"Atencao"##"Selecionar o título a ser substituido."
EndIf

If lFA050VLS .And. lRet
	lRet := ExecBlock("FA050VLS",.F.,.F.)
EndIf

Return lRet

/*
±±ºPrograma  ³FINA050   ºAutor  ³Totvs               º Data ³  05/11/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verifica a possibilidade de Alteração de um titulo que teveº±±
±±º          ³ seus impostos(PCC) Retido em outro Titulo(Retentor)        º±±
*/
Function F050VerAlt(lHelp)
Local aArea 		:= GetArea()
Local aAreaSE2 	:= SE2->(GetArea())
Local aAreaSFQ 	:= SFQ->(GetArea())
Local lRet			:= .T.
Local lContrRet := .T.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"


DEFAULT lHelp := .T.

//Caso controle retencao de PCC e o titulo possua calculo de PCC e a retencao seja na emissao
If lContrRet .and. !lPccBaixa .and. SE2->(E2_PIS+E2_COFINS+E2_CSLL) > 0
	If SE2->E2_PRETPIS == "2" .or. SE2->E2_PRETCOF == "2" .or. SE2->E2_PRETCSL == "2"
		SFQ->(DbSetOrder(2)) //-- FQ_FILIAL+FQ_ENTDES+FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES

		If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
			//-- Localiza Tit Retentor
			SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA

			If SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI)))

				//-- Verifica se o titulo e seus impostos estão Baixados
				If SE2->E2_VALOR == SE2->E2_SALDO
					If F050BxImp()

						If lHelp
							Help(" ",1,"F050BXPCC")
						EndIf

						lRet := .F.
					EndIf
				Else
					lRet := .F.
				EndIf
			Else
				lRet := .F.
			EndIf
		EndIf
	Else
		If F050BxImp()
			If lHelp
				Help(" ",1,"F050BXPCC")
			Endif
			lRet := .F.
		EndIf
	EndIf
EndIf

RestArea(aAreaSE2)
RestArea(aAreaSFQ)
RestArea(aArea)

Return lRet

/*
±±ºPrograma  ³FINA050   ºAutor  ³ Totvs     			  º Data ³  05/11/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Trata Exclusão , com valores atualizados de   				  º±±
±±º          ³ Titulo que Reteve os Impostos PCC de outro juntamente com  º±±
±±º          ³ os seus, e, agora, sofreu alteração na base de calculo     º±±
±±º          ³ Deleção do Titulo Retido                                   º±±
*/
Function F050DelRtd()
Local aArea 			:= GetArea()
Local aAreaSE2 		:= SE2->(GetArea())
Local aAreaSFQ 		:= SFQ->(GetArea())
Local aDados			:= {}
Local lRet				:= .T.
Local lHelpOld, lErroOld
Local dDataFim  		:= E2_EMISSAO

//Titulos Retidos
Local nRecRtd   		:= SE2->(RECNO())
Local nVlr_Rtd_Tot	:= 0
Local nVlr_Rtd   		:= 0
Local nSdo_Rtd   		:= 0
Local nPIS_Rtd 		:= 0
Local nCOF_Rtd			:= 0
Local nCSL_Rtd  		:= 0
//Titulo Retentor
Local nRecRtR   		:= SE2->(RECNO())
Local cFil_Rtr      	:= E2_FILIAL
Local cPre_Rtr      	:= E2_PREFIXO
Local cNum_Rtr     	:= E2_NUM
Local cPar_Rtr     	:= E2_PARCELA
Local cTip_Rtr     	:= E2_TIPO
Local cFor_Rtr     	:= E2_FORNECE
Local cLoj_Rtr      	:= E2_LOJA
Local nVlr_Rtr   		:= 0
Local nSdo_Rtr   		:= 0
Local nPIS_Rtr   		:= 0
Local nCOF_Rtr   		:= 0
Local nCSL_Rtr			:= 0
Local nVRPIS_Rtr 		:= 0
Local nVRCOF_Rtr 		:= 0
Local nVRCSL_Rtr		:= 0
Local cTitPai_Rtr   	:= E2_TITPAI
Local nVlMinImp 		:= GetNewPar("MV_VL10925",5000)
Local lCalcIssBx :=  IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"

dDataFim  := LastDay( ddatabase )

If Type("lMsHelpAuto") == "L"
	lHelpOld 	:= lMsHelpAuto
	lMsHelpAuto := .F. // Nao exibe erro
Else
	Private lMsHelpAuto := .F.
EndIf

If Type("lMsErroAuto") == "L"
	lErroOld := lMsErroAuto
Else
	Private lMsErroAuto := .F.
EndIf

SFQ->(DbSetOrder(2)) //-- FQ_FILIAL+FQ_ENTDES+FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES
If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
	nRecRtd   :=	SE2->(RECNO())
	cPREFORI  :=	SFQ->FQ_PREFORI
	nNUMORI   :=	SFQ->FQ_NUMORI
	nPARCORI  :=	SFQ->FQ_PARCORI
	cTIPOORI  :=	SFQ->FQ_TIPOORI
	nCFORI    :=	SFQ->FQ_CFORI
	nLOJAORI  :=	SFQ->FQ_LOJAORI
	//-- Localiza Tit Retentor
	SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
	If SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI)))
		SFQ->(dbSetOrder(1))
		SE2->E2_PREFIXO	:= cPREFORI
		SE2->E2_NUM			:=	nNUMORI
		SE2->E2_PARCELA	:=	nPARCORI
		SE2->E2_TIPO		:=	cTIPOORI
		SE2->E2_FORNECE	:=	nCFORI
		SE2->E2_LOJA		:=	nLOJAORI
		//-- Prepara campos para a função: F050TotMes
		M->E2_VENCREA 		:= SE2->E2_VENCREA
		M->E2_PIS 			:= SE2->E2_PIS
		M->E2_COFINS 		:= SE2->E2_COFINS
		M->E2_CSLL 			:= SE2->E2_CSLL
		M->E2_APLVLMN 		:=	SE2->E2_APLVLMN
		M->E2_TIPO  		:=	SE2->E2_TIPO
		M->E2_FORNECE 		:=	SE2->E2_FORNECE
		M->E2_LOJA 			:=	SE2->E2_LOJA
		M->E2_NATUREZ 		:=	SE2->E2_NATUREZ
		M->E2_VLCRUZ 		:=	SE2->E2_VLCRUZ
		M->E2_MOEDA 		:=	SE2->E2_MOEDA
		M->E2_EMISSAO 		:=	SE2->E2_EMISSAO
		M->E2_TXMOEDA		:=	SE2->E2_TXMOEDA
		///Totaliza Titulos do Fornecedor
		aDadosRet 			:= F050TotMes(M->E2_VENCREA,@nIndexSE2,@cIndexSE2)
		nVlr_Rtd_Tot 		:= aDadosRet[1]

		///Pesquisa Todos Titulos Retidos neste Titulos Retentor, para o fornecedor e periodo
		If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
			RecRtR   :=	SE2->(RECNO())
			While SFQ->(!Eof()) .and. SFQ->FQ_FILIAL == xFilial("SFQ") .And.;
			SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI) == cPREFORI+nNUMORI+nPARCORI+cTIPOORI+nCFORI+nLOJAORI
				cChaveSFQ := SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)
				//-- Localiza Titulos Retidos
				SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
				If 	SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)))
					If nRecRtd   			== 	SE2->(RECNO())
						nVlr_Rtd				+= 	SE2->E2_VALOR + SE2->E2_VRETPIS + SE2->E2_VRETCOF + SE2->E2_VRETCSL
					ElseIf 	(E2_PRETPIS == 	'2')
						nVlr_Rtd				+= 	SE2->E2_VALOR
						nPIS_Rtd   			+= 	SE2->E2_PIS
						nCOF_Rtd  			+= 	SE2->E2_COFINS
						nCSL_Rtd   			+= 	SE2->E2_CSLL
					EndIf
					If  ((cModRetPIS = "1") .And. (nVlr_Rtd_Tot 	<= 	nVlMinImp) .And.(SE2->E2_PRETPIS <> "1"))
						RecLock("SE2")
						Replace E2_PRETPIS 	With '1'
						Replace E2_PRETCOF 	With '1'
						Replace E2_PRETCSL 	With '1'
						MsUnlock()
						FKCOMMIT()
					EndIf
				EndIf
				SFQ->(dbSkip())
			EndDo
		EndIf
		//-- Salva dados do Titulo Retentor Antes de Excluí-lo
		SE2->(dbGoto(RecRtR))
		cFil_Rtr    := SE2->E2_FILIAL
		cPre_Rtr    := E2_PREFIXO
		cNum_Rtr    := E2_NUM
		cPar_Rtr    := E2_PARCELA
		cTip_Rtr    := E2_TIPO
		cFor_Rtr    := E2_FORNECE
		cLoj_Rtr    := E2_LOJA
		nVlr_Rtr   	:= SE2->E2_VALOR
		nSdo_Rtr   	:= SE2->E2_SALDO
		nPIS_Rtr   	:= SE2->E2_PIS
		nCOF_Rtr   	:= SE2->E2_COFINS
		nCSL_Rtr	:= SE2->E2_CSLL
		nVRPIS_Rtr 	:= SE2->E2_VRETPIS
		nVRCOF_Rtr 	:= SE2->E2_VRETCOF
		nVRCSL_Rtr	:= SE2->E2_VRETCSL
		cTitPai_Rtr := Rtrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))

		//-- Monta Array para ExecAuto do Titulo Retentor
		aEval(SE2->(DbStruct()), {|x| aAdd(aDados,{x[1],SE2->&(x[1]),NIL})})

		If !(SE2->e2_tipo $ MVABATIM+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA +"/"+"SES"+"/"+MV_CPNEG+"/"+"INA" .or. ;
		(SE2->e2_tipo $ MVPAGANT .and. GetMv("MV_IMPADT") != "S"))
			If SE2->E2_TIPO $ MVPAGANT
				If cPaisLoc == 'BRA' .And. !Empty(SE2->E2_BASEPIS)
					nBasePCC := SE2->E2_BASEPIS
				Else
					nBasePCC := nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
				Endif
			Else
				nBasePCC := (nVlr_Rtr + SE2->E2_IRRF + If(!lCalcIssBx,SE2->E2_ISS,0) + If(!lInssBx,SE2->E2_INSS,0)) +;
				(nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr)
			Endif
			SA2->(DbSeek(xFilial("SA2") + aDados[aScan(aDados,{|x|x[1]=="E2_FORNECE"}),2] + aDados[aScan(aDados,{|x|x[1]=="E2_LOJA"}),2]))
			SED->(DbSeek(xFilial("SED") + aDados[aScan(aDados,{|x|x[1]=="E2_NATUREZ"}),2]))
			If !SE2->E2_TIPO $ MVPAGANT

				aDados[aScan(aDados,{|x|x[1]=="E2_VALOR"}),2]  += (SE2->E2_IRRF + If(!lCalcIssBx,SE2->E2_ISS,0) + If(!lInssBx,SE2->E2_INSS,0))
				aDados[aScan(aDados,{|x|x[1]=="E2_SALDO"}),2]  += (SE2->E2_IRRF + If(!lCalcIssBx,SE2->E2_ISS,0) + If(!lInssBx,SE2->E2_INSS,0))
				aDados[aScan(aDados,{|x|x[1]=="E2_IRRF"}),2] := 0
				aDados[aScan(aDados,{|x|x[1]=="E2_ISS"}),2] := 0
				aDados[aScan(aDados,{|x|x[1]=="E2_INSS"}),2] := 0

				//PIS
				//³ se natureza pede calculo do PIS      ³
				If SED->ED_CALCPIS == "S"  .and. SA2->A2_RECPIS == "2"
					If ! GetNewPar("MV_RNDPIS",.F.)
						aDados[aScan(aDados,{|x|x[1]=="E2_PIS"}),2] := NoRound((nBasePCC * (SED->ED_PERCPIS / 100)),2)
					Else
						aDados[aScan(aDados,{|x|x[1]=="E2_PIS"}),2] := Round((nBasePCC * (SED->ED_PERCPIS / 100)),2)
					Endif
				Else
					aDados[aScan(aDados,{|x|x[1]=="E2_PIS"}),2] := 0
					nOldPis	 			:= 0
				EndIf
				// COFINS
				//³ se natureza pede calculo do COFINS	  ³
				If SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI == "2"
					If ! GetNewPar("MV_RNDCOF",.F.)
						aDados[aScan(aDados,{|x|x[1]=="E2_COFINS"}),2] := NoRound((nBasePCC * (SED->ED_PERCCOF / 100)),2)
					Else
						aDados[aScan(aDados,{|x|x[1]=="E2_COFINS"}),2] := Round((nBasePCC * (SED->ED_PERCCOF / 100)),2)
					Endif
				Else
					aDados[aScan(aDados,{|x|x[1]=="E2_COFINS"}),2] := 0
					nOldCofins := 0
				EndIf
				// CSLL
				//³ se natureza pede calculo do CSLL ³
				If SED->ED_CALCCSL == "S"  .and. SA2->A2_RECCSLL == "2"
					If ! GetNewPar("MV_RNDCSL",.F.)
						aDados[aScan(aDados,{|x|x[1]=="E2_CSLL"}),2] := NoRound((nBasePCC * (SED->ED_PERCCSL / 100)),2)
					Else
						aDados[aScan(aDados,{|x|x[1]=="E2_CSLL"}),2] := Round((nBasePCC * (SED->ED_PERCCSL / 100)),2)
					Endif
				Else
					aDados[aScan(aDados,{|x|x[1]=="E2_CSLL"}),2] := 0
					nOldCsll	  			:= 0
				Endif
			EndIf
		EndIf
		//-- Calculo pelo sistema qdo o Valor Total dos titulos do fornecedor para o periodo menor que o valor minimo
		If	((cModRetPIS = "1") .And. (nVlr_Rtd_Tot 	<= 	nVlMinImp))
			aDados[aScan(aDados,{|x|x[1]=="E2_VALOR"}),2]  := nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
			aDados[aScan(aDados,{|x|x[1]=="E2_SALDO"}),2]  := nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
			aDados[aScan(aDados,{|x|x[1]=="E2_VRETPIS"}),2] := 0
			aDados[aScan(aDados,{|x|x[1]=="E2_VRETCOF"}),2] := 0
			aDados[aScan(aDados,{|x|x[1]=="E2_VRETCSL"}),2] := 0
			aDados[aScan(aDados,{|x|x[1]=="E2_PRETPIS"}),2] := "1"
			aDados[aScan(aDados,{|x|x[1]=="E2_PRETCOF"}),2] := "1"
			aDados[aScan(aDados,{|x|x[1]=="E2_PRETCSL"}),2] := "1"
		EndIf
		//³Exclui o titulo no contas a pagar³
		MSExecAuto({|x, y, z| FINA050(x, y, z)}, aClone(aDados),5,5)

		If lMsErroAuto
			Help(" ",1,"NOATUARET"     ,, STR0169  + cPre_Rtr + cNum_Rtr      , 1,0)  //"Titulo Retentor - Não Atualizado: "
			lRet := .F.
		Else
			//-- Ajusta Titulo Retido Alterado
			SE2->(dbGoto(nRecRtd))
			If  ((nVlr_Rtd_Tot > nVlMinImp)  .And. (SE2->E2_PRETPIS = '1'))
				If E2_VENCREA == aDados[aScan(aDados,{|x|x[1]=="E2_VENCREA"}),2]
					RecLock("SE2")
					Replace E2_PRETPIS 	With ' '
					Replace E2_PRETCOF 	With ' '
					Replace E2_PRETCSL 	With ' '
					MsUnlock()
					FKCOMMIT()
				EndIf
			EndIf
			//³Gera o titulo no contas a pagar³
			lMsErroAuto := .F.

			MSExecAuto(	{ |a,b,c| FINA050(a,b,c) },aDados,,3)
			If lMsErroAuto
				Help(" ",1,"NOATUARET"     ,, STR0169  + cPre_Rtr + cNum_Rtr      , 1,0)  //"Titulo Retentor - Não Atualizado: "
				lRet := .F.
			Else
				//-- Ajusta Titulo Retentor
				RecLock("SE2")
				Replace E2_VALOR 			With nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
				Replace E2_SALDO   		With nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr

				If nVlr_Rtd_Tot > nVlMinImp
					Replace E2_VALOR 		With E2_VALOR - (nPIS_Rtr + nCOF_Rtr + nCSL_Rtr + nPIS_Rtd + nCOF_Rtd + nCSL_Rtd)
					Replace E2_SALDO 		With E2_SALDO - (nPIS_Rtr + nCOF_Rtr + nCSL_Rtr + nPIS_Rtd + nCOF_Rtd + nCSL_Rtd)
					Replace E2_VRETPIS 	With nPIS_Rtr + nPIS_Rtd
					Replace E2_VRETCOF 	With nCOF_Rtr + nCOF_Rtd
					Replace E2_VRETCSL 	With nCSL_Rtr + nCSL_Rtd
					Replace E2_PIS 		With nPIS_Rtr
					Replace E2_COFINS 	With nCOF_Rtr
					Replace E2_CSLL 		With nCSL_Rtr
				Else
					Replace E2_VRETPIS 	With 0
					Replace E2_VRETCOF 	With 0
					Replace E2_VRETCSL 	With 0
					Replace E2_PRETPIS 	With '1'
					Replace E2_PRETCOF 	With '1'
					Replace E2_PRETCSL 	With '1'
					Replace E2_PIS 		With nPIS_Rtr
					Replace E2_COFINS 	With nCOF_Rtr
					Replace E2_CSLL 		With nCSL_Rtr
				EndIf
				Replace E2_VLCRUZ 	With IF(SE2->E2_MOEDA == 1,SE2->E2_VALOR,Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,MsDecimais(1)+1,SE2->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1)))
				MsUnlock()
				FKCOMMIT()
				If nVlr_Rtd_Tot > nVlMinImp
					//³ Ajusta tambem os registros de impostos-Pcc ³
					dbSelectArea("SE2")
					SE2->(DbSetOrder(1))
					dbSeek(cFil_Rtr+cPre_Rtr+cNum_Rtr+cPar_Rtr)
					While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM == ;
					cFil_Rtr+cPre_Rtr+cNum_Rtr

						If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_PISNAT"))  .And. ;
						AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
							RecLock("SE2")
							Replace E2_VALOR 	With nPIS_Rtr 		+ 	nPIS_Rtd
							Replace E2_SALDO 	With nPIS_Rtr 		+ 	nPIS_Rtd
							Replace E2_TITPAI With cTitPai_Rtr
							Replace E2_ORIGEM	With "FINA050"
							MsUnlock()
							FKCOMMIT()
						EndIf
						If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_COFINS"))  .And. ;
						AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
							RecLock("SE2")
							Replace E2_VALOR 	With nCOF_Rtr 		+ 	nCOF_Rtd
							Replace E2_SALDO 	With nCOF_Rtr 		+ 	nCOF_Rtd
							Replace E2_TITPAI With cTitPai_Rtr
							Replace E2_ORIGEM	With "FINA050"
							MsUnlock()
							FKCOMMIT()
						EndIf
						If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_CSLL"))  .And. ;
						AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
							RecLock("SE2")
							Replace E2_VALOR 	With nCSL_Rtr 		+ 	nCSL_Rtd
							Replace E2_SALDO 	With nCSL_Rtr 		+ 	nCSL_Rtd
							Replace E2_TITPAI With cTitPai_Rtr
							Replace E2_ORIGEM	With "FINA050"
							MsUnlock()
							FKCOMMIT()
						EndIf
						dbSkip()
					Enddo
				Else
					//³ Exclui registros indevidos de impostos-Pcc ³
					dbSelectArea("SE2")
					SE2->(DbSetOrder(1))
					dbSeek(cFil_Rtr+cPre_Rtr+cNum_Rtr+cPar_Rtr)
					While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM == ;
					cFil_Rtr+cPre_Rtr+cNum_Rtr
						If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_PISNAT"))  .And. ;
						AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0

							FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
							RecLock("SE2")
							dbDelete()
							MsUnlock()
							FKCOMMIT()
						EndIf
						If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_COFINS"))  .And. ;
						AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0

							FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
							RecLock("SE2")
							dbDelete()
							MsUnlock()
							FKCOMMIT()
						EndIf
						If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_CSLL"))  .And. ;
						AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0

							FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
							RecLock("SE2")
							dbDelete()
							MsUnlock()
							FKCOMMIT()
						EndIf
						dbSkip()
					Enddo
				EndIf

				/*	   If (nVlr_Rtd_Tot 	<= 	nVlMinImp)
				F050DelPCC()
				EndIf  */
			EndIf
		EndIf
	Else
		Help(" ",1,"NOATUARET"     ,, STR0169  + cPre_Rtr + cNum_Rtr      , 1,0)  //"Titulo Retentor - Não Atualizado: "
		lRet := .F.
	EndIf
Else
	Help(" ",1,"NOATUARET"     ,, STR0169  + cPre_Rtr + cNum_Rtr      , 1,0)  //"Titulo Retentor - Não Atualizado: "
	lRet := .F.
EndIf

If ValType(lHelpOld ) == "L"
	lMsHelpAuto := lHelpOld
EndIf
If ValType(lErroOld) == "L"
	lMsErroAuto	:= lErroOld
EndIf

RestArea(aAreaSE2)
RestArea(aAreaSFQ)
RestArea(aArea)

Return lRet

/*
±±ºPrograma  ³FINA050   ºAutor  ³ Totvs              º Data ³  05/11/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Trata Ajuste na Alteração de Titulo teve seus Impostos PCC º±±
±±º          ³ retidos em outro, e, agora, sofreu alteração na base de    º±±
±±º          ³ calculo. 																  º±±
±±º          ³ Alteração a partir do Titulo Retido								  º±±
*/
Function F050AltRtd()
Local aArea 			:= GetArea()
Local aAreaSE2 			:= SE2->(GetArea())
Local aAreaSFQ 			:= SFQ->(GetArea())
Local aDados			:= {}
Local lRet				:= .T.
Local lHelpOld, lErroOld
Local dDataFim  		:= E2_EMISSAO
Local dDataIni  		:= E2_EMISSAO

//Titulos Retidos
Local nRecRtd   		:= SE2->(RECNO())
Local cFil_Rtd      	:= E2_FILIAL
Local cPre_Rtd      	:= E2_PREFIXO
Local cNum_Rtd      	:= E2_NUM
Local cPar_Rtd     	:= E2_PARCELA
Local nVlr_Rtd_Tot	:= 0
Local nVlr_Rtd   		:= 0
Local nSdo_Rtd   		:= 0
Local nPIS_Rtd 		:= 0
Local nCOF_Rtd			:= 0
Local nCSL_Rtd  		:= 0
//Titulo Retentor
Local nRecRtR   		:= SE2->(RECNO())
Local cFil_Rtr      	:= E2_FILIAL
Local cPre_Rtr      	:= E2_PREFIXO
Local cNum_Rtr      	:= E2_NUM
Local cPar_Rtr   	  	:= E2_PARCELA
Local nVlr_Rtr_Tot	:= 0
Local cTip_Rtr     		:= E2_TIPO
Local cFor_Rtr     		:= E2_FORNECE
Local cLoj_Rtr      	:= E2_LOJA
Local nVlr_Rtr   		:= 0
Local nSdo_Rtr   		:= 0
Local nPIS_Rtr   		:= 0
Local nCOF_Rtr   		:= 0
Local nCSL_Rtr			:= 0
Local nVRPIS_Rtr 		:= 0
Local nVRCOF_Rtr 		:= 0
Local nVRCSL_Rtr		:= 0
Local cTitPai_Rtr   	:= E2_TITPAI
Local nVlMinImp 		:= GetNewPar("MV_VL10925",5000)
Local lCalcIssBx :=  IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"

dDataFim  := LastDay( SE2->E2_VENCREA  )
dDataIni  := FirstDay( SE2->E2_VENCREA  )

If Type("lMsHelpAuto") == "L"
	lHelpOld 	:= lMsHelpAuto
	lMsHelpAuto := .F. // Nao exibe erro
Else
	Private lMsHelpAuto := .F.
EndIf

If Type("lMsErroAuto") == "L"
	lErroOld := lMsErroAuto
Else
	Private lMsErroAuto := .F.
EndIf
//-- Prepara campos para a função: F050TotMes
M->E2_VENCREA 		:= SE2->E2_VENCREA
M->E2_PIS 			:= SE2->E2_PIS
M->E2_COFINS 		:= SE2->E2_COFINS
M->E2_CSLL 			:= SE2->E2_CSLL
M->E2_APLVLMN 		:=	SE2->E2_APLVLMN
M->E2_TIPO  		:=	SE2->E2_TIPO
M->E2_FORNECE 		:=	SE2->E2_FORNECE
M->E2_LOJA 			:=	SE2->E2_LOJA
M->E2_NATUREZ 		:=	SE2->E2_NATUREZ
M->E2_VLCRUZ 		:=	SE2->E2_VLCRUZ
M->E2_MOEDA 		:=	SE2->E2_MOEDA
M->E2_EMISSAO 		:=	SE2->E2_EMISSAO
M->E2_TXMOEDA		:=	SE2->E2_TXMOEDA
///Totaliza Titulos do Fornecedor Data de referencia é a do retido
aDadosRet 			:= F050TotMes(M->E2_VENCREA,@nIndexSE2,@cIndexSE2)
nVlr_Rtd_Tot 		:= aDadosRet[1]

SFQ->(DbSetOrder(2)) //-- FQ_FILIAL+FQ_ENTDES+FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES
If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
	nRecRtd   :=	SE2->(RECNO())
	cPREFORI  :=	SFQ->FQ_PREFORI
	nNUMORI   :=	SFQ->FQ_NUMORI
	nPARCORI  :=	SFQ->FQ_PARCORI
	cTIPOORI  :=	SFQ->FQ_TIPOORI
	nCFORI    :=	SFQ->FQ_CFORI
	nLOJAORI  :=	SFQ->FQ_LOJAORI
	//-- Localiza Tit Retentor
	SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
	If SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI)))
		SFQ->(dbSetOrder(1))
		SE2->E2_PREFIXO	:= cPREFORI
		SE2->E2_NUM			:=	nNUMORI
		SE2->E2_PARCELA	:=	nPARCORI
		SE2->E2_TIPO		:=	cTIPOORI
		SE2->E2_FORNECE	:=	nCFORI
		SE2->E2_LOJA		:=	nLOJAORI
		//-- Prepara campos para a função: F050TotMes
		M->E2_VENCREA 		:= SE2->E2_VENCREA
		M->E2_PIS 			:= SE2->E2_PIS
		M->E2_COFINS 		:= SE2->E2_COFINS
		M->E2_CSLL 			:= SE2->E2_CSLL
		M->E2_APLVLMN 		:=	SE2->E2_APLVLMN
		M->E2_TIPO  		:=	SE2->E2_TIPO
		M->E2_FORNECE 		:=	SE2->E2_FORNECE
		M->E2_LOJA 			:=	SE2->E2_LOJA
		M->E2_NATUREZ 		:=	SE2->E2_NATUREZ
		M->E2_VLCRUZ 		:=	SE2->E2_VLCRUZ
		M->E2_MOEDA 		:=	SE2->E2_MOEDA
		M->E2_EMISSAO 		:=	SE2->E2_EMISSAO
		M->E2_TXMOEDA		:=	SE2->E2_TXMOEDA
		///Totaliza Titulos do Fornecedor Data de referencia é a do retentor
		aDadosRet 			:= F050TotMes(M->E2_VENCREA,@nIndexSE2,@cIndexSE2)
		nVlr_Rtr_Tot 		:= aDadosRet[1]

		///Pesquisa Todos Titulos Retidos neste Titulos Retentor, para o fornecedor e periodo
		If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
			RecRtR   :=	SE2->(RECNO())
			While SFQ->(!Eof()) .and. SFQ->FQ_FILIAL == xFilial("SFQ") .And.;
			SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI) == cPREFORI+nNUMORI+nPARCORI+cTIPOORI+nCFORI+nLOJAORI
				cChaveSFQ := SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)
				//-- Localiza Titulos Retidos
				SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
				If 	SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)))
					If nRecRtd   			== 	SE2->(RECNO())
						cFil_Rtd    		:= 	SE2->E2_FILIAL
						cPre_Rtd    		:= 	SE2->E2_PREFIXO
						cNum_Rtd    		:= 	SE2->E2_NUM
						cPar_Rtd    		:= 	SE2->E2_PARCELA
						nVlr_Rtd				+= 	SE2->E2_VALOR + SE2->E2_VRETPIS + SE2->E2_VRETCOF + SE2->E2_VRETCSL
						nPIS_Rtd   			+= 	SE2->E2_PIS
						nCOF_Rtd  			+= 	SE2->E2_COFINS
						nCSL_Rtd   			+= 	SE2->E2_CSLL
					ElseIf (SE2->E2_PRETPIS 	== 	'2')
						nVlr_Rtd				+= 	SE2->E2_VALOR
						nPIS_Rtd   			+= 	SE2->E2_PIS
						nCOF_Rtd  			+= 	SE2->E2_COFINS
						nCSL_Rtd   			+= 	SE2->E2_CSLL
					EndIf

					If  	nVlr_Rtr_Tot 	<= 	nVlMinImp
						//Atualiza Situação de Retenção do titulo Retido
						RecLock("SE2")
						Replace E2_PRETPIS 	With '1'
						Replace E2_PRETCOF 	With '1'
						Replace E2_PRETCSL 	With '1'
						MsUnlock()
						FKCOMMIT()
						//Exclui Relacionamento do titulo Retido com seu Retentor
						RecLock("SFQ")
						dbDelete()
						MsUnlock()
						FKCOMMIT()
					EndIf
					If nVlr_Rtr_Tot > nVlMinImp
						If	nRecRtd == SE2->(RECNO())
							//Atualiza Situação de Retenção do titulo Retido
							RecLock("SE2")
							Replace E2_VALOR 		With SE2->(E2_VALOR + E2_VRETPIS + 	E2_VRETCOF + E2_VRETCSL)
							Replace E2_SALDO 		With SE2->E2_VALOR
							Replace E2_PRETPIS 	With '2'
							Replace E2_PRETCOF 	With '2'
							Replace E2_PRETCSL 	With '2'
							Replace E2_VRETPIS 	With  0
							Replace E2_VRETCOF 	With  0
							Replace E2_VRETCSL 	With  0
							MsUnlock()
							FKCOMMIT()
						Endif
					EndIf
				EndIf
				SFQ->(dbSkip())
			EndDo
		EndIf
		//³ Exclui registros indevidos de impostos-Pcc ³
		dbSelectArea("SE2")
		SE2->(DbSetOrder(1))
		dbSeek(cFil_Rtd+cPre_Rtd+cNum_Rtd+cPar_Rtd)
		While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM == ;
		cFil_Rtd+cPre_Rtd+cNum_Rtd

			If AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_PISNAT"))  .And. ;
			AllTrim(E2_TIPO) = AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0

				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				RecLock("SE2")
				dbDelete()
				MsUnlock()
				FKCOMMIT()
			EndIf
			If AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_COFINS"))  .And. ;
			AllTrim(E2_TIPO) = AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0

				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				RecLock("SE2")
				dbDelete()
				MsUnlock()
				FKCOMMIT()
			EndIf
			If AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_CSLL"))  .And. ;
			AllTrim(E2_TIPO) = AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0

				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				RecLock("SE2")
				dbDelete()
				MsUnlock()
				FKCOMMIT()
			EndIf
			dbSkip()
		Enddo

		//-- Salva dados do Titulo Retentor Antes de Excluí-lo
		SE2->(dbGoto(RecRtR))
		cFil_Rtr    	:= SE2->E2_FILIAL
		cPre_Rtr    	:= SE2->E2_PREFIXO
		cNum_Rtr    	:= SE2->E2_NUM
		cPar_Rtr    	:= SE2->E2_PARCELA
		cTip_Rtr    	:= SE2->E2_TIPO
		cFor_Rtr    	:= SE2->E2_FORNECE
		cLoj_Rtr    	:= SE2->E2_LOJA
		nVlr_Rtr   		:= SE2->E2_VALOR
		nSdo_Rtr   		:= SE2->E2_SALDO
		nPIS_Rtr   		:= SE2->E2_PIS
		nCOF_Rtr   		:= SE2->E2_COFINS
		nCSL_Rtr		:= SE2->E2_CSLL
		nVRPIS_Rtr 		:= SE2->E2_VRETPIS
		nVRCOF_Rtr 		:= SE2->E2_VRETCOF
		nVRCSL_Rtr		:= SE2->E2_VRETCSL
		cTitPai_Rtr 	:= Rtrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))

		//-- Monta Array para ExecAuto do Titulo Retentor
		aEval(SE2->(DbStruct()), {|x| aAdd(aDados,{x[1],SE2->&(x[1]),NIL})})

		If !(SE2->e2_tipo $ MVABATIM+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA +"/"+"SES"+"/"+MV_CPNEG+"/"+"INA" .or. ;
		(SE2->e2_tipo $ MVPAGANT .and. GetMv("MV_IMPADT") != "S"))

			If SE2->E2_TIPO $ MVPAGANT
				If cPaisLoc == 'BRA' .And. !Empty(SE2->E2_BASEPIS)
					nBasePCC := SE2->E2_BASEPIS
				Else
					nBasePCC := nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
				Endif
			Else
				nBasePCC := (nVlr_Rtr + SE2->E2_IRRF + If(!lCalcIssBx,SE2->E2_ISS,0) + If(!lInssbX,SE2->E2_INSS,0)) + (nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr)
			Endif
			SA2->(DbSeek(xFilial("SA2") + aDados[aScan(aDados,{|x|x[1]=="E2_FORNECE"}),2] + aDados[aScan(aDados,{|x|x[1]=="E2_LOJA"}),2]))
			SED->(DbSeek(xFilial("SED") + aDados[aScan(aDados,{|x|x[1]=="E2_NATUREZ"}),2]))
			If !SE2->E2_TIPO $ MVPAGANT
				//PIS
				//³ se natureza pede calculo do PIS      ³
				If SED->ED_CALCPIS == "S"  .and. SA2->A2_RECPIS == "2"
					If ! GetNewPar("MV_RNDPIS",.F.)
						aDados[aScan(aDados,{|x|x[1]=="E2_PIS"}),2] := NoRound((nBasePCC * (SED->ED_PERCPIS / 100)),2)
					Else
						aDados[aScan(aDados,{|x|x[1]=="E2_PIS"}),2] := Round((nBasePCC * (SED->ED_PERCPIS / 100)),2)
					Endif
				Else
					aDados[aScan(aDados,{|x|x[1]=="E2_PIS"}),2] := 0
					nOldPis	 			:= 0
				EndIf
				// COFINS
				//³ se natureza pede calculo do COFINS	  ³
				If SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI == "2"
					If ! GetNewPar("MV_RNDCOF",.F.)
						aDados[aScan(aDados,{|x|x[1]=="E2_COFINS"}),2] := NoRound((nBasePCC * (SED->ED_PERCCOF / 100)),2)
					Else
						aDados[aScan(aDados,{|x|x[1]=="E2_COFINS"}),2] := Round((nBasePCC * (SED->ED_PERCCOF / 100)),2)
					Endif
				Else
					aDados[aScan(aDados,{|x|x[1]=="E2_COFINS"}),2] := 0
					nOldCofins	 		:= 0
				EndIf
				// CSLL
				//³ se natureza pede calculo do CSLL ³
				If SED->ED_CALCCSL == "S"  .and. SA2->A2_RECCSLL == "2"
					If ! GetNewPar("MV_RNDCSL",.F.)
						aDados[aScan(aDados,{|x|x[1]=="E2_CSLL"}),2] := NoRound((nBasePCC * (SED->ED_PERCCSL / 100)),2)
					Else
						aDados[aScan(aDados,{|x|x[1]=="E2_CSLL"}),2] := Round((nBasePCC * (SED->ED_PERCCSL / 100)),2)
					Endif
				Else
					aDados[aScan(aDados,{|x|x[1]=="E2_CSLL"}),2] := 0
					nOldCsll	  			:= 0
				Endif
			EndIf
		EndIf
		//-- Calculo pelo sistema qdo o Valor Total dos titulos do fornecedor para o periodo menor que o valor minimo
		If	((cModRetPIS = "1") .And. (nVlr_Rtr_Tot 	<= 	nVlMinImp))
			aDados[aScan(aDados,{|x|x[1]=="E2_VALOR"}),2]  := nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
			aDados[aScan(aDados,{|x|x[1]=="E2_SALDO"}),2]  := nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
			aDados[aScan(aDados,{|x|x[1]=="E2_VRETPIS"}),2] := 0
			aDados[aScan(aDados,{|x|x[1]=="E2_VRETCOF"}),2] := 0
			aDados[aScan(aDados,{|x|x[1]=="E2_VRETCSL"}),2] := 0
			aDados[aScan(aDados,{|x|x[1]=="E2_PRETPIS"}),2] := "1"
			aDados[aScan(aDados,{|x|x[1]=="E2_PRETCOF"}),2] := "1"
			aDados[aScan(aDados,{|x|x[1]=="E2_PRETCSL"}),2] := "1"
		EndIf
		//-- Ajusta Titulo Retido Alterado
		SE2->(dbGoto(nRecRtd))
		If  ((nVlr_Rtr_Tot > nVlMinImp)  .And. (SE2->E2_PRETPIS = '1'))
			If E2_VENCREA == aDados[aScan(aDados,{|x|x[1]=="E2_VENCREA"}),2]
				RecLock("SE2")
				Replace E2_PRETPIS 	With '2'
				Replace E2_PRETCOF 	With '2'
				Replace E2_PRETCSL 	With '2'
				MsUnlock()
				FKCOMMIT()
			EndIf
		EndIf
		//³Gera o titulo no contas a pagar³

		//-- Ajusta Titulo Retentor
		SE2->(dbGoto(RecRtR))
		RecLock("SE2")
		Replace E2_VALOR 			With nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
		Replace E2_SALDO   		With nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
		If nVlr_Rtr_Tot > nVlMinImp
			Replace E2_VALOR 		With E2_VALOR - (nPIS_Rtr + nCOF_Rtr + nCSL_Rtr + nPIS_Rtd + nCOF_Rtd + nCSL_Rtd)
			Replace E2_SALDO 		With E2_SALDO - (nPIS_Rtr + nCOF_Rtr + nCSL_Rtr + nPIS_Rtd + nCOF_Rtd + nCSL_Rtd)
			Replace E2_VRETPIS 	With nPIS_Rtr + nPIS_Rtd
			Replace E2_VRETCOF 	With nCOF_Rtr + nCOF_Rtd
			Replace E2_VRETCSL 	With nCSL_Rtr + nCSL_Rtd
			Replace E2_PIS 		With nPIS_Rtr
			Replace E2_COFINS 	With nCOF_Rtr
			Replace E2_CSLL 		With nCSL_Rtr
		Else
			Replace E2_VRETPIS 	With 0
			Replace E2_VRETCOF 	With 0
			Replace E2_VRETCSL 	With 0
			Replace E2_PRETPIS 	With '1'
			Replace E2_PRETCOF 	With '1'
			Replace E2_PRETCSL 	With '1'
			Replace E2_PIS 		With nPIS_Rtr
			Replace E2_COFINS 	With nCOF_Rtr
			Replace E2_CSLL 		With nCSL_Rtr
		EndIf
		MsUnlock()
		FKCOMMIT()
		If nVlr_Rtr_Tot > nVlMinImp
			//³ Ajusta tambem os registros de impostos-Pcc ³
			dbSelectArea("SE2")
			SE2->(DbSetOrder(1))
			dbSeek(cFil_Rtr+cPre_Rtr+cNum_Rtr+cPar_Rtr)
			While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM == ;
			cFil_Rtr+cPre_Rtr+cNum_Rtr
				If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_PISNAT"))  .And. ;
				AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
					RecLock("SE2")
					Replace E2_VALOR 	With nPIS_Rtr 		+ 	nPIS_Rtd
					Replace E2_SALDO 	With nPIS_Rtr 		+ 	nPIS_Rtd
					Replace E2_TITPAI   	With cTitPai_Rtr
					Replace E2_ORIGEM		With "FINA050"
					MsUnlock()
					FKCOMMIT()
				EndIf
				If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_COFINS"))  .And. ;
				AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
					RecLock("SE2")
					Replace E2_VALOR 	With nCOF_Rtr 		+ 	nCOF_Rtd
					Replace E2_SALDO 	With nCOF_Rtr 		+ 	nCOF_Rtd
					Replace E2_TITPAI   	With cTitPai_Rtr
					Replace E2_ORIGEM		With "FINA050"
					MsUnlock()
					FKCOMMIT()
				EndIf
				If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_CSLL"))  .And. ;
				AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
					RecLock("SE2")
					Replace E2_VALOR 	With nCSL_Rtr 		+ 	nCSL_Rtd
					Replace E2_SALDO 	With nCSL_Rtr 		+ 	nCSL_Rtd
					Replace E2_TITPAI   	With cTitPai_Rtr
					Replace E2_ORIGEM		With "FINA050"
					MsUnlock()
					FKCOMMIT()
				EndIf
				dbSkip()
			Enddo
		Else
			//³ Exclui registros indevidos de impostos-Pcc ³
			dbSelectArea("SE2")
			SE2->(DbSetOrder(1))
			dbSeek(cFil_Rtr+cPre_Rtr+cNum_Rtr+cPar_Rtr)
			While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM == ;
			cFil_Rtr+cPre_Rtr+cNum_Rtr
				If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_PISNAT"))  .And. ;
				AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO == SE2->E2_VALOR

					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					RecLock("SE2")
					dbDelete()
					MsUnlock()
					FKCOMMIT()
				EndIf
				If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_COFINS"))  .And. ;
				AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO == SE2->E2_VALOR

					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					RecLock("SE2")
					dbDelete()
					MsUnlock()
					FKCOMMIT()
				EndIf
				If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_CSLL"))  .And. ;
				AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO == SE2->E2_VALOR

					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					RecLock("SE2")
					dbDelete()
					MsUnlock()
					FKCOMMIT()
				EndIf
				dbSkip()
			Enddo
		EndIf


	Else
		Help(" ",1,"NOATUARET"     ,, STR0169  + cPre_Rtr + cNum_Rtr      , 1,0)  //"Titulo Retentor - Não Atualizado: "
		lRet := .F.
	EndIf
Else
	Help(" ",1,"NOATUARET"     ,, STR0169  + cPre_Rtr + cNum_Rtr      , 1,0)  //"Titulo Retentor - Não Atualizado: "
	lRet := .F.
EndIf

If ValType(lHelpOld ) == "L"
	lMsHelpAuto := lHelpOld
EndIf
If ValType(lErroOld) == "L"
	lMsErroAuto	:= lErroOld
EndIf

RestArea(aAreaSE2)
RestArea(aAreaSFQ)
RestArea(aArea)
Return lRet

/*
±±ºPrograma  ³FINA050   ºAutor  ³ Totvs     			  º Data ³  05/11/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Trata Ajuste na Alteração de Titulo que Reteve os          º±±
±±º          ³ Impostos PCC juntamente com os seus, e, agora,             º±±
±±º          ³ sofreu alteração na base de calculo     						  º±±
±±º          ³ Alteração a partir do Titulo Retentor                      º±±
*/
Function F050GrvRtr()
Local aArea 			:= GetArea()
Local aAreaSE2 		:= SE2->(GetArea())
Local aAreaSFQ 		:= SFQ->(GetArea())
Local aDados			:= {}
Local lRet				:= .T.
Local lHelpOld, lErroOld
Local dDataFim  		:= E2_EMISSAO

//Titulo Retentor
Local nRecRtR   		:= SE2->(RECNO())
Local cFil_Rtr      	:= E2_FILIAL
Local cPre_Rtr      	:= E2_PREFIXO
Local cNum_Rtr     	:= E2_NUM
Local cPar_Rtr     	:= E2_PARCELA
Local cTip_Rtr     	:= E2_TIPO
Local cFor_Rtr     	:= E2_FORNECE
Local cLoj_Rtr      	:= E2_LOJA
Local nVlr_Rtr   		:= 0
Local nSdo_Rtr   		:= 0
Local nPIS_Rtr   		:= 0
Local nCOF_Rtr   		:= 0
Local nCSL_Rtr			:= 0
Local nVRPIS_Rtr 		:= 0
Local nVRCOF_Rtr 		:= 0
Local nVRCSL_Rtr		:= 0
Local cTitPai_Rtr   	:= E2_TITPAI
Local nVlMinImp 		:= GetNewPar("MV_VL10925",5000)

Local nPosForn			:= 0
Local nPosLoja			:= 0
Local nPosNat			:= 0
Local nPosPis			:= 0
Local nPosCsll			:= 0
Local nPosCof		:= 0

Local lCalcIssBx :=  IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"

dDataFim  := LastDay( ddatabase )

If Type("lMsHelpAuto") == "L"
	lHelpOld 	:= lMsHelpAuto
	lMsHelpAuto := .F. // Nao exibe erro
Else
	Private lMsHelpAuto := .F.
EndIf

If Type("lMsErroAuto") == "L"
	lErroOld := lMsErroAuto
Else
	Private lMsErroAuto := .F.
EndIf

//-- Salva dados do Titulo Retentor Antes de Excluí-lo
cFil_Rtr    	:= SE2->E2_FILIAL
cPre_Rtr    	:= SE2->E2_PREFIXO
cNum_Rtr    	:= SE2->E2_NUM
cPar_Rtr    	:= SE2->E2_PARCELA
cTip_Rtr    	:= SE2->E2_TIPO
cFor_Rtr    	:= SE2->E2_FORNECE
cLoj_Rtr    	:= SE2->E2_LOJA
nVlr_Rtr   		:= SE2->E2_VALOR
nSdo_Rtr   		:= SE2->E2_SALDO
nPIS_Rtr   		:= SE2->E2_PIS
nCOF_Rtr   		:= SE2->E2_COFINS
nCSL_Rtr		:= SE2->E2_CSLL
nVRPIS_Rtr 		:= SE2->E2_VRETPIS
nVRCOF_Rtr 		:= SE2->E2_VRETCOF
nVRCSL_Rtr		:= SE2->E2_VRETCSL
cTitPai_Rtr 	:= Rtrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))

M->E2_VENCREA 		:= SE2->E2_VENCREA
M->E2_PIS 			:= SE2->E2_PIS
M->E2_COFINS 		:= SE2->E2_COFINS
M->E2_CSLL 			:= SE2->E2_CSLL
M->E2_APLVLMN 		:=	SE2->E2_APLVLMN
M->E2_TIPO  		:=	SE2->E2_TIPO
M->E2_FORNECE 		:=	SE2->E2_FORNECE
M->E2_LOJA 			:=	SE2->E2_LOJA
M->E2_NATUREZ 		:=	SE2->E2_NATUREZ
M->E2_VLCRUZ 		:=	SE2->E2_VLCRUZ
M->E2_MOEDA 		:=	SE2->E2_MOEDA
M->E2_EMISSAO 		:=	SE2->E2_EMISSAO
M->E2_TXMOEDA		:=	SE2->E2_TXMOEDA

//-- Monta Array para ExecAuto do Titulo Retentor
aEval(SE2->(DbStruct()), {|x| aAdd(aDados,{x[1],SE2->&(x[1]),NIL})})

nPosForn := aScan(aDados,{|x| x[1]== "E2_FORNECE"})
nPosLoja := aScan(aDados,{|x| x[1]== "E2_LOJA"})
nPosNat	 := aScan(aDados,{|x| x[1]== "E2_NATUREZ"})
nPosPis	 := aScan(aDados,{|x| x[1]== "E2_PIS"})
nPosCsll := aScan(aDados,{|x| x[1]== "E2_CSLL"})
nPosCof	 := aScan(aDados,{|x| x[1]== "E2_COFINS"})

If !(SE2->e2_tipo $ MVABATIM+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA +"/"+"SES"+"/"+MV_CPNEG+"/"+"INA" .or. ;
(SE2->e2_tipo $ MVPAGANT .and. GetMv("MV_IMPADT") != "S"))

	If SE2->E2_TIPO $ MVPAGANT
		If cPaisLoc == 'BRA' .And. !Empty(SE2->E2_BASEPIS)
			nBasePCC := SE2->E2_BASEPIS
		Else
			nBasePCC := nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
		Endif
	Else
		nBasePCC := (nVlr_Rtr + SE2->E2_IRRF + If(!lCalcIssBx,SE2->E2_ISS,0) + If(!lInssbX,SE2->E2_INSS,0)) + (nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr)
	Endif
	SA2->(dbSeek(xFilial("SA2") + aDados[nPosForn,2] + aDados[nPosLoja,2]))
	SED->(dbSeek(xFilial("SED") + aDados[nPosNat,2]))
	If !SE2->E2_TIPO $ MVPAGANT
		//PIS
		//³ se natureza pede calculo do PIS      ³
		If SED->ED_CALCPIS == "S"  .and. SA2->A2_RECPIS == "2"
			If ! GetNewPar("MV_RNDPIS",.F.)
				aDados[nPosPis,2] 	:= NoRound((nBasePCC * (SED->ED_PERCPIS / 100)),2)
			Else
				aDados[nPosPis,2] 	:= Round((nBasePCC * (SED->ED_PERCPIS / 100)),2)
			Endif
		Else
			aDados[nPosPis,2] 		:= 0
			nOldPis	 			:= 0
		EndIf
		// COFINS
		//³ se natureza pede calculo do COFINS	  ³
		If SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI == "2"
			If ! GetNewPar("MV_RNDCOF",.F.)
				aDados[nPosCof,2] 	:= NoRound((nBasePCC * (SED->ED_PERCCOF / 100)),2)
			Else
				aDados[nPosCof,2] 	:= Round((nBasePCC * (SED->ED_PERCCOF / 100)),2)
			EndIf
		Else
			aDados[nPosCof,2] 		:= 0
			nOldCofins	 		:= 0
		EndIf
		// CSLL
		//³ se natureza pede calculo do CSLL ³
		If SED->ED_CALCCSL == "S"  .and. SA2->A2_RECCSLL == "2"
			If ! GetNewPar("MV_RNDCSL",.F.)
				aDados[nPosCsll,2] 	:= NoRound((nBasePCC * (SED->ED_PERCCSL / 100)),2)
			Else
				aDados[nPosCsll,2] 	:= Round((nBasePCC * (SED->ED_PERCCSL / 100)),2)
			EndIf
		Else
			aDados[nPosCsll,2] 		:= 0
			nOldCsll	  			:= 0
		Endif
	EndIf
EndIf
//Ajusta Valor pcc do titulo retentor
If !(SE2->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"SES"+"/"+"INA")
	RecLock("SE2")
	Replace E2_PIS 	With aDados[nPosPis,2]
	Replace E2_COFINS With aDados[nPosCof,2]
	Replace E2_CSLL 	With aDados[nPosCsll,2]
	MsUnlock()
	FKCOMMIT()
Else

	FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
	SE2->(RecLock("SE2"))
	SE2->(dbDelete())
	SE2->(MsUnlock())
EndIf
//³ Ajusta tambem os registros de impostos-Pcc ³
dbSelectArea("SE2")
SE2->(DbSetOrder(1))
dbSeek(cFil_Rtr+cPre_Rtr+cNum_Rtr+cPar_Rtr)
While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM == ;
cFil_Rtr+cPre_Rtr+cNum_Rtr
	If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_PISNAT"))  .And. ;
	AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
		RecLock("SE2")
		Replace E2_VALOR 		With nPIS_Rtr
		Replace E2_SALDO 		With nPIS_Rtr
		Replace E2_TITPAI With cTitPai_Rtr
		Replace E2_ORIGEM	With "FINA050"
		MsUnlock()
		FKCOMMIT()
	EndIf
	If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_COFINS"))  .And. ;
	AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
		RecLock("SE2")
		Replace E2_VALOR 		With nCOF_Rtr
		Replace E2_SALDO 		With nCOF_Rtr
		Replace E2_TITPAI With cTitPai_Rtr
		Replace E2_ORIGEM	With "FINA050"
		MsUnlock()
		FKCOMMIT()
	EndIf
	If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_CSLL"))  .And. ;
	AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
		RecLock("SE2")
		Replace E2_VALOR 		With nCSL_Rtr
		Replace E2_SALDO 		With nCSL_Rtr
		Replace E2_TITPAI With cTitPai_Rtr
		Replace E2_ORIGEM	With "FINA050"
		MsUnlock()
		FKCOMMIT()
	EndIf
	dbSkip()
Enddo

If ValType(lHelpOld ) == "L"
	lMsHelpAuto := lHelpOld
EndIf
If ValType(lErroOld) == "L"
	lMsErroAuto	:= lErroOld
EndIf

RestArea(aAreaSE2)
RestArea(aAreaSFQ)
RestArea(aArea)

Return lRet

/*/
±±³Fun‡…o	 ³F050BxPai ³ Autor ³Totvs                  ³ Data ³ 05/11/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se o titulo Pai relacionado ao titulo de Imposto  ³±±
±±³          ³ em alteração, foi baixado	     			              		  ³±±
/*/
Function F050BxPai()
Local lRet 		:= .F.
Local aAreaSE2 := SE2->(GetArea())
Local aArea 	:= GetArea()

If !Empty(SE2->E2_TITPAI)

	//Busco o Titulo Pai e verifico se o mesmo sofreu baixas
	dbSelectArea("SE2")
	dbSetOrder(1)
	If dbSeek(xFilial("SE2")+SE2->E2_TITPAI)
		If	SE2->E2_VALOR	<>	SE2->E2_SALDO
			lRet := .T.
		EndIf
	EndIf

Endif

RestArea(aAreaSE2)
RestArea(aArea)

Return lRet

/*/
±±³Fun‡…o	 ³ F050DelPCC ³ Autor ³ Totvs               ³ Data ³ 05/11/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Exclui Impostos PCC                                        ³±±
/*/
Function F050DelPCC()
Local lRet 		:= .F.
Local aAreaSE2 := SE2->(GetArea())
Local aArea 	:= GetArea()
Local cSE2Fil  := SE2->E2_FILIAL
Local cPrefixo	:= SE2->E2_PREFIXO
Local cNum		:= SE2->E2_NUM

dbSelectArea("SE2")
dbSetOrder(1)
If dbSeek(xFilial("SE2")+cPrefixo+cNum)
	While !Eof() .and. SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM) == cSE2Fil+cPrefixo+cNum
		If AllTrim(xFilial("SE2")+cPrefixo+cNum) == AllTrim(E2_FILIAL+E2_PREFIXO+E2_NUM)
			If (SE2->E2_TIPO $ MVTAXA+"/"+MVTXA)
				If AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_PISNAT"	))  	.Or. ;
				AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_COFINS"	))  	.Or. ;
				AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_CSLL"	))

					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					SE2->(RecLock("SE2"))
					SE2->(dbDelete())
					SE2->(MsUnlock())
				EndIf
			EndIf
		EndIf
		DbSkip()
	Enddo
EndIf

RestArea(aAreaSE2)
RestArea(aArea)
Return lRet

/*
±±ºPrograma  ³FINA050   ºAutor  ³ Totvs              º Data ³  05/11/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Trata Ajuste na Alteração, com valores atualizados de      º±±
±±º          ³ Titulo que Reteve os Impostos PCC de outro juntamente com  º±±
±±º          ³ os seus, e, agora, sofreu alteração na base de calculo     º±±
±±º          ³ Alteração da data de referencia do titulo Retido           º±±
*/
Function F050AlRtd2(lAtuPCCRet)
Local aArea 			:= GetArea()
Local aAreaSE2 		:= SE2->(GetArea())
Local aAreaSFQ 		:= SFQ->(GetArea())
Local lRet				:= .T.
Local lHelpOld, lErroOld
Local dDataFim  		:= E2_EMISSAO
Local dDataIni  		:= E2_EMISSAO

//Titulos Retidos
Local nRecRtd   		:= SE2->(RECNO())
Local cFil_Rtd      	:= E2_FILIAL
Local cPre_Rtd      	:= E2_PREFIXO
Local cNum_Rtd     	:= E2_NUM
Local cPar_Rtd     	:= E2_PARCELA
Local nVlr_Rtd_Tot	:= 0
Local nVlr_Rtd   		:= 0
Local nPIS_Rtd 		:= 0
Local nCOF_Rtd			:= 0
Local nCSL_Rtd  		:= 0
Local nPIS_Rt1 		:= 0
Local nCOF_Rt1			:= 0
Local nCSL_Rt1  		:= 0
//Titulo Retentor
Local nRecRtR   		:= SE2->(RECNO())
Local cFil_Rtr      	:= E2_FILIAL
Local cPre_Rtr      	:= E2_PREFIXO
Local cNum_Rtr     	:= E2_NUM
Local cPar_Rtr     	:= E2_PARCELA
Local nVlr_Rtr_Tot	:= 0
Local cTip_Rtr     	:= E2_TIPO
Local cFor_Rtr     	:= E2_FORNECE
Local cLoj_Rtr      	:= E2_LOJA
Local nVlr_Rtr   		:= 0
Local nSdo_Rtr   		:= 0
Local nPIS_Rtr   		:= 0
Local nCOF_Rtr   		:= 0
Local nCSL_Rtr			:= 0
Local nVRPIS_Rtr 		:= 0
Local nVRCOF_Rtr 		:= 0
Local nVRCSL_Rtr		:= 0
Local cTitPai_Rtr   	:= E2_TITPAI
Local nVlMinImp 		:= GetNewPar("MV_VL10925",5000)

/*
Chamado TRGZT8
Os impostos do titulo retentor nao devem sofre alteracoes, quando ele ou os titulos que reteve forem alterados.
Este parametro define se o titulo retentor deve ter os impostos alterados. */
Default lAtuPCCRet		:= .T.

dDataFim  := LastDay( SE2->E2_VENCREA  )
dDataIni  := FirstDay( SE2->E2_VENCREA  )

If Type("lMsHelpAuto") == "L"
	lHelpOld 	:= lMsHelpAuto
	lMsHelpAuto := .F. // Nao exibe erro
Else
	Private lMsHelpAuto := .F.
EndIf

If Type("lMsErroAuto") == "L"
	lErroOld := lMsErroAuto
Else
	Private lMsErroAuto := .F.
Endif
//-- Prepara campos para a função: F050TotMes
M->E2_VENCREA 		:= SE2->E2_VENCREA
M->E2_PIS 			:= SE2->E2_PIS
M->E2_COFINS 		:= SE2->E2_COFINS
M->E2_CSLL 			:= SE2->E2_CSLL
M->E2_APLVLMN 		:=	SE2->E2_APLVLMN
M->E2_TIPO  		:=	SE2->E2_TIPO
M->E2_FORNECE 		:=	SE2->E2_FORNECE
M->E2_LOJA 			:=	SE2->E2_LOJA
M->E2_NATUREZ 		:=	SE2->E2_NATUREZ
M->E2_VLCRUZ 		:=	SE2->E2_VLCRUZ
M->E2_MOEDA 		:=	SE2->E2_MOEDA
M->E2_EMISSAO 		:=	SE2->E2_EMISSAO
M->E2_TXMOEDA		:=	SE2->E2_TXMOEDA
///Totaliza Titulos do Fornecedor Data de referencia é a do retido
aDadosRet 			:= F050TotMes(M->E2_VENCREA,@nIndexSE2,@cIndexSE2)
nVlr_Rtd_Tot 		:= aDadosRet[1]

SFQ->(DbSetOrder(2)) //-- FQ_FILIAL+FQ_ENTDES+FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES
If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
	nRecRtd   :=	SE2->(RECNO())
	cPREFORI  :=	SFQ->FQ_PREFORI
	nNUMORI   :=	SFQ->FQ_NUMORI
	nPARCORI  :=	SFQ->FQ_PARCORI
	cTIPOORI  :=	SFQ->FQ_TIPOORI
	nCFORI    :=	SFQ->FQ_CFORI
	nLOJAORI  :=	SFQ->FQ_LOJAORI
	//-- Localiza Tit Retentor
	SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
	If SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI)))
		nRecRtR   			:=	SE2->(RECNO())
		SE2->E2_PREFIXO	:= cPREFORI
		SE2->E2_NUM			:=	nNUMORI
		SE2->E2_PARCELA	:=	nPARCORI
		SE2->E2_TIPO		:=	cTIPOORI
		SE2->E2_FORNECE	:=	nCFORI
		SE2->E2_LOJA		:=	nLOJAORI
		//-- Prepara campos para a função: F050TotMes
		M->E2_VENCREA 		:= SE2->E2_VENCREA
		M->E2_PIS 			:= SE2->E2_PIS
		M->E2_COFINS 		:= SE2->E2_COFINS
		M->E2_CSLL 			:= SE2->E2_CSLL
		M->E2_APLVLMN 		:=	SE2->E2_APLVLMN
		M->E2_TIPO  		:=	SE2->E2_TIPO
		M->E2_FORNECE 		:=	SE2->E2_FORNECE
		M->E2_LOJA 			:=	SE2->E2_LOJA
		M->E2_NATUREZ 		:=	SE2->E2_NATUREZ
		M->E2_VLCRUZ 		:=	SE2->E2_VLCRUZ
		M->E2_MOEDA 		:=	SE2->E2_MOEDA
		M->E2_EMISSAO 		:=	SE2->E2_EMISSAO
		M->E2_TXMOEDA		:=	SE2->E2_TXMOEDA
		///Totaliza Titulos do Fornecedor Data de referencia é a do Retentor
		aDadosRet 			:= F050TotMes(M->E2_VENCREA,@nIndexSE2,@cIndexSE2)
		nVlr_Rtr_Tot 		:= aDadosRet[1]

		SFQ->(dbSetOrder(1))
		///Pesquisa Todos Titulos Retidos neste Titulo Retentor, para o fornecedor e periodo
		If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
			While SFQ->(!Eof()) .and. SFQ->FQ_FILIAL == xFilial("SFQ") .And.;
			SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI) == cPREFORI+nNUMORI+nPARCORI+cTIPOORI+nCFORI+nLOJAORI
				cChaveSFQ := SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)
				//-- Localiza Titulos Retidos
				SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
				If 	SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)))
					If nRecRtd   			== 	SE2->(RECNO())
						cFil_Rtd    		:= 	SE2->E2_FILIAL
						cPre_Rtd    		:= 	SE2->E2_PREFIXO
						cNum_Rtd    		:= 	SE2->E2_NUM
						cPar_Rtd    		:= 	SE2->E2_PARCELA
						nVlr_Rtd				:= 	SE2->E2_VALOR + SE2->E2_VRETPIS + SE2->E2_VRETCOF + SE2->E2_VRETCSL
						nPIS_Rtd   			:= 	SE2->E2_PIS
						nCOF_Rtd  			:= 	SE2->E2_COFINS
						nCSL_Rtd   		  	:= 	SE2->E2_CSLL
						//Exclui Relacionamento do titulo Retido com seu Retentor
						RecLock("SFQ")
						dbDelete()
						MsUnlock()
						FKCOMMIT()
					Else
						nPIS_Rt1 			+= 	SE2->E2_PIS
						nCOF_Rt1				+= 	SE2->E2_COFINS
						nCSL_Rt1  			+= 	SE2->E2_CSLL
					EndIf

					If 	nVlr_Rtr_Tot 	<= 	nVlMinImp
						//Atualiza Situação de Retenção do titulo Retido
						RecLock("SE2")
						Replace E2_PRETPIS 	With '1'
						Replace E2_PRETCOF 	With '1'
						Replace E2_PRETCSL 	With '1'
						MsUnlock()
						FKCOMMIT()
						//Exclui Relacionamento do titulo Retido com seu Retentor
						RecLock("SFQ")
						dbDelete()
						MsUnlock()
						FKCOMMIT()
					EndIf
				EndIf
				SFQ->(dbSkip())
			Enddo
		Endif


		//-- Salva dados do Titulo Retentor
		SE2->(dbGoto(nRecRtR))
		cFil_Rtr    := SE2->E2_FILIAL
		cPre_Rtr    := SE2->E2_PREFIXO
		cNum_Rtr    := SE2->E2_NUM
		cPar_Rtr    := SE2->E2_PARCELA
		cTip_Rtr    := SE2->E2_TIPO
		cFor_Rtr    := SE2->E2_FORNECE
		cLoj_Rtr    := SE2->E2_LOJA
		nVlr_Rtr   	:= SE2->E2_VALOR
		nSdo_Rtr   	:= SE2->E2_SALDO
		nPIS_Rtr   	:= SE2->E2_PIS
		nCOF_Rtr   	:= SE2->E2_COFINS
		nCSL_Rtr	:= SE2->E2_CSLL
		nVRPIS_Rtr 	:= SE2->E2_VRETPIS
		nVRCOF_Rtr 	:= SE2->E2_VRETCOF
		nVRCSL_Rtr	:= SE2->E2_VRETCSL
		cTitPai_Rtr := Rtrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))

		//-- Ajusta Titulo Retido Alterado (periodo)
		SE2->(dbGoto(nRecRtd))
		RecLock("SE2")

		If nVlr_Rtd_Tot > nVlMinImp
			//Pesquisar titulos pendentes de retenção para o Fornecedor periodo(E2_PRETPIS ="1")
			//se encontrar gravar relacionamento(SFQ) entre o pendente e este
			F050GrvSFQ()
			Replace E2_VALOR 	With SE2->(E2_VALOR - E2_VRETPIS - E2_VRETCOF - E2_VRETCSL)
			Replace E2_SALDO 	With SE2->(E2_SALDO - E2_VRETPIS - E2_VRETCOF - E2_VRETCSL)
			Replace E2_VRETPIS 	With SE2->E2_VRETPIS
			Replace E2_VRETCOF 	With SE2->E2_VRETCOF
			Replace E2_VRETCSL 	With SE2->E2_VRETCSL
			Replace E2_PRETPIS 	With ' '
			Replace E2_PRETCOF 	With ' '
			Replace E2_PRETCSL 	With ' '
			// Grava Impostos PCC
			F050TXPCC()
		Else
			Replace E2_PRETPIS 	With '1'
			Replace E2_PRETCOF 	With '1'
			Replace E2_PRETCSL 	With '1'
		EndIf
		MsUnlock()
		FKCOMMIT()

		//-- Ajusta Titulo Retentor
		SE2->(dbGoto(nRecRtr))
		If lAtuPCCRet
			RecLock("SE2")

			If nVlr_Rtr_Tot > nVlMinImp
				Replace E2_VALOR 	With (nVlr_Rtr + nPIS_Rtd + nCOF_Rtd + nCSL_Rtd)
				Replace E2_SALDO 	With (nVlr_Rtr + nPIS_Rtd + nCOF_Rtd + nCSL_Rtd)
				Replace E2_VRETPIS 	With nPIS_Rtr + nPIS_Rt1
				Replace E2_VRETCOF 	With nCOF_Rtr + nCOF_Rt1
				Replace E2_VRETCSL 	With nCSL_Rtr + nCSL_Rt1
				Replace E2_PIS 		With nPIS_Rtr
				Replace E2_COFINS 	With nCOF_Rtr
				Replace E2_CSLL 	With nCSL_Rtr
			Else
				Replace E2_VALOR 	With nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
				Replace E2_SALDO   	With nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
				Replace E2_VRETPIS 	With 	0
				Replace E2_VRETCOF 	With 	0
				Replace E2_VRETCSL 	With 	0
				Replace E2_PRETPIS 	With 	'1'
				Replace E2_PRETCOF 	With 	'1'
				Replace E2_PRETCSL 	With 	'1'
				Replace E2_PIS 		With nPIS_Rtr
				Replace E2_COFINS 	With nCOF_Rtr
				Replace E2_CSLL 	With nCSL_Rtr
			EndIf
			MsUnlock()
			FKCOMMIT()
			If nVlr_Rtr_Tot > nVlMinImp
				//³ Ajusta tambem os registros de impostos-Pcc ³
				dbSelectArea("SE2")
				SE2->(DbSetOrder(1))
				dbSeek(cFil_Rtr+cPre_Rtr+cNum_Rtr+cPar_Rtr)
				While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM == ;
				cFil_Rtr+cPre_Rtr+cNum_Rtr
					If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_PISNAT"))  .And. ;
					AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
						RecLock("SE2")
						Replace E2_VALOR 	With nPIS_Rtr 		+ 	nPIS_Rt1
						Replace E2_SALDO 	With nPIS_Rtr 		+ 	nPIS_Rt1
						Replace E2_TITPAI With cTitPai_Rtr
						Replace E2_ORIGEM	With "FINA050"
						MsUnlock()
						FKCOMMIT()
					EndIf
					If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_COFINS"))  .And. ;
					AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
						RecLock("SE2")
						Replace E2_VALOR 	With nCOF_Rtr 		+ 	nCOF_Rt1
						Replace E2_SALDO 	With nCOF_Rtr 		+ 	nCOF_Rt1
						Replace E2_TITPAI With cTitPai_Rtr
						Replace E2_ORIGEM	With "FINA050"
						MsUnlock()
						FKCOMMIT()
					EndIf
					If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_CSLL"))  .And. ;
					AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
						RecLock("SE2")
						Replace E2_VALOR 	With nCSL_Rtr 		+ 	nCSL_Rt1
						Replace E2_SALDO 	With nCSL_Rtr 		+ 	nCSL_Rt1
						Replace E2_TITPAI With cTitPai_Rtr
						Replace E2_ORIGEM	With "FINA050"
						MsUnlock()
						FKCOMMIT()
					EndIf
					dbSkip()
				Enddo
			Else
				F050DelPCC()
			EndIf
		Endif
	Else
		Help(" ",1,"NOATUARET"     ,, STR0169  + cPre_Rtr + cNum_Rtr      , 1,0)  //"Titulo Retentor - Não Atualizado: "
		lRet := .F.
	EndIf
Else
	Help(" ",1,"NOATUARET"     ,, STR0169  + cPre_Rtr + cNum_Rtr      , 1,0)  //"Titulo Retentor - Não Atualizado: "
	lRet := .F.
EndIf

If ValType(lHelpOld ) == "L"
	lMsHelpAuto := lHelpOld
EndIf
If ValType(lErroOld) == "L"
	lMsErroAuto	:= lErroOld
Endif

RestArea(aAreaSE2)
RestArea(aAreaSFQ)
RestArea(aArea)

Return lRet

/*
±±ºPrograma  ³FINA050   ºAutor  ³ Totvs              º Data ³  05/11/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Trata Ajuste na Alteração de:                              º±±
±±º          ³ Titulo que Reteve os Impostos PCC de outro juntamente com  º±±
±±º          ³ os seus, e, agora, sofreu alteração na base de calculo.    º±±
±±º          ³ Alteração do periodo de referencia do Titulo Retentor      º±±
*/
Function F050GrRtr2(lAtuPCCRet)
Local aArea 			:= GetArea()
Local aAreaSE2 		:= SE2->(GetArea())
Local aAreaSFQ := SFQ->(GetArea())
Local lRet				:= .T.
Local lHelpOld, lErroOld
Local dDataFim  		:= E2_EMISSAO
Local dDataIni  		:= E2_EMISSAO
//Titulo Retido
Local nRecRtd   		:= 0
Local cFil_Rtd      	:= E2_FILIAL
Local cPre_Rtd      	:= E2_PREFIXO
Local cNum_Rtd     	:= E2_NUM
Local cPar_Rtd     	:= E2_PARCELA
Local nVRPIS_Rtd 		:= 0
Local nVRCOF_Rtd 		:= 0
Local nVRCSL_Rtd		:= 0

//Titulo Retentor
Local nRecRtR   		:= SE2->(RECNO())
Local cFil_Rtr      	:= E2_FILIAL
Local cPre_Rtr      	:= E2_PREFIXO
Local cNum_Rtr     	:= E2_NUM
Local cPar_Rtr     	:= E2_PARCELA
Local nVlr_Rtr_Tot	:= 0
Local cTip_Rtr     	:= E2_TIPO
Local cFor_Rtr     	:= E2_FORNECE
Local cLoj_Rtr      	:= E2_LOJA
Local nVlr_Rtr   		:= 0
Local nSdo_Rtr   		:= 0
Local nPIS_Rtr   		:= 0
Local nCOF_Rtr   		:= 0
Local nCSL_Rtr			:= 0
Local nVRPIS_Rtr 		:= 0
Local nVRCOF_Rtr 		:= 0
Local nVRCSL_Rtr		:= 0
Local cTitPai_Rtr   	:= E2_TITPAI
Local nVlMinImp 		:= GetNewPar("MV_VL10925",5000)

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

/*
Chamado TRGZT8
Os impostos do titulo retentor nao devem sofre alteracoes, quando ele ou os titulos que reteve forem alterados.
Este parametro define se o titulo retentor deve ter os impostos alterados. */
Default lAtuPCCRet		:= .T.

dDataFim  := LastDay( SE2->E2_VENCREA  )
dDataIni  := FirstDay( SE2->E2_VENCREA  )

If Type("lMsHelpAuto") == "L"
	lHelpOld 	:= lMsHelpAuto
	lMsHelpAuto := .F. // Nao exibe erro
Else
	Private lMsHelpAuto := .F.
EndIf

If Type("lMsErroAuto") == "L"
	lErroOld := lMsErroAuto
Else
	Private lMsErroAuto := .F.
EndIf

cPREFORI  			:=	SE2->E2_PREFIXO
nNUMORI   			:=	SE2->E2_NUM
nPARCORI  			:=	SE2->E2_PARCELA
cTIPOORI  			:=	SE2->E2_TIPO
nCFORI    			:=	SE2->E2_FORNECE
nLOJAORI 			:=	SE2->E2_LOJA
//-- Salva dados do Titulo Retentor
//-- Titulo Retentor
nRecRtR   			:=	SE2->(RECNO())
cFil_Rtr    		:= SE2->E2_FILIAL
cPre_Rtr    		:= SE2->E2_PREFIXO
cNum_Rtr    		:= SE2->E2_NUM
cPar_Rtr    		:= SE2->E2_PARCELA
cTip_Rtr    		:= SE2->E2_TIPO
cFor_Rtr    		:= SE2->E2_FORNECE
cLoj_Rtr    		:= SE2->E2_LOJA
nVlr_Rtr   			:= SE2->E2_VALOR
nSdo_Rtr   			:= SE2->E2_SALDO
nPIS_Rtr   			:= SE2->E2_PIS
nCOF_Rtr   			:= SE2->E2_COFINS
nCSL_Rtr				:= SE2->E2_CSLL
nVRPIS_Rtr 			:= SE2->E2_VRETPIS
nVRCOF_Rtr 			:= SE2->E2_VRETCOF
nVRCSL_Rtr			:= SE2->E2_VRETCSL
cTitPai_Rtr 		:= Rtrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
//-- Prepara campos para a função: F050TotMes
M->E2_VENCREA 		:= SE2->E2_VENCREA
M->E2_PIS 			:= SE2->E2_PIS
M->E2_COFINS 		:= SE2->E2_COFINS
M->E2_CSLL 			:= SE2->E2_CSLL
M->E2_APLVLMN 		:=	SE2->E2_APLVLMN
M->E2_TIPO  		:=	SE2->E2_TIPO
M->E2_FORNECE 		:=	SE2->E2_FORNECE
M->E2_LOJA 			:=	SE2->E2_LOJA
M->E2_NATUREZ 		:=	SE2->E2_NATUREZ
M->E2_VLCRUZ 		:=	SE2->E2_VLCRUZ
M->E2_MOEDA 		:=	SE2->E2_MOEDA
M->E2_EMISSAO 		:=	SE2->E2_EMISSAO
M->E2_TXMOEDA		:=	SE2->E2_TXMOEDA
///Totaliza Titulos do Fornecedor Data de referencia é a do Retentor
aDadosRet 			:= F050TotMes(M->E2_VENCREA,@nIndexSE2,@cIndexSE2)
nVlr_Rtr_Tot 		:= aDadosRet[1] // + (SE2->E2_VRETPIS + SE2->E2_VRETCOF + SE2->E2_VRETCSL)

SFQ->(dbSetOrder(1))
///Pesquisa Todos Titulos Retidos neste Titulo Retentor, para o fornecedor e periodo
If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
	While SFQ->(!Eof()) .and. SFQ->FQ_FILIAL == xFilial("SFQ") .And.;
	SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI) == cPREFORI+nNUMORI+nPARCORI+cTIPOORI+nCFORI+nLOJAORI
		cChaveSFQ := SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)
		//-- Localiza Titulos Retidos
		SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
		If		SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)))
			//Salva chaves de Ultimo retido e totais de valores retidos
			nRecRtd   				:= SE2->(RECNO())
			cFil_Rtd      			:= SE2->E2_FILIAL
			cPre_Rtd      			:= SE2->E2_PREFIXO
			cNum_Rtd     			:= SE2->E2_NUM
			cPar_Rtd     			:= SE2->E2_PARCELA
			nVRPIS_Rtd 				+= SE2->E2_PIS
			nVRCOF_Rtd 				+= SE2->E2_COFINS
			nVRCSL_Rtd				+= SE2->E2_CSLL

			//Atualiza Situação de Retenção do titulo Retido
			RecLock("SE2")
			Replace E2_PRETPIS 	With '1'
			Replace E2_PRETCOF 	With '1'
			Replace E2_PRETCSL 	With '1'
			MsUnlock()
			FKCOMMIT()

			//Exclui Relacionamento do titulo Retido com seu Retentor
			RecLock("SFQ")
			dbDelete()
			MsUnlock()
			FKCOMMIT()
		EndIf
		SFQ->(dbSkip())
	EndDo
EndIf

//-- Ajusta Titulo Alterado (periodo)
SE2->(dbGoto(nRecRtr))
If lAtuPCCRet
	If !(lAltera .And. !lPCCBaixa .And. SE2->E2_VALOR == SE2->E2_BASEPIS - SE2->(E2_VRETPIS + E2_VRETCOF + SE2->E2_VRETCSL))
		SE2->E2_VALOR	+= SE2->(E2_VRETPIS + E2_VRETCOF + SE2->E2_VRETCSL)
		SE2->E2_SALDO	+= SE2->(E2_VRETPIS + E2_VRETCOF + SE2->E2_VRETCSL)
	EndIf

	RecLock("SE2")

	If nVlr_Rtr_Tot > nVlMinImp
		//Pesquisar titulos pendentes de retenção para Fornecedor periodo(E2_PRETPIS ="1")
		//se encontrar gravar relacionamento(SFQ) entre o pendente e este
		F050GrvSFQ()
		Replace E2_VALOR 		With SE2->(E2_VALOR - E2_VRETPIS - E2_VRETCOF - E2_VRETCSL)
		Replace E2_SALDO 		With SE2->(E2_SALDO - E2_VRETPIS - E2_VRETCOF - E2_VRETCSL)
		Replace E2_VLCRUZ 	With IF(SE2->E2_MOEDA == 1,SE2->E2_VALOR,Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,MsDecimais(1)+1,SE2->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1)))
		Replace E2_VRETPIS 	With SE2->E2_VRETPIS
		Replace E2_VRETCOF 	With SE2->E2_VRETCOF
		Replace E2_VRETCSL 	With SE2->E2_VRETCSL
		Replace E2_PRETPIS 	With ' '
		Replace E2_PRETCOF 	With ' '
		Replace E2_PRETCSL 	With ' '
		// Exclui Impostos PCC periodo anterior
		F050DelPCC()

		// Grava Impostos PCC
		F050TXPCC()
	Else
		Replace E2_VALOR 		With SE2->E2_VALOR
		Replace E2_SALDO 		With SE2->E2_SALDO
		Replace E2_VRETPIS 	With 0
		Replace E2_VRETCOF 	With 0
		Replace E2_VRETCSL 	With 0
		Replace E2_PRETPIS 	With '1'
		Replace E2_PRETCOF 	With '1'
		Replace E2_PRETCSL 	With '1'
	Endif

	///Totaliza Titulos do Fornecedor Data de referencia é a Anterior a Alteração do Retentor
	aDadosRet 			:= F050TotMes(dOldVencRe,@nIndexSE2,@cIndexSE2)
	nVlr_Rtr_Tot 		:= aDadosRet[1]
	// Caso o valor total dos titulos remanescentes seja superior ao minimo, gerar novo retentor
	If nVlr_Rtr_Tot 	> 	nVlMinImp
		If nRecRtd		<>	0
			SE2->(dbGoto(nRecRtd))
			Replace E2_VALOR 		With SE2->(E2_VALOR - nVRPIS_Rtd - nVRCOF_Rtd - nVRCSL_Rtd)
			Replace E2_SALDO 		With SE2->(E2_SALDO - nVRPIS_Rtd - nVRCOF_Rtd - nVRCSL_Rtd)
			Replace E2_VRETPIS 	With nVRPIS_Rtd
			Replace E2_VRETCOF 	With nVRCOF_Rtd
			Replace E2_VRETCSL 	With nVRCSL_Rtd
			Replace E2_PRETPIS 	With ' '
			Replace E2_PRETCOF 	With ' '
			Replace E2_PRETCSL 	With ' '

			//Pesquisar titulos pendentes de retenção para Fornecedor periodo(E2_PRETPIS ="1")
			//se encontrar gravar relacionamento(SFQ) entre o pendente e este
			If F050GrvSFQ()
				// Exclui Impostos PCC periodo anterior
				F050DelPCC()

				// Grava Impostos PCC
				F050TXPCC()
			Endif
		EndIf
	Else
		//Pesquisa titulos Retidos no periodo anterior a alteração, altera a situação para pendente de rentenção e exclui os impostos pcc respectivos
		F050AltPCC()
	EndIf
	MsUnlock()
	FKCOMMIT()
Endif

If ValType(lHelpOld ) == "L"
	lMsHelpAuto := lHelpOld
EndIf
If ValType(lErroOld) == "L"
	lMsErroAuto	:= lErroOld
EndIf

RestArea(aAreaSE2)
RestArea(aAreaSFQ)
RestArea(aArea)

Return lRet

/*/
±±³Fun‡…o	 ³ F050TXPCC   ³ Autor ³ Totvs               ³ Data ³ 05/11/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava Impostos Pcc                                         ³±±
/*/
Function F050TXPCC()
Local lRet 	  		:= .F.
Local aAreaSE2 	:= SE2->(GetArea())
Local aArea   		:= GetArea()
Local nRegSe2     := SE2->(RECNO())
Local cPrefixo		:= SE2->E2_PREFIXO
Local cNum	  		:= SE2->E2_NUM
Local cTipoSE2 	:= SE2->E2_TIPO
Local dVencrea    := SE2->E2_VENCREA
Local dVctoReal   := SE2->E2_VENCREA
Local dEmissao    := SE2->E2_VENCREA
Local dEmis1      := SE2->E2_VENCREA
Local cParcPis    := SE2->E2_PARCELA
Local cParcCsll   := SE2->E2_PARCELA
Local cParcCof    := SE2->E2_PARCELA
Local cModSpb		:= "1"
Local lSpbInUse	:= SpbInUse()
Local nValPis     := SE2->E2_VRETPIS
Local nValCofins  := SE2->E2_VRETCOF
Local nValCsll    := SE2->E2_VRETCSL
Local cCodRetPis 	:= ""
Local cCodRetCof 	:= ""
Local cCodRetCsl 	:= ""
Local cGeraDirf 	:= Iif(cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN",SE2->E2_DIRF," ")

Local	cTitPai_Rtr := Rtrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))

Local lCodRtPCC 	:= cPaisLoc == "BRA"

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local cLojaImp	:= PadR( "00", TamSX3("A2_LOJA")[1], "0" )

Local cCodAprov := SE2->E2_CODAPRO

If	(SE2->E2_PIS <= 0 .Or. SE2->E2_COFINS <= 0 .Or. SE2->E2_CSLL <= 0 )
	cCodRetPis := If (lCodRtPCC .and. !Empty(SE2->E2_CODRPIS),SE2->E2_CODRPIS,"5979")
	cCodRetCof := If (lCodRtPCC .and. !Empty(SE2->E2_CODRCOF),SE2->E2_CODRCOF,"5960")
	cCodRetCsl := If (lCodRtPCC .and. !Empty(SE2->E2_CODRCSL),SE2->E2_CODRCSL,"5987")
Else
	// Se os 3 impostos juntos for maior que a media de retencao, o codigo sera o mesmo
	// para os tres.
	If SE2->(E2_PIS+E2_COFINS+E2_CSLL) > ((GetMv("MV_VRETPIS")+GetMv("MV_VRETCOF")+GetMv("MV_VRETCSL")) / 3)
		cCodRetPis := If (lCodRtPCC .and. !Empty(SE2->E2_CODRPIS),SE2->E2_CODRPIS,"5952")
		cCodRetCof := If (lCodRtPCC .and. !Empty(SE2->E2_CODRCOF),SE2->E2_CODRCOF,"5952")
		cCodRetCsl := If (lCodRtPCC .and. !Empty(SE2->E2_CODRCSL),SE2->E2_CODRCSL,"5952")
	EndIf
EndIf


//Verifica se aglutina os impostos em apenas um titulo
If SuperGetMv("MV_AG10925",.F.,"2") == "1" .and. cCodRetPis == "5952"
	nRefCof := nValCofins //Armazena o valor do Cofins, para recompor os valores apos a geracao dos titulos
	nRefCsl := nValCsll   //Armazena o valor do Csll, para recompor os valores apos a geracao dos titulos

	nValPis += nValCofins + nValCsll
	nValCofins := 0
	nValCsll := 0
Endif
//³ Gera titulo de PIS								  ³
//³ Cria o fornecedor, caso nao exista			  ³
If nValPis > 0
	dbSelectArea("SA2")
	If !(dbSeek(xFilial("SA2")+GetMv("MV_UNIAO")))
		Reclock("SA2",.T.)
		Replace A2_FILIAL With xFilial("SA2")
		Replace A2_COD    With GetmV("MV_UNIAO")
		Replace A2_NOME	With "UNIAO"
		Replace A2_NREDUZ With "UNIAO"
		Replace A2_LOJA	With cLojaImp
		Replace A2_MUN 	With "."
		Replace A2_EST 	With SuperGetMv("MV_ESTADO")
		Replace A2_BAIRRO With "."
		Replace A2_END 	With "."
		Replace A2_TIPO	With "J"
	EndIF
	dVencRea := F050VImp("PIS",dEmissao,dEmis1,dVctoReal) // Calcula o vencimento do imposto

	//³ Verifica parcela do PIS caso exista titulo ³
	//³ de PIS com o mesmo numero.                 ³
	cParcPis := ParcImposto(cPrefixo,cNum,cTipoSE2)
	//³ Grava a parcela do PIS no titulo pai fazendo ³
	//³ a amarracao titulo x titulo PIS 				 ³
	dbGoto(nRegSe2)
	RecLock("SE2")
	SE2->E2_PARCPIS 	:= cParcPis
	SE2->E2_DIRF    	:= "2"	 // Desmarca titulo principal, pois apenas o titulo de
	// imposto var para DIRF
	//³ Cria a natureza PIS caso nao exista 		 ³
	dbSelectArea("SED")
	cVar := Alltrim(GetMv("MV_PISNAT"))
	cVar := cVar + Space(10-Len(cVar))
	If !(dbSeek(cFilial+cVar))
		RecLock("SED",.T.)
		Replace 	ED_FILIAL  With cFilial,;
		ED_CODIGO  With cVar	,	;
		ED_CALCIRF With "N" 	,	;
		ED_CALCISS With "N"	, 	;
		ED_CALCINS With "N"	,	;
		ED_CALCCSL With "N"  ,	;
		ED_CALCCOF With "N"  ,  ;
		ED_CALCPIS With "N"  ,	;
		ED_DESCRIC With "PIS",  ;
		ED_TIPO	   With "2"
	EndIf
	//³ Grava titulo de PIS caso n„o exista anterior.³
	RecLock("SE2",.T.)
	SE2->E2_FILIAL		:= cFilial
	SE2->E2_PREFIXO 	:= cPrefixo
	SE2->E2_NUM			:= cNum
	SE2->E2_PARCELA 	:= cParcPis
	SE2->E2_NATUREZ 	:= GetMv("MV_PISNAT")
	SE2->E2_TIPO		:= Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG  .And. !lPCCBaixa,MVTXA,MVTAXA)
	SE2->E2_EMISSAO 	:= dDataBase
	SE2->E2_VALOR		:= nValPis
	SE2->E2_VENCREA 	:= dVencrea
	SE2->E2_SALDO		:= nValPis
	SE2->E2_VENCTO		:= dVencRea
	SE2->E2_VENCORI 	:= dVencRea
	SE2->E2_EMIS1		:= IIf(Type("dDataEmis1") # "U",IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
	SE2->E2_FORNECE		:= GetMv("MV_UNIAO")
	SE2->E2_LOJA 		:= cLojaImp
	SE2->E2_NOMFOR		:= SA2->A2_NREDUZ
	SE2->E2_MOEDA		:= 1
	SE2->E2_VLCRUZ		:= Round( nValPis, MsDecimais(1) )
	SE2->E2_TITPAI    := cTitPai_Rtr
	SE2->E2_CODAPRO		:= cCodAprov
	SE2->E2_ORIGEM		:= "FINA050"
	If lSpbInUse
		Replace	SE2->E2_MODSPB with cModSpb
	EndIf

	SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)
	SE2->E2_DIRF    := cGeraDirf
	SE2->E2_CODRET  := cCodRetPis
	//³ Grava o lancamento de PIS no PCO ³
	PCODetLan("000002","10","FINA050")
Endif

//³ Gera titulo de COFINS							  ³
//³ Cria o fornecedor, caso nao exista			  ³
If nValCofins > 0
	dbSelectArea("SA2")
	If !(dbSeek(xFilial("SA2")+GetMv("MV_UNIAO")))
		Reclock("SA2",.T.)
		Replace A2_FILIAL With xFilial("SA2")
		Replace A2_COD    With GetmV("MV_UNIAO")
		Replace A2_NOME	With "UNIAO"
		Replace A2_NREDUZ With "UNIAO"
		Replace A2_LOJA	With cLojaImp
		Replace A2_MUN 	With "."
		Replace A2_EST 	With SuperGetMv("MV_ESTADO")
		Replace A2_BAIRRO With "."
		Replace A2_END 	With "."
		Replace A2_TIPO	With "J"
	Endif
	dVencRea := F050VImp("COFINS",dEmissao,dEmis1,dVctoReal) // Calcula o vencimento do imposto
	//³ Verifica parcela do COFINS caso exista titulo ³
	//³ de COFINS com o mesmo numero.                 ³
	cParcCof := ParcImposto(cPrefixo,cNum,cTipoSE2)
	//³ Grava a parcela do COFINS no titulo pai fazendo ³
	//³ a amarracao titulo x titulo COFINS	   			 ³
	dbGoto(nRegSe2)
	RecLock("SE2")
	SE2->E2_PARCCOF 	:= cParcCof
	SE2->E2_DIRF    	:= "2"	 // Desmarca titulo principal, pois apenas o titulo de
	// imposto var para DIRF
	//³ Cria a natureza COFINS caso nao exista 	³
	dbSelectArea("SED")
	cVar := Alltrim(GetMv("MV_COFINS"))
	cVar := cVar + Space(10-Len(cVar))
	If !(dbSeek(cFilial+cVar))
		RecLock("SED",.T.)
		Replace 	ED_FILIAL  With cFilial,;
		ED_CODIGO  With cVar	,	;
		ED_CALCIRF With "N" 	,	;
		ED_CALCISS With "N"	, 	;
		ED_CALCINS With "N"	,	;
		ED_CALCCSL With "N"  ,	;
		ED_CALCCOF With "N"  ,  ;
		ED_CALCPIS With "N"  ,	;
		ED_DESCRIC With "COFINS",;
		ED_TIPO	   With "2"
	Endif
	//³ Grava titulo de COFINS caso n„o exista anterior.³
	RecLock("SE2",.T.)
	SE2->E2_FILIAL		:= cFilial
	SE2->E2_PREFIXO 	:= cPrefixo
	SE2->E2_NUM			:= cNum
	SE2->E2_PARCELA 	:= cParcCof
	SE2->E2_NATUREZ 	:= GetMv("MV_COFINS")
	SE2->E2_TIPO	   := Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG  .And. !lPCCBaixa,MVTXA,MVTAXA)
	SE2->E2_EMISSAO 	:= dDataBase
	SE2->E2_VALOR		:= nValCofins
	SE2->E2_VENCREA 	:= dVencrea
	SE2->E2_SALDO		:= nValCofins
	SE2->E2_VENCTO		:= dVencRea
	SE2->E2_VENCORI 	:= dVencRea
	SE2->E2_EMIS1		:= IIf(Type("dDataEmis1") # "U", IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
	SE2->E2_FORNECE		:= GetMv("MV_UNIAO")
	SE2->E2_LOJA 		:= cLojaImp
	SE2->E2_NOMFOR		:= SA2->A2_NREDUZ
	SE2->E2_MOEDA		:= 1
	SE2->E2_VLCRUZ		:= Round( nValCofins, MsDecimais(1) )
	SE2->E2_TITPAI    	:= cTitPai_Rtr
	SE2->E2_CODAPRO		:= cCodAprov
	SE2->E2_ORIGEM		:= "FINA050"
	If lSpbInUse
		Replace	SE2->E2_MODSPB with cModSpb
	EndIf
	SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)
	SE2->E2_DIRF    := cGeraDirf
	SE2->E2_CODRET  := cCodRetCof

	//³ Gera o lancamento de COFINS no PCO ³
	PCODetLan("000002","11","FINA050")
EndIf
//³ Gera titulo de CSLL							  ³
//³ Cria o fornecedor, caso nao exista			  ³
If nValCsll > 0
	dbSelectArea("SA2")
	If !(dbSeek(xFilial("SA2")+GetMv("MV_UNIAO")))
		Reclock("SA2",.T.)
		Replace A2_FILIAL With xFilial("SA2")
		Replace A2_COD    With GetmV("MV_UNIAO")
		Replace A2_NOME	With "UNIAO"
		Replace A2_NREDUZ With "UNIAO"
		Replace A2_LOJA	With cLojaImp
		Replace A2_MUN 	With "."
		Replace A2_EST 	With SuperGetMv("MV_ESTADO")
		Replace A2_BAIRRO With "."
		Replace A2_END 	With "."
		Replace A2_TIPO	With "J"
	EndIf
	dVencRea := F050VImp("CSLL",dEmissao,dEmis1,dVctoReal) // Calcula o vencimento do imposto

	//³ Verifica parcela do CSLL caso exista titulo ³
	//³ de CSLL com o mesmo numero.                 ³
	cParcCsll := ParcImposto(cPrefixo,cNum,cTipoSE2)
	//³ Grava a parcela do CSLL no titulo pai fazendo ³
	//³ a amarracao titulo x titulo CSLL   			  ³
	dbGoto(nRegSe2)
	RecLock("SE2")
	SE2->E2_PARCSLL 	:= cParcCsll
	SE2->E2_DIRF    	:= "2"	 // Desmarca titulo principal, pois apenas o titulo de
	// imposto vai para DIRF
	//³ Cria a natureza CSLL caso nao exista 	³
	dbSelectArea("SED")
	cVar := Alltrim(GetMv("MV_CSLL"))
	cVar := cVar + Space(10-Len(cVar))
	If !(dbSeek(cFilial+cVar))
		RecLock("SED",.T.)
		Replace 	ED_FILIAL  With cFilial,;
		ED_CODIGO  With cVar	,	;
		ED_CALCIRF With "N" 	,	;
		ED_CALCISS With "N"	, 	;
		ED_CALCINS With "N"	,	;
		ED_CALCCSL With "N"  ,	;
		ED_CALCCOF With "N"  ,  ;
		ED_CALCPIS With "N"  ,	;
		ED_DESCRIC With "CSLL", ;
		ED_TIPO	   With "2"
	EndIf

	//³ Grava titulo de CSLL caso n„o exista anterior.³
	RecLock("SE2",.T.)
	SE2->E2_FILIAL		:= cFilial
	SE2->E2_PREFIXO 	:= cPrefixo
	SE2->E2_NUM			:= cNum
	SE2->E2_PARCELA 	:= cParcCsll
	SE2->E2_NATUREZ 	:= GetMv("MV_CSLL")
	SE2->E2_TIPO		:= Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG  .And. !lPCCBaixa,MVTXA,MVTAXA)
	SE2->E2_EMISSAO 	:= dDataBase
	SE2->E2_VALOR		:= nValCsll
	SE2->E2_VENCREA 	:= dVencrea
	SE2->E2_SALDO		:= nValCsll
	SE2->E2_VENCTO		:= dVencRea
	SE2->E2_VENCORI 	:= dVencRea
	SE2->E2_EMIS1		:= IIf(Type("dDataEmis1") # "U", IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
	SE2->E2_FORNECE	:= GetMv("MV_UNIAO")
	SE2->E2_LOJA 		:= cLojaImp
	SE2->E2_NOMFOR		:= SA2->A2_NREDUZ
	SE2->E2_MOEDA		:= 1
	SE2->E2_VLCRUZ		:= Round( nValCsll, MsDecimais(1) )
	SE2->E2_TITPAI    := cTitPai_Rtr
	SE2->E2_CODAPRO		:= cCodAprov
	SE2->E2_ORIGEM		:= "FINA050"
	If lSpbInUse
		Replace	SE2->E2_MODSPB with cModSpb
	EndIf
	SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)
	SE2->E2_DIRF    := cGeraDirf
	SE2->E2_CODRET  := cCodRetCsl
	//³ Gera o lancamento de CSLL no PCO ³
	PCODetLan("000002","12","FINA050")
EndIf

//Refaz os valores de PIS/COFINS/CSLL, quando aglutinados em um unico TX.
If SuperGetMv("MV_AG10925",.F.,"2") == "1" .And. cCodRetPis == "5952"
	nValPis -= nRefCof + nRefCsl
	nValCsll := nRefCsl
	nValCofins := nRefCof
EndIf
RestArea(aAreaSE2)
RestArea(aArea)

Return lRet

/*/
±±³Fun‡…o	 ³ F050GrvSFQ ³ Autor ³ Totvs               ³ Data ³ 05/11/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Pesquisar titulos pendentes de retenção paa Fornecedor     ³±±
±±³          ³ periodo(ex.E2_PRETPIS ="1"), gravar o relacionamento(SFQ)  ³±±
±±³          ³ entre o novo retentopr eos titulos pendentes de retenção,  ³±±
±±³          ³ atualizar para retido em outro titulo(ex.E2_PRETPIS ="2")  ³±±
/*/
Function F050GrvSFQ()
Local lRet 	  		:= .F.
Local aAreaSE2 	:= SE2->(GetArea())
Local aArea   		:= GetArea()
Local nRegSe2     := SE2->(RECNO())
Local cNomeFor    := SE2->E2_NOMFOR
Local cFornece    := SE2->E2_FORNECE
Local nValPisT  	:= nPisOri//SE2->E2_PIS
Local nValCofinsT := nCofOri//SE2->E2_COFINS
Local nValCsllT   := nCslOri//SE2->E2_CSLL
Local cPrefOri		:=	SE2->E2_PREFIXO
Local cNumOri		:=	SE2->E2_NUM
Local cParcOri		:=	SE2->E2_PARCELA
Local cTipoOri		:=	SE2->E2_TIPO
Local cCfOri		:=	SE2->E2_FORNECE
Local cLojaOri   	:= SE2->E2_LOJA
Local	dDtSeek		:=	SE2->E2_VENCREA
Local dDataAcm		:=	SE2->E2_VENCREA
Local dFirstDay 	:= FirstDay(dDataAcm)
Local dLastDay   	:= LastDay(dDataAcm)
Local nLastDay   	:=	0
Local nX          := 0
Local nTamData    := 0

dbGoTop()
dbSetOrder(3)  //Filial+Dt.VENCREA+NomeForn
nLastDay := Day(LastDay(SE2->E2_VENCREA))
nTamData := Iif(Len(Dtoc(SE2->E2_VENCREA)) == 10, 7, 5)

For nX := 1 to nLastDay
	dDtSeek := DTOS(CTOD(STRZERO(nX)+"/"+Subs(DTOC(dDataAcm),4,nTamData)))
	///Pesquisa todos titulos pendentes de retenção(ex.E2_PRETPIS='1') para o novo periodo deste titulo e seu fornecedor
	If dbSeek(xFilial("SE2")+dDtSeek+cNomeFor,.T.)
		//Encontrou a primeira ocorrencia de titulo para o fornecedor
		//A partir deste titulo ele vai acumulando todos os que tiverem dentro do range de datas
		While !Eof() .and. xFilial("SE2") == E2_FILIAL .and.	E2_NOMFOR == cNomeFor .and. ;
		(E2_VENCREA >= dFirstDay .and. E2_VENCREA <= dLastDay)


			If E2_FORNECE+E2_LOJA 	== 	cFornece+cLojaOri  	.And. ;
			SE2->E2_PRETPIS   	== 	'1' 						.And. ;
			nRegSe2					<>		SE2->(RECNO())
				nValPisT 		  		+= 	SE2->E2_PIS
				nValCofinsT				+= 	SE2->E2_COFINS
				nValCsllT  				+= 	SE2->E2_CSLL
				//Atualiza Situação de Retenção do titulo Retido
				RecLock("SE2")
				Replace E2_PRETPIS 	With 	'2'
				Replace E2_PRETCOF 	With 	'2'
				Replace E2_PRETCSL 	With 	'2'
				MsUnLock()
				FKCOMMIT()
				//Grava Relacionamento(SFQ)
				dbSelectArea("SFQ")
				RecLock("SFQ",.T.)
				SFQ->FQ_FILIAL  		:= 	xFilial("SFQ")
				SFQ->FQ_ENTORI  		:= 	"SE2"
				SFQ->FQ_PREFORI 		:= 	cPrefOri
				SFQ->FQ_NUMORI  		:= 	cNumOri
				SFQ->FQ_PARCORI 		:= 	cParcOri
				SFQ->FQ_TIPOORI 		:= 	cTipoOri
				SFQ->FQ_CFORI   		:= 	cCfOri
				SFQ->FQ_LOJAORI 		:= 	cLojaOri
				SFQ->FQ_FILDES			:=  SE2->E2_FILIAL
				SFQ->FQ_ENTDES  		:= 	"SE2"
				SFQ->FQ_PREFDES 		:= 	SE2->E2_PREFIXO
				SFQ->FQ_NUMDES  		:= 	SE2->E2_NUM
				SFQ->FQ_PARCDES 		:= 	SE2->E2_PARCELA
				SFQ->FQ_TIPODES 		:= 	SE2->E2_TIPO
				SFQ->FQ_CFDES   		:= 	SE2->E2_FORNECE
				SFQ->FQ_LOJADES 		:= 	SE2->E2_LOJA
				Msunlock()
				lRet 	  					:= 	.T.
			EndIf
			SE2->(dbSkip())
		Enddo
	EndIf
Next

RestArea(aAreaSE2)
RestArea(aArea)

SE2->E2_VRETPIS	:=		nValPisT
SE2->E2_VRETCOF	:=		nValCofinsT
SE2->E2_VRETCSL	:=		nValCsllT

Return lRet

/*/
±±³Fun‡…o	 ³ F050AltPCC ³ Autor ³ Totvs               ³ Data ³ 05/11/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Pesquisar titulos retidos para Fornecedor no periodo antigo³±±
±±³          ³ (anterior a alteração), sem SFQ gravado(ex.E2_PRETPIS =" ")³±±
±±³          ³ atualizar a situação para pendente de retenção e excluir   ³±±
±±³          ³ os impostos PCC respectivos a ele                          ³±±
/*/
Function F050AltPCC()
Local lRet 	  		:= .F.
Local aAreaSE2 	:= SE2->(GetArea())
Local aArea   		:= GetArea()
Local nRegSe2     := SE2->(RECNO())
Local cNomeFor    := SE2->E2_NOMFOR
Local cFornece    := SE2->E2_FORNECE
Local cLojaOri   	:= SE2->E2_LOJA
Local	dDtSeek		:=	dOldVencRe
Local dDataAcm		:=	dOldVencRe
Local dFirstDay 	:= FirstDay(dDataAcm)
Local dLastDay   	:= LastDay(dDataAcm)
Local nLastDay   	:=	0
Local nX          := 0
Local nTamData    := 0

dbGoTop()
dbSetOrder(3)  //Filial+Dt.VENCREA+NomeForn
nLastDay := Day(LastDay(dOldVencRe))
nTamData := Iif(Len(Dtoc(dOldVencRe)) == 10, 7, 5)

For nX := 1 to nLastDay
	dDtSeek := DTOS(CTOD(STRZERO(nX)+"/"+Subs(DTOC(dDataAcm),4,nTamData)))
	///Pesquisa todos titulos pendentes de retenção(ex.E2_PRETPIS='1') para o novo periodo deste titulo e seu fornecedor
	If dbSeek(xFilial("SE2")+dDtSeek+cNomeFor,.T.)
		//Encontrou a primeira ocorrencia de titulo para o fornecedor
		//A partir deste titulo ele vai acumulando todos os que tiverem dentro do range de datas
		While !Eof() .and. xFilial("SE2") == E2_FILIAL .and.	E2_NOMFOR == cNomeFor .and. ;
		(E2_VENCREA >= dFirstDay .and. E2_VENCREA <= dLastDay)


			If E2_FORNECE+E2_LOJA == cFornece+cLojaOri  	.And. ;
			SE2->E2_PRETPIS   	== 	' ' 				.And. ;
			nRegSe2		  			<>		SE2->(RECNO())
				//Atualiza Situação de Retenção do titulo Retido
				RecLock("SE2")
				Replace E2_VALOR     With  SE2->(E2_VALOR + E2_VRETPIS + E2_VRETCOF + E2_VRETCSL )
				Replace E2_SALDO     With  SE2->(E2_SALDO + E2_VRETPIS + E2_VRETCOF + E2_VRETCSL )
				Replace E2_VRETPIS 	With 	0
				Replace E2_VRETCOF 	With 	0
				Replace E2_VRETCSL 	With 	0
				Replace E2_PRETPIS 	With 	'1'
				Replace E2_PRETCOF 	With 	'1'
				Replace E2_PRETCSL 	With 	'1'
				MsUnlock()
				FKCOMMIT()
				//Exclui Impostos PCC
				F050DelPCC()
			EndIf
			dbSkip()
		Enddo
	EndIf
Next

RestArea(aAreaSE2)
RestArea(aArea)

Return lRet

/*/
±±³Fun‡…o	 ³ FRetOTits ³ Autor ³ Adrianne Furtado    ³ Data ³ 23/12/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se o título ATUAL que está sendo ALTERADO, reteve ³±±
±±³          ³ impostos referentes a outro título em sua INCLUSÃO         ³±±
/*/
Function FRetOTits(nValInss)
Local aAreaSFQ := SFQ->(GetArea())
Local aAreaSE2 := SE2->(GetArea())
//valor que esse titulo reteve referente a outro(s) titulo(s)a
Local nDifer := 0

//SOMENTE EFETUARÁ O CALCULO SE FOR ALTERAÇÃO DO TITULO
If FwIsInCallStack("AxAltera") .and. Funname() == "FINA050"
	SE2->(DBSetOrder(1))
	SFQ->(DbSetOrder(1))
	SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
	While SFQ->(FQ_ENTORI+FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI) == ;
	"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)

		If AllTrim(SFQ->FQ_TPIMP) == "INS"
			SE2->(DBSeek(xFilial("SE2")+SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)))
			nDifer += SE2->E2_VRETINS
		EndIf
		SFQ->(DbSkip())
	EndDo
	nValInss += nDifer
EndIf

RestArea(aAreaSFQ)
RestArea(aAreaSE2)
Return nValInss


/*/
±±³Fun‡…o	 ³F050BSIMP ³ Autor ³ Mauricio Pequim Jr	  ³ Data ³ 12/04/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verificacao do uso de base diferenciada para impostos		  ³±±
/*/
Function F050BSIMP(nOpcao,nImposto)

Local lRet 		:= .F.
Local lSE2Ok 	:= .F.
Local aArea		:= GetArea()
Local cCondImp	:= ".T."
Local lSimples	:= cPaisLoc == "BRA" .and. SA2->A2_CALCIRF == "3"
Local lApura	:= cPaisLoc == "BRA"

//NAO TRANSFORME ESTA VARIAVEL EM LOCAL
//ELA SERA MACRO-EXECUTADA
PRIVATE lCposImp := cPaisLoc == "BRA"

lIrProg := IIf(cPaisLoc == "BRA",IIf(!Empty(SA2->A2_IRPROG),SA2->A2_IRPROG,"2"),"2")

DEFAULT nOpcao := 1  // 1 = Vericar campos e calculo dos impostos; 2 = Verificar apenas existencia dos campos
DEFAULT nImposto := 0  // 0 = Vericacao Geral

If nOpcao == 1
	//Se existirem os campos de base de impostos
	//Verifica se o cliente e a natureza calcula impostos
	cCondImp := 'lCposImp .and. cPaisLoc == "BRA" .and. SED->(MsSeek(xFilial("SED")+M->E2_NATUREZ))'
	lSe2Ok := !Empty(M->E2_NATUREZ) .and. !EMPTY(M->E2_FORNECE)
ElseIf nOpcao == 2
	//Se existirem os campos de base de impostos
	lRet := lCposImp
	lSe2Ok := .F.
ElseIf nOpcao == 3
	//Verifica apenas se calcula algum dos impostos (Desdobramento)
	lCposImp := .T.
	lSe2Ok := .T.
Endif

If lCposImp .and. lSe2Ok .and. &cCondImp

	Do Case

		Case nImposto == 1		//Irrf

		If SED->ED_CALCIRF == "S" .And. !lSimples
			//IRRF Pessoa Fisica na Baixa
			If	(SA2->A2_TIPO == 'F' .OR. (SA2->A2_TIPO == "J" .AND. lIrProg == "1"))
				lRet := F050BIRPF(nOpcao)
			Else
				//IRRF Juridica
				lRet := .T.
			Endif
		Endif

		Case nImposto == 2		//PIS
		If (SED->ED_CALCPIS == "S" .and. SA2->A2_RECPIS $ "2") .or. (lApura .and. SED->ED_PCAPPIS > 0) //ESTE ITEM É PROVISORIO PARA O SPED PIS COF
			lRet := .T.
		Endif

		Case nImposto == 3		//COFINS
		If (SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI $ "2") .or. (lApura .and. SED->ED_PCAPCOF > 0) //ESTE ITEM É PROVISORIO PARA O SPED PIS COF
			lRet := .T.
		Endif

		Case nImposto == 4		//CSLL
		If	(SED->ED_CALCCSL == "S" .and. SA2->A2_RECCSLL $ "2")
			lRet := .T.
		Endif

		Case nImposto == 5		//INSS

		If	(SED->ED_CALCINS == "S" .And. SA2->A2_RECINSS == "S")
			lRet := .T.
		Endif

		Case nImposto == 6		//ISS

		If (SED->ED_CALCISS == "S" .And. SA2->A2_RECISS == "N")
			lRet := .T.
		Endif

		//Verifica se algum imposto eh calculado
		//Utilizado para verificar se o desdobramento sera feito por rotina automatica e calcular impostos
		//Ou utilizar a rotina padrao
		Case nImposto == 7

		//IRRF
		If SED->ED_CALCIRF == "S" .And. !lSimples
			//IRRF Pessoa Fisica na Baixa
			If	(SA2->A2_TIPO == 'F' .OR. (SA2->A2_TIPO == "J" .AND. lIrProg == "1")) .AND. SA2->A2_CALCIRF == '2'
				lRet := F050BIRPF(nOpcao)
			Else
				//IRRF Juridica
				lRet := .T.
			Endif
		Endif

		//COFINS
		If !lRet .and. (SED->ED_CALCPIS == "S" .and. SA2->A2_RECPIS $ "2")
			lRet := .T.
		Endif

		//COFINS
		If !lRet .and. (SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI $ "2")
			lRet := .T.
		Endif

		//CSLL
		If	!lRet .and. (SED->ED_CALCCSL == "S" .and. SA2->A2_RECCSLL $ "2")
			lRet := .T.
		Endif

		//INSS
		If	!lRet .and. (SED->ED_CALCINS == "S" .And. SA2->A2_RECINSS == "S")
			lRet := .T.
		Endif

		//ISS
		If !lRet .and. (SED->ED_CALCISS == "S" .And. SA2->A2_RECISS == "N")
			lRet := .T.
		Endif


	END CASE

Endif

RestArea(aArea)

Return lRet

/*/
±±³Fun‡…o	 ³F050IMPAUT³ Autor ³ Mauricio Pequim Jr	  ³ Data ³ 12/04/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se os impostos foram informados no array da rotina³±±
±±³          ³ automatica ou se devem ser calculados normalmente.         ³±±
/*/
Function F050ImpAut(cImposto)

Local nI := 0
Local nT := 0
Local lRet := .F.

aAutoCab := If(Type("aAutoCab") != "A",{},aAutoCab)
DEFAULT cImposto := ""

//Base Impostos diferenciada
If Len(aAutoCab) > 0

	//Verifico se algum imposto foi enviado no array aRotAuto
	//Significa que o imposto foi preh calculado e não deve ser calculado novamente
	IF !Empty(cImposto) .and. (nT := ascan(aAutoCab,{|x| Alltrim(x[1]) == cImposto}) ) > 0
		lRet := .T.
	Endif

Endif

Return (lRet)

/*/
±±³Fun‡…o	 ³F050BIRPF ³ Autor ³ Mauricio Pequim Jr	  ³ Data ³ 20/05/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verificacao do uso do campo E2_BASEIRF - IRPF BAIXA		  ³±±
/*/
Function F050BIRPF(nOpcao)

Local lRet := .F.
Local lSE2Ok := .F.
Local aArea	:= GetArea()
Local lBaseIRPF	:= cPaisLoc == "BRA"
Local cChaveSA2 := ""

DEFAULT nOpcao := 1  // 1 = Inclusão, Alteracao. 2 = Baixa 3= Bordero, manutencao de bordero

lIrProg := IIf(cPaisLoc == "BRA",IIf(!Empty(SA2->A2_IRPROG),SA2->A2_IRPROG,"2"),"2")

If nOpcao == 1 .OR. nOpcao == 2
	dbSelectArea("SA2")
	SA2->(dbSetOrder(1))
	If nOpcao == 1
		cChaveSA2 := xFilial("SA2") + M->E2_FORNECE + SPACE(TamSx3("E2_FORNECE")[1] - LEN(M->E2_FORNECE))+;
		M->E2_LOJA + SPACE(TamSx3("E2_LOJA")[1] - LEN(M->E2_LOJA))
		SA2->(dbSeek(cChaveSA2))
	Else
		SA2->(dbSeek(xFilial("SA2") + SE2->(E2_FORNECE + E2_LOJA)))
	Endif
	If !SA2->(Eof())
		lIrProg := IIf(cPaisLoc == "BRA",IIf(!Empty(SA2->A2_IRPROG),SA2->A2_IRPROG,"2"),"2")
	Endif
Endif
If nOpcao == 1
	lSe2Ok := !Empty(M->E2_NATUREZ) .and. !EMPTY(M->E2_FORNECE)
	If lBaseIrpf .and. lSe2Ok .and. cPaisLoc == 'BRA' .AND. ( nModulo == 6 .Or. lF050Auto) .AND. ;
	SED->(MsSeek(xFilial("SED")+M->E2_NATUREZ)) .AND. ;
	SED->ED_CALCIRF == 'S' .AND. ;
	((SA2->A2_TIPO == 'F' .OR. (SA2->A2_TIPO == "J" .AND. lIrProg == "1")) .AND. SA2->A2_CALCIRF == '2')
		lRet := .T.
	Endif
ElseIf nOpcao == 2
	lSe2Ok := !Empty(SE2->E2_NATUREZ) .and. !EMPTY(SE2->E2_FORNECE)
	If lBaseIrpf .and. lSe2Ok .and. cPaisLoc == 'BRA' .and. nModulo == 6
		lRet := .T.
	Endif
ElseIf nOpcao == 3
	If lBaseIrpf .and. cPaisLoc == 'BRA' .and. nModulo == 6 .AND. SED->ED_CALCIRF == 'S' .AND. ;
	((SA2->A2_TIPO == 'F' .OR. (SA2->A2_TIPO == "J" .AND. lIrProg == "1")) .AND. SA2->A2_CALCIRF == '2')
		lRet := .T.
	Endif
Endif

RestArea(aArea)

Return lRet

/*/
±±³Fun‡…o	 ³ Fa050Agend ³ Autor ³ José Lucas          ³ Data ³ 11/02/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Altera a Data de Agendamento do Título.                    ³±±
/*/
Function Fa050Agend()
LOCAL aArea      := GetArea()
LOCAL dDataAgend := CTOD("")

LOCAL nOpca      := 0
LOCAL cTitulo	 := OemToAnsi(STR0170)		//"Alteração no agendamento."
LOCAL cSequencia := "000000"
LOCAL lGravaLog  := GetNewpar( "MV_CTBLGET" , .F. )
Local lRet		 := .T.

PRIVATE aSE2FI2	 := {}
PRIVATE _Opc     := 4

// Validação Siafi
If FinTemDH()
	lRet := .F.
Endif

If lRet

	dDataAgend := IIF(EMPTY(SE2->E2_DATAAGE),SE2->E2_VENCREA,SE2->E2_DATAAGE)

	DbSelectArea("FI2")

	DEFINE MSDIALOG oDlg TITLE cTitulo FROM 00,00 TO 150,500 OF oMainWnd PIXEL


	@ 035, 035 MSGET OemToAnsi(STR0171) 			SIZE 090,10 OF oDlg PIXEL WHEN .F.
	@ 035, 124 MSGET oDataAge  	VAR dDataAgend		SIZE 090,10 PICTURE "@D" VALID Fa050VAge(dDataAgend)	OF oDlg PIXEL

	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,if(Fa050AOk(oDlg),nOpca:=1,nOpca := 0)},{||oDlg:End()}) CENTERED

	If nOpcA == 1
		//³ Grava a Data de Agendamento.                        ³
		If lGravaLog
			cSequencia := Fa050GetSq(SE2->E2_NUMBOR,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
			AADD(aSE2FI2,{cSequencia,"ALTERAÇÃO NA DATA DE AGENDAMENTO",Trans(SE2->E2_DATAAGE,"@D 99/99/99"),Trans(dDataAgend,"@D 99/99/99"),"E2_DATAAGE","D"})
		EndIf
		RecLock("SE2",.F.)
		SE2->E2_DATAAGE := dDataAgend
		MsUnLock()

		If Len(aSE2FI2) > 0 .and. lGravaLog
			//³ Efetua a gravacao do Histórico de Agendamentos.     ³
			F050GrvFI2(lGravaLog)
		EndIf
	EndIf
	RestArea( aArea )

Endif

Return

/*/
±±³Fun‡…o	 ³ Fa050VAge()³ Autor ³ José Lucas          ³ Data ³ 11/02/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Validar a digitação da Data de Agendamento.                ³±±
/*/
Function Fa050VAge(dDataAgend)
LOCAL lRet 		:= .T.

If dDataAgend < SE2->E2_EMISSAO
	MsgAlert("Data de agendamento dever ser maior ou igual a data da Emissão.","Atenção!")
	lRet := .F.
EndIf
Return( lRet )

/*/
±±³Fun‡…o	 ³ Fa050AOk()³ Autor ³ José Lucas          ³ Data ³ 11/02/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Validar e fechar Dialogo da caixa de edição da data de 	  ³±±
±±³          ³ Agendamento.                                           	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpL := Fa050VAge(oObj)			            			  ³±±
/*/
Function Fa050AOk(oDlg)
LOCAL lRet := .T.
oDlg:End()
Return( lRet )

/*/
±±³Fun‡…o	 ³ Fa050GetSq()³ Autor ³ José Lucas         ³ Data ³ 11/02/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retornar o próximo numero sequencial para gravação do Log  ³±±
±±³          ³ com base na existencia do Título.                       	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpN := Fa050GetSq(cNumBor,cPrefixo,cTitulo,cParcela,	  ³±±
±±³ 		 ³ cTipo,cFornece,cLoja).									  ³±±
/*/
Function Fa050GetSq(cNumBor,cPrefixo,cTitulo,cParcela,cTipo,cFornece,cLoja)
Local aArea			:= GetArea()
Local cQuery		:= ""
Local cSequencia	:= "000000"

If Select("QRYFI2") > 0
	QRYFI2->(DbCloseArea())
EndIf

If TcGetDb() $ "INFORMIX*ORACLE"
	cQuery := "SELECT NVL(MAX(FI2_SEQ),'0') MAXSEQ FROM "
ElseIf  TcGetDb() $ "DB2*POSTGRES"  .OR. ( TcGetDb() == "DB2/400" .And. Upper(TcSrvType()) == "ISERIES" )
	cQuery := "SELECT COALESCE(MAX(FI2_SEQ),'0') MAXSEQ FROM "
Else
	cQuery := "SELECT ISNULL(MAX(FI2_SEQ),'0') MAXSEQ FROM "
EndIf

cQuery += RetSqlName("FI2") + " FI2 "
cQuery += " WHERE"
cQuery += " FI2_FILIAL = '" + xFilial("FI2") + "' "
cQuery += " AND FI2_CARTEI = '2' "
cQuery += " AND FI2_NUMBOR = '" + cNumBor + "' "
cQuery += " AND FI2_PREFIX = '" + cPrefixo + "' "
cQuery += " AND FI2_TITULO = '" + cTitulo + "' "
cQuery += " AND FI2_PARCEL = '" + cParcela + "' "
cQuery += " AND FI2_TIPO = '" + cTipo + "' "
cQuery += " AND FI2_CODFOR = '" + cFornece + "' "
cQuery += " AND FI2_LOJFOR = '" + cLoja + "' "
cQuery += " AND FI2_GERADO = '2' "
cQuery += " AND D_E_L_E_T_ <> '*' "

cQuery := ChangeQuery(cQuery)

dbUseArea( .T., "TOPCONN", TCGenQry(,,cQuery), 'QRYFI2', .F., .T.)

QRYFI2->(dbGoTop())
If QRYFI2->(!Eof())
	cSequencia := PadL(AllTrim(QRYFI2->MAXSEQ), TamSX3("FI2_SEQ")[1], "0")
EndIf
QRYFI2->(DbCloseArea())

cSequencia := Soma1(cSequencia)

RestArea(aArea)

Return(cSequencia)

/*/
±±³Funcao    ³F050VlAdFoLj³ Autor ³Totvs                ³ Data ³20.05.2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±ºDescricao ³ Valida fornecedor e loja para titulo de adiantamento de    º±±
±±º          ³ pedido de compra ou documento de entrada.                  º±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se validou a condicao                         ³±±
/*/
Function F050VlAdFoLj()

Local lOk := .T.

If FunName() = "MATA121"
	If Type("cA120Forn") != "U" .and. Type("cA120Loj") != "U"
		If M->E2_FORNECE+M->E2_LOJA != cA120Forn+cA120Loj
			lOk := .F.
		Endif
	Endif
Elseif FunName() = "MATA103"
	If Type("cA100For") != "U" .and. Type("cLoja") != "U"
		If M->E2_FORNECE+M->E2_LOJA != cA100For+cLoja
			lOk := .F.
		Endif
	Endif
Endif

If !lOk
	Aviso(STR0115,STR0166,{ "Ok" }) //"ATENCAO"#"Por tratar-se de título para processo de adiantamento, é obrigatório que o código do fornecedor e loja sejam os mesmos do 'Pedido de Compra/Documento de Entrada'."
Endif

Return lOk

/*/
±±³Fun‡…o	 ³f050CvtMoe³ Autor ³               		  ³ Data ³ 26/07/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Ajusta valor do titulo em reais (gatilho campo E2_TXMOEDA)  ³±±
/*/
Function F050CvtMoe()

Local nValor := 0
lAltTxMoeda	:= .F.

If M->E2_MOEDA >1 .And. nOldTxMoeda <> M->E2_TXMOEDA
	lAltTxMoeda := .T.
	//recalcula conversao de moeda conforme taxa	
	Fa050Nat2()
	FA050VALOR()
EndIf
If ( cPaisLoc == "CHI" )
	nValor :=Round( xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,3,M->E2_TXMOEDA), MsDecimais(1) )
Else
	nValor :=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,3,M->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
Endif
nOldTxMoeda := M->E2_TXMOEDA
lAltTxMoeda := .F.

Return nValor

/*
±±ºPrograma  ³Fa50VendorºAutor  ³Clovis Magenta      º Data ³  18/08/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Função que validará se o título foi gerado por uma baixa   º±±
±±º          ³ automatica do tipo VENDOR. Caso positivo, podera ser 	     º±±
±±º          ³ deletado, igual ao processo da baixa manual por VENDOR.    º±±
*/
Function Fa50Vendor()
Local lDelete 	 := .F.
Local lBxAutVen := SuperGetMv("MV_BXAUTVE",.T.,.F.)
Local aArea := GetArea()

If lBxAutVen .and. Alltrim(SE2->E2_ORIGEM) == "FINA090" .and. Alltrim(SE2->E2_NATUREZ) == "VENDOR"
	lDelete := .T.
Endif

RestArea(aArea)

Return lDelete

/*
±±ºPrograma  ³isFunruralºAutor  ³Clovis Magenta      º Data ³  02/07/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Função que verifica se o fornecedor é FUNRURAL e se é consi-º±±
±±º          ³derado para o calculo diferenciado para MP447 - INSS        º±±
*/
STATIC Function isFunrural()
Local lRural := .F.
Local aAreaSE2 := SA2->(GetArea())
Local cOrigem  := FunName()

dbSelectArea("SA2")
dbSetOrder(1)
If Alltrim(cOrigem) == "FINA050" .OR. Type("M->E2_FORNECE")<>"U"
	DbSeek(xFilial("SA2")+M->E2_FORNECE+M->E2_LOJA)
Elseif Alltrim(cOrigem) == "MATA103"
	DbSeek(xFilial("SA2")+SF1->(F1_FORNECE+F1_LOJA))
Endif
If Alltrim(SA2->A2_TIPORUR)$"L|F"
	lRural := .T.
Endif

RestArea(aAreaSE2)

Return lRural

/*
±±ºPrograma  ³ Fa050VldPai ºAutor ³ Gustavo Henrique º Data ³  03/09/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Realiza as validacoes para identificar o titulo pai        º±±
*/
Static Function Fa050VldPai( cPrefixo, cNum, cParcela, cTipoPai, cFornece, cMunic, cParcPai, cValorPai, cNatureza )

Local nX         := 0
Local lAchou     := .F.
Local aNaturezas := {}
Local aValorPai  := {}
Local aParcelas  := {}

If ( cTipoPai $ MVTAXA + "/" + MVTXA ) .And. cFornece <> cMunic

	aParcelas 	:= { SE2->E2_PARCPIS, SE2->E2_PARCCOF, SE2->E2_PARCSLL, SE2->E2_PARCIR }
	aValorPai	:= { SE2->E2_PIS    , SE2->E2_COFINS , SE2->E2_CSLL   , SE2->E2_IRRF   }
	aNaturezas	:= { GetMv("MV_PISNAT"), GetMv("MV_COFINS"), GetMv("MV_CSLL"), &( GetMv("MV_IRF") ) }

	nPosParc	:= aScan( aParcelas, cParcela )

	If nPosParc > 0 .And. Iif( cTipoPai $ MVTXA, SE2->E2_TIPO $ MVPAGANT + "/" + MV_CPNEG, .T. )

		If aValorPai[nPosParc] != 0 .And. Upper( AllTrim( cNatureza ) ) $ Upper( AllTrim( aNaturezas[nPosParc] ) )
			lAchou := .T.
		EndIf

	EndIf

Else

	If &(cParcPai) == cParcela .and. IIF(cTipoPai $ MVTXA,SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,.T.)
		If &(cValorPai) != 0
			lAchou := .T.
		EndIf
	EndIf

EndIf

Return lAchou

/*/
±±³Fun‡…o	 ³Fa050GetCC³ Autor ³ Lucas			 	    ³ Data ³ 18/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Obter os dados do Cartão de Credito.						  ³±±
/*/
Function Fa050GetCC(lSE2)
Local aArea  	 := GetArea()
Local nOpca  	 := 0
Local aSize  	 := MSADVSIZE()
Local cCodAdm 	 := CriaVar("FRC_CODADM")
Local cNumCartao := CriaVar("FRC_NUMCAR")
Local cNomeAdm   := CriaVar("AE_DESC")
Local cValidade  := Space(4)
Local cCodSeg 	 := CriaVar("FRC_CODSEG")
Local aParcelas  := {"01"} //,"02","03","04","05","06","07","08","09","10","11","12"}
Local cParcela   := "01"
Local aPicture   := Array(4)
Local oCbxParc
Local oDlgCC
Local nOpc 		 := 0
Local aTitulos   := {}

aPicture[1] := PesqPict("FRC","FRC_CODADM", TamSX3("FRC_CODADM"))
aPicture[2] := PesqPict("FRC","FRC_NUMCAR", TamSX3("FRC_NUMCAR"))
aPicture[3] := PesqPict("SAE","AE_DESC"   , TamSX3("AE_DESC"))
aPicture[4] := PesqPict("FRC","FRC_CODSEG", TamSX3("FRC_CODSEG"))

dbSelectArea("FRC")

DEFINE MSDIALOG oDlgCC TITLE STR0172 From aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL // "Informe Dados do Cartão de Credito"

@ 027,010 SAY STR0173	PIXEL OF oDlgCC COLOR CLR_HBLUE // "Administradora"
@ 025,060 MSGET cCodAdm F3 "SAE" Picture aPicture[1] SIZE 40,08		Valid Fa050CodAdm(cCodAdm,@cNomeAdm)		PIXEL OF oDlgCC
@ 025,120 MSGET cNomeAdm         Picture aPicture[3] SIZE 170,08		PIXEL OF oDlgCC WHEN .F.

@ 042,010 SAY STR0174	PIXEL OF oDlgCC COLOR CLR_HBLUE // "Numero do Cartão"
@ 040,060 MSGET cNumCartao		 Picture aPicture[2] SIZE 120,08 	Valid Fa050NumCart(cNumCartao)	PIXEL OF oDlgCC

@ 057,010 SAY STR0175	PIXEL OF oDlgCC COLOR CLR_HBLUE // "Validade"
@ 055,060 MSGET cValidade		 Picture "@R 99/99"	 SIZE 30,08 	Valid Fa050Valid(cValidade)		PIXEL OF oDlgCC

@ 072,010 SAY STR0176	PIXEL OF oDlgCC
@ 070,060 MSGET cCodSeg			 Picture aPicture[4] SIZE 30,08 Valid Fa050CodSeg()					PIXEL OF oDlgCC
@ 070,100 SAY STR0177	PIXEL OF oDlgCC

@ 087,010 SAY STR0178 	 PIXEL OF oDlgCC
@ 085,060 MSCOMBOBOX oCbxParc  VAR cParcela		ITEMS aParcelas SIZE 60, 54 WHEN !lSE2	PIXEL OF oDlgCC	//ON CHANGE (nMoedSubs := Val(Substr(cMoeda,1,2)))

ACTIVATE MSDIALOG oDlgCC ON INIT EnchoiceBar(oDlgCC,{|| If(fa050Ok(),(nOpca := 1,oDlgCC:End()),NIL)},{|| nOpca := 2,oDlgCC:End()})

//Gravar titulos em um array para posterior substituição.
If nOpca == 1
	If lSE2
		nPosicao := Ascan(aTitulos, { |x| x[1]+x[2]+x[3]+[4] == SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO })
		If nPosicao == 0
			AADD(aTitulos,{SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,cCodAdm,cNumCartao,cValidade,cCodSeg,cParcela})
		Else
			aTitulos[nPosicao][1]:= SE2->E2_PREFIXO
			aTitulos[nPosicao][2]:= SE2->E2_NUM
			aTitulos[nPosicao][3]:= SE2->E2_PARCELA
			aTitulos[nPosicao][4]:= SE2->E2_TIPO
			aTitulos[nPosicao][5]:= cCodAdm
			aTitulos[nPosicao][6]:= cNumCartao
			aTitulos[nPosicao][7]:= cValidade
			aTitulos[nPosicao][8]:= cCodSeg
			aTitulos[nPosicao][9]:= cParcela
		EndIf
	Else
		nPosicao := Ascan(aTitulo2CC, { |x| x[1]+x[2]+x[3]+[4] == __SUBS->E2_PREFIXO+__SUBS->E2_NUM+__SUBS->E2_PARCELA+__SUBS->E2_TIPO })
		If nPosicao == 0
			AADD(aTitulo2CC,{__SUBS->E2_PREFIXO,__SUBS->E2_NUM,__SUBS->E2_PARCELA,__SUBS->E2_TIPO,cCodAdm,cNumCartao,cValidade,cCodSeg,cParcela})
		Else
			aTitulo2CC[nPosicao][1]:= __SUBS->E2_PREFIXO
			aTitulo2CC[nPosicao][2]:= __SUBS->E2_NUM
			aTitulo2CC[nPosicao][3]:= __SUBS->E2_PARCELA
			aTitulo2CC[nPosicao][4]:= __SUBS->E2_TIPO
			aTitulo2CC[nPosicao][5]:= cCodAdm
			aTitulo2CC[nPosicao][6]:= cNumCartao
			aTitulo2CC[nPosicao][7]:= cValidade
			aTitulo2CC[nPosicao][8]:= cCodSeg
			aTitulo2CC[nPosicao][9]:= cParcela
		EndIf
	EndIf
Else
	aTitulo2CC := {}
EndIf

RestArea(aArea)
Return( If(lSE2,aTitulos,) )

Function Fa050dValid()
Return .T.

Function Fa050Ok()
Return .T.

/*
±±³Função    ³ Fa050CodAdm()³ Autor ³ José Lucas  	    ³ Data ³ 20/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Validar Codigo da Administradora de Cartão de Credito.     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpL1 := Fa050CodAdm(cCodAdm)	  			              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna	 ³ ExpL1 -> transação efetuada com sucesso ou não			  ³±±
*/
Function Fa050CodAdm( cCodAdm, cNomeAdm )
Local lResult := .T.

If Empty(cCodAdm)
	MsgAlert(STR0179,STR0026)	//"Informe o Codigo da Administradora !" ### Atenção
	lResult := .F.
EndIf
If lResult
	SAE->(dbSetOrder(1))
	If ! SAE->(dbSeek(xFilial("SAE")+cCodAdm))
		MsgAlert(STR0180,STR0026)	//"Administradora de Cartões Invalida !" ### Atenção
		lResult := .F.
	Else
		cNomeAdm := SAE->AE_DESC
	EndIf
EndIf
Return (lResult)

/*
±±³Função    ³ Fa050NumCart()³ Autor ³ José Lucas  	    ³ Data ³ 20/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Verifica se o número do cartão digitado é válido.          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpL1 := Fa050NumCart(cNumCartao)  			              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna	 ³ ExpL1 -> transação efetuada com sucesso ou não			  ³±±
*/
Function Fa050NumCart( cNumCartao )
Local lResult := .T.
If Empty(cNumCartao)
	MsgAlert(STR0181,STR0026)	//"É obrigatório o preenchimento do número do cartão !" ### Atenção
	lResult := .F.
ElseIf Len(AllTrim(cNumCartao))>19
	MsgAlert(STR0182,STR0026)	//"Número do Cartão maior que 19 dígitos !" ### Atenção
	lResult := .F.
EndIf
Return (lResult)

/*
±±³Função    ³ Fa050dValid()³ Autor ³ José Lucas  	    ³ Data ³ 20/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Verifica se o número do cartão digitado é válido.          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpL1 := Fa050dValid(cValid)		  			              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna	 ³ ExpL1 -> transação efetuada com sucesso ou não			  ³±±
*/
Function Fa050Valid( cValid )
Local lResult := .T.
Local dValid  := CTOD("")

//LastDay(dDataBase)+"/"+Subs(cValid,1,2)+"/"+Subs(cValid,3,2)

If Empty(cValid)
	MsgAlert(STR0183,STR0026)	//"É obrigatório o preenchimento do validade do cartão !" ### Atenção
	lResult := .F.
EndIf
If lResult
	//Consistir mes e ano de validade do cartão.
	If Subs(cValid,1,2) < "01" .or. Subs(cValid,1,2) > "12"
		MsgAlert(STR0184,STR0026)	//"Mes Informado invalido !" ### Atenção
		lResult := .F.
	EndIf
	If "20"+Subs(cValid,3,2) < StrZero(Year(dDataBase),4)
		MsgAlert(STR0185,STR0026)	//"Ano Informado invalido !" ### Atenção
		lResult := .F.
	EndIf
EndIf
If lResult
	//Consitir mes no mesmo ano da dDataBase.
	If Subs(cValid,1,2) < StrZero(Month(dDatabase),2) .and. "20"+Subs(cValid,3,2) == StrZero(Year(dDataBase),4)
		MsgAlert(STR0186,STR0026)	//"Cartão com validade vencida !" ### Atenção
		lResult := .F.
	EndIf
	//Consitir último dia de validade do cartão, quando mes igual a dDataBase.
	If Subs(cValid,1,2) == StrZero(Month(dDatabase),2)
		dValid := Subs(DTOC(LastDay(dDataBase)),1,2)
		dValid += "/"+Subs(cValid,1,2)+"/"+Subs(cValid,3,2)
		dValid := CTOD(dValid)
		If dValid < dDataBase
			MsgAlert(STR0186,STR0026)	//"Cartão com validade vencida !" ### Atenção
			lResult := .F.
		EndIf
	EndIf
EndIf
Return (lResult)

/*
±±³Função    ³ Fa050CodSeg()³ Autor ³ José Lucas  	    ³ Data ³ 20/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Verifica se o número do cartão digitado é válido.          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpL1 := Fa050CodSeg(cCodSeg)	  			              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna	 ³ ExpL1 -> transação efetuada com sucesso ou não			  ³±±
*/
Function Fa050CodSeg( cCodSeg )
Local lResult := .T.

If Empty(cCodSeg)
	lResult := .T.
EndIf
Return (lResult)

/*
±±³Função    ³ Fa050Tit2CC()³ Autor ³ José Lucas  	    ³ Data ³ 20/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Substituir títulos por títulos contra a Administradora de  ³±±
±±³          ³ Cartão de Credito, mantendo o titulo original baixado.     ³±±
*/
Function Fa050Tit2CC()
Local aArea 	:= GetArea()
Local lResult 	:= .T.
Local lDivide   := GetNewPar("MV_DIVTCC","1") == "1"
Local lEdita    := GetNewPar("MV_EDITCC","1") == "2"
LOCAL cIndex 		:= ""
LOCAL cChave
LOCAL aDeletar 	:= {}
Local lPadrao   := .F.
Local cPadrao   := "533"
Local cArquivo  := ""
Local nHdlPrv   := 0
Local nTotal    := 0
Local lDigita
Local nRecSubs  := 0
LOCAL nHdlLock 	:= 0
LOCAL lInverte 	:= .F.
LOCAL oValor  		:= 0
LOCAL oQtdTit		:= 0
LOCAL oDlg
LOCAL oDlg1
Local nRecSE2 := SE2->(RECNO())
LOCAL aMoedas		:= {}
LOCAL aOutMoed		:= {STR0107,STR0108}	//"1=Nao Considera"###"2=Converte"
LOCAL cOutMoeda	:= "1"
LOCAL cMoeda		:= "1"
Local cSimb
Local nRecno := 0
Local aSize := {}
Local oPanel
Local oPanel2
Local nTotalParc := 0.00
Local nValTotal  := SE2->E2_VALOR
Local nParcela   := 1
Local nValorSE2  := 0.00
Local nCount     := 0
Local nReg       := SE2->(RecNo())
Local lSubsSuces := .F.
Local nC         := 0
Local aCampos    := {}
Local lAtuSldNat := .T.
Local cParcela 	 := GetMV("MV_1DUP")

VALOR 		:= 0
VLRINSTR 	:= 0

If Len(aTitulo2CC) > 0

	For nCount := 1 To Len(aTitulo2CC)

		dbSelectArea("SE2")
		dbSetOrder(1)
		dbSeek(xFilial("SE2")+aTitulo2CC[nCount][1]+aTitulo2CC[nCount][2]+aTitulo2CC[nCount][3]+aTitulo2CC[nCount][4])

		If lDivide .and. aTitulo2CC[nCount][09] <> "01"
			nTotalParc := Val(aTitulo2CC[nCount][09])
		Else
			nTotalParc := 1
		EndIf

		nValTotal  := SE2->E2_VALOR
		nValorSE2  := nValTotal/nTotalParc

		For nParcela := 1 To nTotalParc
			nOpc:=3			 //Inclusao
			lSubst:=.T.
			lSubsSuces := .F.
			If lEdita    	//Abre Enchoice para editar os títulos a Substituir...
				lSubsSuces := FA050Inclu("SE2",nReg,nOpc,,,lSubst) == 1
				//Ajustar Tipo do Título.
				RecLock("SE2",.F.)
				E2_TIPO    := "CC"
				MsUnLock()
			Else
				aCampos := {}
				For nC := 1 To SE2->(FCount())
					If SE2->(FieldName(nC)) == "E2_PARCELA"
						AADD(aCampos,{SE2->(FieldName(nC)),cParcela})
					ElseIf SE2->(FieldName(nC)) == "E2_TIPO"
						AADD(aCampos,{SE2->(FieldName(nC)),"CC"})
					Else
						AADD(aCampos,{SE2->(FieldName(nC)),SE2->(FieldGet(nC))})
					EndIf
				Next nC
				RecLock("SE2",.T.)
				For nC := 1 To Len(aCampos)
					FieldPut(nC,aCampos[nC,2])
				Next nC
				E2_VALOR 	:= nValorSe2
				E2_SALDO 	:= E2_VALOR
				E2_VALLIQ   := E2_VALOR
				If nParcela > 1
					E2_PARCELA := Soma1(cParcela)
				EndIf
				If nParcela == nTotalParc
					E2_VALOR  += (nValTotal-(E2_VALOR*nTotalParc))
					E2_SALDO  := E2_VALOR
					E2_VALLIQ := E2_VALOR
				EndIf
				MsUnLock()
				lSubsSuces := .T.
			EndIf
			If lSubsSuces
				//Incluir registros na tabela de Controle de Títulos a pagar por Cartão de Credito
				dbSelectArea("FRC")
				RecLock("FRC",.T.)
				FRC_FILIAL := xFilial("FRC")
				FRC_DATTEF := dDataBase
				FRC_HORTEF := Subs(Time(),1,5)
				FRC_DOCTEF := "" //Reservado para implementação futura quando localizar e integrar o SigaLoja no Equador
				FRC_AUTORI := "" //Idem.
				FRC_NSUTEF := "" //Idem.
				FRC_STATUS := "01"
				FRC_MOTIVO := ""
				FRC_TIPCAR := "CC"
				FRC_PREFIX := SE2->E2_PREFIXO
				FRC_NUM	   := SE2->E2_NUM
				FRC_PARCEL := SE2->E2_PARCELA
				FRC_TIPO   := SE2->E2_TIPO
				FRC_CODADM := aTitulo2CC[nCount][5]
				FRC_NUMCAR := aTitulo2CC[nCount][6]
				FRC_DATVAL := aTitulo2CC[nCount][7]
				FRC_CODSEG := aTitulo2CC[nCount][8]
				FRC_NUMPAR := nParcela
				FRC_SEQOPE := "1"
				FRC_FORMA  := "CC"	//Substituir por SE4->E4_FORMA
				FRC_VALOR  := SE2->E2_VALOR
				FRC_FORNEC := SE2->E2_FORNECE
				FRC_LOJA   := SE2->E2_LOJA
				If cPaisLoc == "EQU"
					FRC->FRC_PREORI := aTitulo2CC[nCount][1]
					FRC->FRC_NUMORI := aTitulo2CC[nCount][2]
					FRC->FRC_PARORI := aTitulo2CC[nCount][3]
					FRC->FRC_TIPORI := aTitulo2CC[nCount][4]
				EndIf
				MsUnLock()
			EndIf
			lSubst:=.F.
			//Só contabilizar após a gravação da última parcela do Cartão de Credito.
			If nParcela <> nTotalParc
				Loop
			EndIf
			If ( lPadrao )
				//³ Inicializa Lancamento Contabil                                   ³
				nHdlPrv := HeadProva( cLote,;
				"FINA050" /*cPrograma*/,;
				Substr(cUsuario,7,6),;
				@cArquivo )
			EndIf

			//³ Inicializa a gravacao dos lancamentos do SIGAPCO          ³
			PcoIniLan("000002")

			If ! lF050Auto
				dbSelectArea("__SUBS")
				dbGoTop()
				While !Eof()
					If E2_OK == cMarca
						nRecSubs := RecNo()
						dbSelectArea("SE2")
						dbGoto(nRecSubs)
						If ( lPadrao )
							//³ Prepara Lancamento Contabil                                      ³
							If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
								aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
							Endif
							nTotal += DetProva( nHdlPrv,;
							cPadrao,;
							"FINA050" /*cPrograma*/,;
							cLote,;
							/*nLinha*/,;
							/*lExecuta*/,;
							/*cCriterio*/,;
							/*lRateio*/,;
							/*cChaveBusca*/,;
							/*aCT5*/,;
							/*lPosiciona*/,;
							@aFlagCTB,;
							/*aTabRecOri*/,;
							/*aDadosProva*/ )
						EndIf

						dbSelectArea("SE2")
						dbSetOrder(1)
						If dbSeek(xFilial("SE2")+aTitulo2CC[nCount][1]+aTitulo2CC[nCount][2]+aTitulo2CC[nCount][3]+aTitulo2CC[nCount][4])

							//³ Atualizacao dos dados do Modulo SIGAPMS    ³
							If IntePms().AND. !lPmsInt
								PmsWriteFI(2,"SE2")	//Estorno
								PmsWriteFI(3,"SE2")	//Exclusao
							EndIF

							//³ Chama a integracao com o SIGAPCO antes de apagar o titulo ³
							PcoDetLan("000002","01","FINA050",.T.)

							If lF050PROV
								ExecBlock("F050PROV",.F.,.F.)
							Endif
							If lAtuSldNat  .And. SE2->E2_FLUXO == 'S'
								AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
							Endif

							FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
							Reclock("SE2",.F.,.T.)
							dbDelete()
							MsUnlock()
						EndIf
					Endif
					dbSelectArea("__SUBS")
					dbSkip()
				Enddo
			Else
				If ( lPadrao )
					//³ Prepara Lancamento Contabil                                      ³
					If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
						aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
					Endif
					nTotal += DetProva( nHdlPrv,;
					cPadrao,;
					"FINA050" /*cPrograma*/,;
					cLote,;
					/*nLinha*/,;
					/*lExecuta*/,;
					/*cCriterio*/,;
					/*lRateio*/,;
					/*cChaveBusca*/,;
					/*aCT5*/,;
					/*lPosiciona*/,;
					@aFlagCTB,;
					/*aTabRecOri*/,;
					/*aDadosProva*/ )
				EndIf

				dbSelectArea("SE2")
				dbSetOrder(1)
				If dbSeek(xFilial("SE2")+aTitulo2CC[nCount][1]+aTitulo2CC[nCount][2]+aTitulo2CC[nCount][3]+aTitulo2CC[nCount][4])

					If IntePms().AND. !lPmsInt
						//³ Atualizacao dos dados do Modulo SIGAPMS    ³

						PmsWriteFI(2,"SE2")	//Estorno
						PmsWriteFI(3,"SE2")	//Exclusao
					EndIf

					//³ Chama a integracao com o SIGAPCO antes de apagar o titulo ³
					PcoDetLan("000002","01","FINA050",.T.)
					If lAtuSldNat   .And. SE2->E2_FLUXO == 'S'
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, S2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),3)
					Endif

					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					Reclock("SE2",.F.,.T.)
					dbDelete()
					MsUnlock()
				Endif
			EndIf

			//³ Finaliza a gravacao dos lancamentos do SIGAPCO          ³
			PcoFinLan("000002")

			//³ Contabiliza a diferenca               				  ³
			dbSelectArea("SE2")
			nRecSE2 := Recno()
			dbGoBottom()
			dbSkip()
			VALOR := (nValorS - nValorSe2)
			VLRINSTR := VALOR
			If nTotal > 0
				//³ Prepara Lancamento Contabil                                      ³
				//Contabiliza pela variavel VALOR. Nao necessita de controle de flag.
				nTotal += DetProva( nHdlPrv,;
				cPadrao,;
				"FINA050" /*cPrograma*/,;
				cLote,;
				/*nLinha*/,;
				/*lExecuta*/,;
				/*cCriterio*/,;
				/*lRateio*/,;
				/*cChaveBusca*/,;
				/*aCT5*/,;
				/*lPosiciona*/,;
				/*@aFlagCTB*/,;
				/*aTabRecOri*/,;
				/*aDadosProva*/ )
			Endif
			dbSelectArea("SE2")
			dbGoTo(nRecSE2)
			If nTotal > 0
				//³ Envia para Lancamento Contabil							  ³
				If  UsaSeqCor()
					aDiario := {}
					aDiario := {{"SE2",SE2->(recno()),SE2->E2_DIACTB,"E2_NODIA","E2_DIACTB"}}
				Else
					aDiario := {}
				EndIf
				//³ Efetiva Lan‡amento Contabil                                      ³
				RodaProva( nHdlPrv,;
				nTotal )
				cA100Incl( cArquivo,;
				nHdlPrv,;
				3 /*nOpcx*/,;
				cLote,;
				( mv_par01 == 1 ) /*lDigita*/,;
				( mv_par07 == 1 ) /*lAglut*/,;
				/*cOnLine*/,;
				/*dData*/,;
				/*dReproc*/,;
				@aFlagCTB,;
				/*aDadosProva*/,;
				aDiario )
				aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento
			EndIf
		Next nParcela
	Next nCount

	If !Empty(aChaveLbn)
		aEval(aChaveLbn, {|e| UnLockByName(e,.T.,.F.) } ) // Libera Lock
	Endif
	VALOR    := 0
	VLSINSTR := 0
	If Select("__SUBS") > 0
		dbSelectArea("__SUBS")
		dbCloseArea()
		Ferase(cIndex+OrdBagExt())
	Endif
	dbSelectArea("SE2")
	If ! lF050Auto
		RetIndex("SE2")
		dbGoto(nReg)
	EndIf
EndIf

RestArea(aArea)
Return

/*
±±³Função    ³ Fa050GrvFRC()³ Autor ³ José Lucas  	    ³ Data ³ 20/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Substituir títulos por títulos contra a Administradora de  ³±±
±±³          ³ Cartão de Credito, mantendo o titulo original baixado.     ³±±
*/
Function Fa050GrvFRC(aTituloCC)
Local aArea   := GetArea()
Local lAppend := .F.

If Len(aTituloCC) > 0
	//Incluir ou alterar registros na tabela de Controle de Títulos a pagar por Cartão de Credito
	dbSelectArea("FRC")
	dbSetOrder(1)
	If !dbSeek(xFilial("FRC")+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA)
		lAppend := .T.
	Else
		lAppend := .F.
	EndIf
	RecLock("FRC",lAppend)
	FRC_FILIAL := xFilial("FRC")
	FRC_DATTEF := dDataBase
	FRC_HORTEF := Subs(Time(),1,5)
	FRC_DOCTEF := "" //Reservado para implementação futura quando localizar e integrar o SigaLoja no Equador
	FRC_AUTORI := "" //Idem.
	FRC_NSUTEF := "" //Idem.
	FRC_STATUS := "01"
	FRC_MOTIVO := ""
	FRC_TIPCAR := "CC"
	FRC_PREFIX := SE2->E2_PREFIXO
	FRC_NUM	   := SE2->E2_NUM
	FRC_PARCEL := SE2->E2_PARCELA
	FRC_TIPO   := SE2->E2_TIPO
	FRC_CODADM := aTituloCC[Len(aTituloCC)][5]
	FRC_NUMCAR := aTituloCC[Len(aTituloCC)][6]
	FRC_DATVAL := aTituloCC[Len(aTituloCC)][7]
	FRC_CODSEG := aTituloCC[Len(aTituloCC)][8]
	FRC_NUMPAR := 1
	FRC_SEQOPE := "1"
	FRC_FORMA  := "CC"	//Substituir por SE4->E4_FORMA
	FRC_VALOR  := SE2->E2_VALOR
	FRC_FORNEC := SE2->E2_FORNECE
	FRC_LOJA   := SE2->E2_LOJA
	If cPaisLoc == "EQU"
		FRC->FRC_PREORI := aTitulo2CC[nCount][1]
		FRC->FRC_NUMORI := aTitulo2CC[nCount][2]
		FRC->FRC_PARORI := aTitulo2CC[nCount][3]
		FRC->FRC_TIPORI := aTitulo2CC[nCount][4]
	EndIf
	MsUnLock()
EndIf

RestArea(aArea)
Return

/*
±±³Função    ³ Fa050DelFRC()³ Autor ³ José Lucas  	    ³ Data ³ 20/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Apagar titulos do Tipo "CC" na tabela FRC para controle    ³±±
±±³          ³ das operações a receber através de Cartão de Credito.      ³±±
*/
Function Fa050DelFRC(aTituloCC)
Local aArea   := GetArea()

//Excluir registros na tabela de Controle de Títulos a pagar por Cartão de Credito
FRC->(dbSetOrder(1))
If FRC->(dbSeek(xFilial("FRC")+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA))
	If FRC->FRC_STATUS == "01"	//Em analise
		RecLock("FRC",.F.)
		dbDelete()
		MsUnLock()
	EndIf
EndIf

RestArea(aArea)
Return

/*
±±³Função    ³ Fa050Perg5()³ Autor ³ José Lucas  	    ³ Data ³ 20/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Validação pergunta 5 para não permitir gerar				  ³±±
±±³          ³ Cheque p/Anticipo para o Equador, funcionalidade é usada   ³±±
±±³          ³ no Controle de Cheques.									  ³±±
*/
Function Fa050Perg5()
Local aArea := GetArea()
Local lRet  := .T.

If cPaisLoc == "EQU"
	If mv_par05 == 1  //Gera Cheque para Adiantamento (mv_par05 == Sim)
		MsgAlert("Los cheques de anticipo son generados solamente en  el controle de cheques.","Atención")
		lRet := .F.
	EndIf
EndIf

RestArea(aArea)
Return lRet

/*
±±ºPrograma  ³Fa050Drop ºAutor  ³Clovis Magenta      º Data ³  09/11/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao que dropara as tabelas temporarias quando utilizado º±±
±±º          ³ banco de dados postgres                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATA103                                          			  º±±
*/
Function Fa050Drop()
Local lDelTrbIR:= .T.
Local cAglImPJ	 := SuperGetMv("MV_AGLIMPJ",.T.,"1")

//Fecha arquivo temporario
If cAglImPJ != "1" .and. lDelTrbIR .and. !Empty(cArqTmp)
	DELTRBIR(SM0->M0_CODIGO, IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL ),.F.,0,cArqTmp,TCGetDb())
Endif

Return

/*
±±ºPrograma  ³ FA050MCpos º Autor ³ Gustavo Henrique º Data ³  22/11/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Permitir colocar em memoria o conteudo de campos ao        º±±
±±º          ³ selecionar a opcao "Visualizar" do contas a pagar          º±±
*/
Function FA050MCpos()

Local lContrRet := .T.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

//³ Atribuo o valor que realmente foi retido nos campos do PCC ³
//³ para ser apresentado na tela do AxVisual e nao afetar os   ³
//³ titulos de PCC gerados na emissão.                         ³
If cPaisLoc=="BRA" .and. lContrRet .and. !lPccBaixa
	M->E2_PIS    := Iif( Empty(SE2->E2_VRETPIS), SE2->E2_PIS   , SE2->E2_VRETPIS )
	M->E2_COFINS := Iif( Empty(SE2->E2_VRETCOF), SE2->E2_COFINS, SE2->E2_VRETCOF )
	M->E2_CSLL   := Iif( Empty(SE2->E2_VRETCSL), SE2->E2_CSLL  , SE2->E2_VRETCSL )
EndIf

Return .T.

/*/
±±³Fun‡…o	 ³ Fa050Docs³ Autor ³ Andre Lago            ³ Data ³ 21/07/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Efetua manutencao nos documentos                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
/*/
Function Fa050Docs()
LOCAL aArea      	:= GetArea()
LOCAL nOpca      	:= 0
LOCAL cTitulo	 	:= STR0189
Local aHead 		:= {}
Local aCol	 		:= {}
Local cCampos 		:= "FRD_DOCUM,FRD_DESCRI,FRD_RECEB" 		// Campos a serem conciderados
Local nX			:= 0
Local nCols    		:= 0
Local cLinOk		:= "FA050LinFRD()"							// Funcao de validacao da linha do grid (aCols)
Local aAlter    	:= {}                                      	// Campos a serem alterados pelo usuario
Local nFreeze    	:= 000              						// Campos estaticos na GetDados.
Local nMax       	:= 999              						// Numero maximo de linhas permitidas.
Local cFieldOk   	:= "AllwaysTrue"							// Funcao executada na validacao do campo
Local cSuperDel   	:= "AllwaysTrue"          				    // Funcao executada quando pressionada as teclas <Ctrl>+<Delete>
Local cDelOk      	:= "AllwaysTrue"    						// Funcao executada para validar a exclusao de uma linha do aCols
Local aSize
Local aObjects 		:= {}
Local aInfo
Local aPosObj
Local nPosDoc		:= 0
Local nPosRec		:= 0
Local lIgual		:= .F.
Local nY			:= 0
Local lAchou		:= .F.
Local lF050DOCS		:= ExistBlock("F050DOCS")

If SE2->E2_TEMDOCS == "1"
	aSize := MsAdvSize()
	aadd( aObjects, {  30,  70, .T., .T.} )
	aadd( aObjects, {  20, 180, .T., .T., .T. } )
	aInfo := { aSize[1],aSize[2],aSize[3],aSize[4], 0, 0 }
	aPosObj := MsObjSize( aInfo, aObjects )

	DEFINE FONT oBold NAME "Arial" SIZE 0, -13 BOLD
	DEFINE MSDIALOG oDlg TITLE cTitulo FROM aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL
	oDlg:lMaximized := .T.
	oTela     := FWFormContainer():New( oDlg )
	cIdBrowse := oTela:CreateHorizontalBox( 08 )
	cIdRodape := oTela:CreateHorizontalBox( 86 )
	oTela:Activate( oDlg, .F. )

	oPanel1  := oTela:GeTPanel( cIdBrowse )
	oPanel2  := oTela:GeTPanel( cIdRodape )

	@ 008, 015 Say STR0188 + SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) SIZE 190,10 OF oPanel1 PIXEL FONT oBold COLOR CLR_BLUE

	// criar aHeader
	SX3->(dbSetOrder(1))
	SX3->(dbSeek("FRD"))
	While SX3->(!EOF()) .And.  SX3->X3_ARQUIVO == "FRD"
		If X3USO(SX3->X3_USADO) .And.  AllTrim(SX3->X3_CAMPO) $ Alltrim(cCampos) .AND. (cNivel >= SX3->X3_NIVEL)
			aAdd( aHead, { AlLTrim( X3Titulo() ), ; 	// 01 - Titulo
			SX3->X3_CAMPO	, ;		// 02 - Campo
			SX3->X3_Picture	, ;		// 03 - Picture
			SX3->X3_TAMANHO	, ;		// 04 - Tamanho
			SX3->X3_DECIMAL	, ;		// 05 - Decimal
			SX3->X3_Valid  	, ;		// 06 - Valid
			SX3->X3_USADO  	, ;		// 07 - Usado
			SX3->X3_TIPO   	, ;		// 08 - Tipo
			SX3->X3_F3		, ;		// 09 - F3
			SX3->X3_CONTEXT	, ;   	// 10 - Contexto
			SX3->X3_CBOX	, ; 	// 11 - ComboBox
			SX3->X3_RELACAO	, } )	// 12 - Relacao
		Endif
		SX3->(dbSkip())
	End

	// Criar Acols
	dbSelectArea("FRD")
	DbSetOrder(1)
	dbSeek(xFilial("FRD")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
	While !eof() .and. SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) == FRD->(FRD_PREFIX+FRD_NUM+FRD_PARCEL+FRD_TIPO+FRD->FRD_FORNEC+FRD_LOJA)
		aAdd(aCol,Array(Len(aHead)+1))
		nCols ++

		For nX := 1 To Len(aHead)
			If ( aHead[nX][10] != "V")
				aCol[nCols][nX] := FieldGet(FieldPos(aHead[nX][2]))
			Else
				aCol[nCols][nX] := CriaVar(aHead[nX][2],.T.)
			Endif
		Next nX
		aCol[nCols][Len(aHead)+1] := .F.
		dbSkip()
	End

	aAdd(aAlter,'FRD_DOCUM')
	aAdd(aAlter,'FRD_RECEB')

	oGet			:= 	MsNewGetDados():New(0,0,170,402,GD_INSERT+GD_UPDATE+GD_DELETE,;
	cLinOk,,"",aAlter,nFreeze,nMax,cFieldOk,cSuperDel,cDelOk,oPanel2,aHead,aCol)
	oGet:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg, {|| IIF(FA050LinFRD(),(nOpca:=1,oDlg:End()),)},{||oDlg:End()}) CENTERED

	If nOpcA == 1

		nPosDoc := ASCAN(oGet:aHeader,{|x| AllTrim(x[2])=="FRD_DOCUM"})
		nPosRec := ASCAN(oGet:aHeader,{|x| AllTrim(x[2])=="FRD_RECEB"})

		dbSelectArea("FRD")
		dbSetOrder(1)		//FRD_FILIAL+FRD_PREFIX+FRD_NUM+FRD_PARCEL+FRD_TIPO+FRD_FORNEC+FRD_LOJA+FRD_DOCUM
		dbGoTop()

		//Verifica se o aCols foi alterado, para então apagar o registro antigo
		If dbSeek(xFilial("SE2")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
			While !EoF() .And. FRD->(FRD_FILIAL+FRD_PREFIX+FRD_NUM+FRD_PARCEL+FRD_TIPO+FRD_FORNEC+FRD_LOJA) == xFilial("SE2")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
				For nX := 1 To Len(oGet:aCols)
					If FRD->FRD_DOCUM == oGet:aCols[nX][nPosDoc]
						lAchou := .T.
					EndIf
				Next nX
				If !lAchou
					RecLock("FRD",.F.)
					dbDelete()
					MsUnLock()
				EndIf
				lAchou := .F.
				dbSkip()
			End
		EndIf

		For nX := 1 To Len(oGet:aCols)
			If !oGet:aCols[nx][Len(oGet:aHeader)+1]
				If dbSeek(xFilial("SE2")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)+oGet:aCols[nx][nPosDoc])
					RecLock("FRD",.F.)
				Else
					RecLock("FRD",.T.)
				EndIf
				FRD->FRD_FILIAL 	:= xFilial("FRD")
				FRD->FRD_PREFIX 	:= SE2->E2_PREFIXO
				FRD->FRD_NUM		:= SE2->E2_NUM
				FRD->FRD_PARCEL 	:= SE2->E2_PARCELA
				FRD->FRD_TIPO 		:= SE2->E2_TIPO
				FRD->FRD_FORNEC 	:= SE2->E2_FORNECE
				FRD->FRD_LOJA 		:= SE2->E2_LOJA
				FRD->FRD_DOCUM		:= oGet:aCols[nX][nPosDoc]
				FRD->FRD_RECEB		:= oGet:aCols[nX][nPosRec]
				MsUnLock()
			Else
				For nY := 1 To Len(oGet:aCols)
					If !oGet:aCols[nY,Len(oGet:aHeader)+1] .And. (oGet:aCols[nX][nPosDoc] == oGet:aCols[nY][nPosDoc])
						lIgual := .T.
					EndIf
				Next nY
				If !lIgual
					dbSelectArea("FRD")
					dbSetOrder(1)		//FRD_FILIAL+FRD_PREFIX+FRD_NUM+FRD_PARCEL+FRD_TIPO+FRD_FORNEC+FRD_LOJA+FRD_DOCUM
					If dbSeek(xFilial("SE2")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)+oGet:aCols[nx][nPosDoc])
						RecLock("FRD",.F.)
						dbDelete()
						MsUnLock()
					EndIf
				EndIf
			EndIf
		Next

		//³ Ponto de entrada apos gravar a manutencao nos       ³
		//³ documentos.                                         ³
		//³ PARAMIXB[1] caracter com chave 1 da tabela SE2      ³
		//³ PARAMIXB[2] array com acols   da tabela FRD         ³
		//³ PARAMIXB[3] array com aheader da tabela FRD         ³
		//³ Nao tem retorno                                     ³
		IF lF050DOCS
			ExecBlock("F050DOCS",.f.,.f.,{xFilial("SE2")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA),oGet:aCols,oGet:aHeader})
		Endif

	EndIf

	RestArea( aArea )
Else
	Help(" ",1,"FA050VDOC",,,1,0)	//"Controle de documentos não disponível para o título. O título não possui vinculo com tipos de documentos."
EndIf

Return

/*/
±±³Fun‡…o	 ³ FA050Contr ³ Autor ³ TOTVS       		  ³ Data ³ 21/07/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Rotina para rastreio de contratos a partir do titulo         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ FA050Contr(ExpC1,ExpN1,ExpN2)							    ³±±
/*/
Function FA050Contr(cAlias,nReg,nOpc)
LOCAL aAreaCN9   := CN9->(GetArea())
LOCAL aAreaSC7   := SC7->(GetArea())
LOCAL aAreaSD1   := SD1->(GetArea())
LOCAL aAreaSF1   := SF1->(GetArea())
LOCAL cPrefixo   := ""
LOCAL cAliasSF1  := "SF1"
LOCAL cAliasSD1  := "SD1"
LOCAL cNota      := ""
LOCAL cSerie     := ""
LOCAL cFornece   := ""
LOCAL cLojaFor   := ""
LOCAL aPedidos   := {}
LOCAL aContratos := {}
LOCAL aRastrContr:= {}
LOCAL oDlgCtr
LOCAL oLbxCtr
LOCAL aTitCampos := {" ",OemToAnsi(STR0192),OemToAnsi(STR0193),OemToAnsi(STR0194),OemToAnsi(STR0195)}
LOCAL oOk        := LoadBitMap(GetResources(), "LBOK")
LOCAL oNo        := LoadBitMap(GetResources(), "LBNO")
LOCAL nOpcCtr    := 0
LOCAL nPos
LOCAL nX
LOCAL cQuery

//Busca notas fiscais de entrada relacionadas com o titulo em questao:

cAliasSF1 := "SF1TMP"
cQuery	  := "  SELECT * FROM " + RetSqlName('SF1')
cQuery	  += "  WHERE F1_FILIAL  = '" + xFilial('SF1') + "' AND "
cQuery	  += "    F1_FORNECE = '" + SE2->E2_FORNECE + "' AND"
cQuery	  += "    F1_LOJA = '" + SE2->E2_LOJA + "' AND"
cQuery	  += "    F1_DOC = '" + SE2->E2_NUM + "' AND"
cQuery	  += "    D_E_L_E_T_ = ' '"
cQuery    := ChangeQuery(cQuery)
dbUseArea ( .T., "TOPCONN", TCGENQRY(,,cQuery), cAliasSF1, .F., .T.)

While (cAliasSF1)->(!Eof() .AND. F1_FILIAL+F1_FORNECE+F1_LOJA+F1_DOC == xFilial('SF1')+SE2->(E2_FORNECE+E2_LOJA+E2_NUM))
	cPrefixo := If(Empty((cAliasSF1)->F1_PREFIXO),&(GetMV("MV_2DUPREF")),(cAliasSF1)->F1_PREFIXO)
	If cPrefixo == SE2->E2_PREFIXO
		cNota     := (cAliasSF1)->F1_DOC
		cSerie    := (cAliasSF1)->F1_SERIE
		cFornece  := (cAliasSF1)->F1_FORNECE
		cLojaFor  := (cAliasSF1)->F1_LOJA
		Exit
	Endif
	(cAliasSF1)->(DbSkip())
EndDo


(cAliasSF1)->(dbCloseArea())


If Empty(cNota)
	Help(" ",1, "FA050NOTA",, STR0196 , 4,0)

	RestArea(aAreaSF1)
	RestArea(aAreaSD1)
	RestArea(aAreaSC7)
	RestArea(aAreaCN9)
	Return
Endif

//Busca Pedidos de Compras relacionados com a Nota de Entrada:

cAliasSD1 := "SD1TMP"
cQuery	  := "  SELECT * FROM " + RetSqlName('SD1')
cQuery	  += "  WHERE D1_FILIAL  = '" + xFilial('SD1') + "' AND "
cQuery	  += "    D1_DOC = '" + cNota + "' AND"
cQuery	  += "    D1_SERIE = '" + cSerie + "' AND"
cQuery	  += "    D1_FORNECE = '" + cFornece + "' AND"
cQuery	  += "    D1_LOJA = '" + cLojaFor + "' AND"
cQuery	  += "    D1_PEDIDO <> ' ' AND"
cQuery	  += "    D_E_L_E_T_ = ' '"
cQuery    := ChangeQuery(cQuery)
dbUseArea ( .T., "TOPCONN", TCGENQRY(,,cQuery), cAliasSD1, .F., .T.)

While (cAliasSD1)->(!Eof() .AND. D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA == xFilial('SD1')+cNota+cSerie+cFornece+cLojaFor)
	If !Empty((cAliasSD1)->D1_PEDIDO)
		nPos := Ascan(aPedidos,{|x| x[01]+x[02] == (cAliasSD1)->(D1_PEDIDO+D1_ITEMPC)})
		If nPos == 0
			aadd(aPedidos,{(cAliasSD1)->D1_PEDIDO,(cAliasSD1)->D1_ITEMPC})
		Endif
	Endif
	(cAliasSD1)->(DbSkip())
EndDo

(cAliasSD1)->(dbCloseArea())

If Empty(aPedidos)
	Help(" ",1, "FA050PEDI",, STR0196 , 4,0)

	RestArea(aAreaSF1)
	RestArea(aAreaSD1)
	RestArea(aAreaSC7)
	RestArea(aAreaCN9)
	Return
Endif

//Busca os contratos relacionados ao Pedido de Compras:
CN9->(DbSetOrder(1))
SC7->(DbSetOrder(1))
For nX:=1 to Len(aPedidos)
	If SC7->(DbSeek(xFilial("SC7")+aPedidos[nX,01]+aPedidos[nX,02])) .AND. !Empty(SC7->C7_CONTRA)
		nPos := Ascan(aContratos,{|x| x[02]+x[03] == SC7->(C7_CONTRA+C7_CONTREV)})
		If nPos == 0
			If CN9->(DbSeek(xFilial("CN9")+SC7->(C7_CONTRA+C7_CONTREV)))
				aadd(aContratos,{oNo,SC7->C7_CONTRA,SC7->C7_CONTREV,CN9->CN9_DTINIC,CN9->CN9_DTFIM})
			Endif
		Endif
	Endif
Next

If Empty(aContratos)
	Help(" ",1, "FA050CNTR",, STR0196 , 4,0)

	RestArea(aAreaSF1)
	RestArea(aAreaSD1)
	RestArea(aAreaSC7)
	RestArea(aAreaCN9)
	Return
Endif

If Len(aContratos) == 1
	aRastrContr := {aContratos[01,02],aContratos[01,02],Space(TamSX3("CN9_TPCTO")[01]),Replicate("Z",TamSX3("CN9_TPCTO")[01]),;
	Space(TamSX3("CN9_SITUAC")[01]),Replicate("Z",TamSX3("CN9_SITUAC")[01]),cFornece,cFornece,cLojaFor,cLojaFor,;
	Space(TamSX3("B1_COD")[01]),Replicate("Z",TamSX3("B1_COD")[01])}
Else
	DEFINE MSDIALOG oDlgCtr FROM 50,40 TO 285,541 TITLE OemToAnsi( STR0198 ) Of oMainWnd PIXEL

	oLbxCtr := TWBrowse():New( 27,4,243,86,,aTitCampos,,oDlgCtr,,,,,,,,,,,,.F.,,.T.,,.F.,,,)
	oLbxCtr:SetArray(aContratos)
	oLbxCtr:bLDblClick := { || aContratos[oLbxCtr:nAt,1] := If(aContratos[oLbxCtr:nAt,1]:cName=="LBNO", oOk,oNo) }
	oLbxCtr:bLine := { || {aContratos[oLbxCtr:nAT][1],aContratos[oLbxCtr:nAT][2],aContratos[oLbxCtr:nAT][3],aContratos[oLbxCtr:nAT][4],aContratos[oLbxCtr:nAT][5]}}
	oLbxCtr:Align := CONTROL_ALIGN_ALLCLIENT

	ACTIVATE MSDIALOG oDlgCtr CENTERED ON INIT EnchoiceBar(oDlgCtr,{||If(VldSelCtr(oLbxCtr:aArray,aContratos),(nOpcCtr := 1,oDlgCtr:End()),oDlgCtr:End())},{||(nOpcCtr := 0,oDlgCtr:End())})

	If nOpcCtr == 1
		For nX:=1 to Len(aContratos)
			If aContratos[nX,01]:cName == "LBOK"
				aRastrContr := {aContratos[nX,02],aContratos[nX,02],Space(TamSX3("CN9_TPCTO")[01]),Replicate("Z",TamSX3("CN9_TPCTO")[01]),;
				Space(TamSX3("CN9_SITUAC")[01]),Replicate("Z",TamSX3("CN9_SITUAC")[01]),cFornece,cFornece,cLojaFor,cLojaFor,;
				Space(TamSX3("B1_COD")[01]),Replicate("Z",TamSX3("B1_COD")[01])}
			Endif
		Next
	Endif
Endif

If !Empty(aRastrContr)
	CNTC010( aRastrContr )
Endif

RestArea(aAreaSF1)
RestArea(aAreaSD1)
RestArea(aAreaSC7)
RestArea(aAreaCN9)
Return

/*/
±±³Fun‡…o	 ³ VldSelCtr  ³ Autor ³ TOTVS       		  ³ Data ³ 16/11/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida selecao do contrato.                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ VldSelCtr(aLbxCtr,aContratos)							    ³±±
/*/
Static Function VldSelCtr(aLbxCtr,aContratos)
LOCAL nSelOK := 0

aEval(aLbxCtr,{|x| If(x[1]:cName == "LBOK",++nSelOK,0)})

If nSelOK == 0
	Help(" ",1, "FA050VLDC",, STR0199, 4,0)

	Return .f.
ElseIf nSelOK > 1
	Help(" ",1, "FA050VLDC",, STR0200, 4,0)

	Return .f.
Endif
aContratos := aClone(aLbxCtr)

Return .t.

/*
±±ºPrograma  ³FA050LinFRD ºAutor  ³Renan G. Alexandre º Data ³  02/21/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao de validaco da linha da grid dos documentos		  º±±
±±ºDesc.     ³vinculados ao titulo.                                       º±±
*/
Function FA050LinFRD()
Local lRet		:= .T.
Local nPosDoc	:= 0
Local nPosRec	:= 0
Local nX		:= 0
Local nColDel	:= 0

nPosDoc := ASCAN(oGet:aHeader, {|aCpos| AllTrim(aCpos[2]) == "FRD_DOCUM"})
nPosRec := ASCAN(oGet:aHeader, {|aCpos| AllTrim(aCpos[2]) == "FRD_RECEB"})

If (nPosDoc > 0) .And. (nPosRec > 0)
	For nX := 1 To Len(oGet:aCols)
		If !oGet:aCols[nX][Len(oGet:aHeader)+1]
			If Empty(AllTrim(oGet:aCols[nX][nPosDoc])) .Or. Empty(AllTrim(oGet:aCols[nX][nPosRec]))
				lRet := .F.
				Help(" ",1,"FA050DOC1")
				Exit
			ElseIf (nX != oGet:nAt) .And. (AllTrim(oGet:aCols[nX][nPosDoc]) == AllTrim(oGet:aCols[oGet:nAt][nPosDoc]));
			.And. !oGet:aCols[oGet:nAt][Len(oGet:aHeader)+1]
				Help(" ",1,"FA050DOC2")		//"Código de documento já informado, não permitido."##"Informe um código diferente."
				lRet := .F.
				Exit
			EndIf
		Else
			nColDel++
		EndIf
	Next nX
EndIf

If nColDel >= Len(oGet:aCols)
	lRet := .F.
	Help(" ",1,"FA050DOC3")		//"Tipo de documento não informado."##"Informe o tipo de documento a ser vinculado ao título."
EndIf

Return(lRet)

/*
±±ºPrograma  fa050CalcRet ºAutor  ³	Paulo Leme		  º Data ³  02/04/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Calculo das Retenções de Impostos                      	  º±±
*/
Function fa050CalcRet(cCarteira, cFatoGerador, cNatur, nValor, cPrefixo, nNum, cFornec,lGrava,cNumOP)
//Republica Dominicana
Local aAreaSE2   := SE2->(GetArea())
Local aAreaFRN   := FRN->(GetArea())
Local aAreaFRM   := FRM->(GetArea())
Local cNroCert  := " "
Local cFornece	:= " "
Local cLoja		:= " "
Local cChaveSfe	:= " "
Local cNumNfSfe	:= " "
Local nValBase	:= 0
Local nValCalc   := 0
Local nAliq     := 0
Local cTitPai 	:= SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
Local cOrigem  	:= FunName()
Local cTptPai   := SE2->E2_TIPO
Local aImposto	:= {}
Local aAux 		:= {}
Local nRegSE2	:= 0
Local cTipTit	:= ""
Local lCalcImp	:= .T.
Local cFilterSE2:= ""
Local cFornImp	:= ""
Local cLojImp	:= ""
Local dDtVenc	:= dDataBase
Private aCerts	:= {}

DEFAULT lGrava  := .F.
DEFAULT cNumOP  := ""

nValBase	:=	nValor
//Geração das Retenções de Impostos
DbSelectArea("FRN")
FRN->( DbSetOrder(2) )
If 	FRN->( DbSeek( xFilial("FRN") + cNatur ) )
	While 	!FRN->( Eof() ) .And. FRN->(xFilial("FRN") + FRN_CODNAT) 	== 	xFilial('FRN') 	+ cNatur
		If 	FRN->FRN_MSBLQL	<>	'1'
			DbSelectArea("FRM")
			FRM->( DbSetOrder(2) )
			FRM->( dbSeek(xFilial("FRM") + FRN->FRN_IMPOST + FRN->FRN_SEQ ) )
			While 	!FRM->( Eof() ) .And. FRM->(xFilial("FRM") + FRM->FRM_COD + FRM->FRM_SEQ) 	== 	xFilial('FRM') 	+ FRN->FRN_IMPOST + FRN->FRN_SEQ
				If 	!FRM->FRM_APLICA $ "1|2"
					FRM->( DbSkip() )
					Loop
				EndIf
				SA2->( dbSetOrder(1) )
				SA2->( dbSeek(xFilial("SA2") + SE2->E2_FORNECE + SE2->E2_LOJA ) )
				//1-Contas a Pagar ou 3-Ambos. Dentro da vigencia e não bloqueado
				nValCalc     :=  0
				If 	FRM->FRM_CARTEI	   	$ 	cCarteira 	.And. 	;
				FRM->FRM_INIVIG    	<= 	dDataBase 	.And. 	FRM->FRM_FIMVIG  	>= 	dDataBase    .And. ;
				FRM->FRM_MSBLQL		<>	'1' 	    .And.	;
				FRM->FRM_BLOQ 		<> 	'1'         .And. 	;
				(FRM->FRM_TPESSO    ==  "9"			.Or.	FRM->FRM_TPESSO  	==  SA2->A2_TIPO)
					nValCalc     :=  0
					nValCalc 	:= 	fa050CalcImp(FRN->FRN_IMPOST, FRN->FRN_SEQ, FRM->FRM_CARTEIRA, cNatur, nValor)

					aAux := {FRM->FRM_SIGLA,nValCalc,FRM->FRM_APLICA}

				EndIf
				// Cálculo do Valor do Imposto qdo regra de aplicação definida como Retenção ou Imposto
				If 	nValCalc > 0  .And. (!Empty(FRM->FRM_TPABT) .Or. !Empty(FRM->FRM_TPTIT))
					If 	FRM->FRM_FATGER  ==	"1" .And. !(cOrigem $ "FINA085A|FINA850") .And. cFatoGerador <> "9"
						If FRM->FRM_APLICA == "1"
							RecLock("SE2",.F.)
							E2_VALOR    := SE2->E2_VALOR  - nValCalc
							E2_SALDO    := SE2->E2_SALDO  - nValCalc
							E2_VLCRUZ   := SE2->E2_VLCRUZ - nValCalc
							MsUnLock()
						EndIf
						/* Gerar Título de Abatimento de Retenção - SE2 */
						/* fGerAbatCP(cPrefixo, cTitulo, cParcela, cTipoDoc, nFornec, nLoja, nValAbat, cTipoRet, cTpAbt, cTitPai)  */
						fGerAbatCP(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, nValCalc, Iif (FRM->FRM_APLICA == "1", "I","R"), Iif (FRM->FRM_APLICA == "1", FRM->FRM_TPTIT,FRM->FRM_TPABT), cTitPai)
					EndIf
					If 	cOrigem $ "FINA085A|FINA850"

						//Valida se existe imposto gerado - retido 100% na 1a. oportunidade - Baixas Parciais
						nRegSE2 	:= SE2->(Recno())
						cFilterSE2	:= SE2->(dbFilter())

						dbSelectArea("SE2")
						SE2->(dbClearFilter())
						SE2->(dbSetOrder(1))
						If FRM->FRM_APLICA == "1"
							cTipTit := FRM->FRM_TPTIT
							cFornImp := PadR(GetMV("MV_UNIAO"),TamSx3("A2_COD")[1])
							cLojImp  := PadR("00",TamSx3("A2_LOJA")[1])
						ElseIf FRM->FRM_APLICA == "2"
							cTipTit := FRM->FRM_TPABT
							cFornImp := SE2->E2_FORNECE
							cLojImp  := SE2->E2_LOJA
						EndIf

						If SE2->(dbSeek(xFilial("SE2")+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+cTipTit+cFornImp+cLojImp))
							lCalcImp := .F.
						Else
							aAdd(aImposto, aAux)
						EndIf

						SE2->(dbGoTo(nRegSE2))
						If !Empty(cFilterSE2)
							SE2->(dbSetFilter({|| &cFilterSE2},cFilterSE2))
						EndIf

						If 	FRM->FRM_FATGER  ==	"2" .And. cFatoGerador <> "9" .And. lCalcImp
							If FRM->FRM_APLICA == "1" .And. !lGrava
								RecLock("SE2",.F.)
								E2_VALOR    := SE2->E2_VALOR  - nValCalc
								E2_SALDO    := SE2->E2_SALDO  - nValCalc
								E2_VLCRUZ   := SE2->E2_VLCRUZ - nValCalc
								MsUnLock()
							EndIf
							/* Gerar Título de Abatimento de Retenção - SE2 */
							/* fGerAbatCP(cPrefixo, cTitulo, cParcela, cTipoDoc, nFornec, nLoja, nValAbat, cTipoRet, cTpAbt, cTitPai)  */
							If lGrava
								dDtVenc := FCalcVenc(SE2->E2_EMISSAO,FRM->FRM_VCDIA,FRM->FRM_VCTIPO,FRM->FRM_VCDUTI,FRM->FRM_VCCONT,FRM->FRM_VCFAT,FRM->FRM_VDTVLD)
								fGerAbatCP(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, nValCalc, Iif (FRM->FRM_APLICA == "1", "I","R"), Iif (FRM->FRM_APLICA == "1", FRM->FRM_TPTIT,FRM->FRM_TPABT), cTitPai, FRM->FRM_SIGLA,cNumOP,dDtVenc)
							EndIf
						EndIf
					EndIf
					If 	(FRM->FRM_FATGER  ==	"1" .And. cFatoGerador  ==	"1") .Or. (FRM->FRM_FATGER  ==	"2" .And. lGrava .And. lCalcImp)
						/* Grava a Retencao - SFE */
						If Empty(cNroCert)
							If FRM->FRM_APLICA == "1"
								cNroCert	:=	GetCert(FRM->FRM_TPTIT+"   ",cFornece+cLoja+FRM->FRM_TPTIT+"   ")
							Else
								cNroCert	:=	GetCert(FRM->FRM_TPABT+"   ",cFornece+cLoja+FRM->FRM_TPABT+"   ")
							EndIf
						EndIf
						If  FRN->FRN_CONCEP == CCR->CCR_CONCEP .And. CCR->CCR_ALIQ	  <>   0
							nAliq := CCR->CCR_ALIQ
						Else
							nAliq := FRM->FRM_ALIQ
						EndIf
						If ValType(nNum) == 'N'
							cNumNfSfe := STR(nNum, TamSX3("FE_NFISCAL")[1])
						Else
							cNumNfSfe := Substr(nNum + Space(TamSX3("FE_NFISCAL")[1]),1,TamSX3("FE_NFISCAL")[1])
						EndIf
						cChaveSfe := xFilial("SFE") + SE2->E2_FORNECE + SE2->E2_LOJA + cNumNfSfe + cPrefixo + Iif ( FRM->FRM_APLICA == "1", "I","R") + FRN->FRN_CONCEP //FE_FILIAL+FE_FORNECE+FE_LOJA+FE_NFISCAL+FE_SERIE+FE_TIPO+FE_CONCEPT
						If 	!FA50SfeExi(cChaveSfe,Iif (FRM->FRM_APLICA == "1", FRM->FRM_TPTIT,FRM->FRM_TPABT)) // Verifica se já existe o registro do imposto. Se não existir, inclui
							RecLock("SFE",.T.)
							FE_FILIAL	:=	xFilial("SFE")
							FE_NROCERT	:=	cNroCert
							FE_EMISSAO  :=	dDataBase
							FE_FORNECE  :=	SE2->E2_FORNECE
							FE_LOJA     :=	SE2->E2_LOJA
							FE_TIPO     :=	Iif ( FRM->FRM_APLICA == "1", "I","R")
							FE_PORCRET	:=	Iif ( CCR->CCR_REDUC  >   0 , 100 - CCR->CCR_REDUC ,  100 -	FRN->FRN_REDUC)
							FE_ALIQ     :=	nAliq
							FE_VALBASE  :=  nValBase
							If FRM->FRM_APLICA == "1"
								FE_VALIMP	:=	nValCalc
							Else
								FE_RETENC	:=	nValCalc
							EndIf
							FE_CONCEPT  :=  FRN->FRN_CONCEP
							FE_ITEM     :=  1
							FE_NFISCAL  :=  nNum
							FE_SERIE    :=  cPrefixo
							FE_ORDPAGO  :=  Iif( ValType("cOrdPago") <> "U", cOrdPago, SE2->E2_ORDPAGO)
							FE_BANCO    :=	SE2->E2_BCOCHQ
							FE_AGENCIA  :=	SE2->E2_AGECHQ
							FE_NUMCOM   := 	SE2->E2_CTACHQ
							FE_TPTIMP   :=  Iif (FRM->FRM_APLICA == "1", FRM->FRM_TPTIT,FRM->FRM_TPABT)
							FE_TPTPAI   :=  cTptPai
							FE_SIGLA    :=  FRM->FRM_SIGLA
							MsUnLock()
						EndIf
					EndIf
				EndIf
				FRM->( DbSkip() )
			EndDo
		EndIf
		RestArea(aAreaSE2)
		FRN->( DbSkip() )
	EndDo

	If Type("aRetencao") == "A"
		aAdd( aRetencao, {SE2->E2_FILIAL,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,aImposto} )
	EndIf

EndIf
RestArea(aAreaFRM)
RestArea(aAreaFRN)
Return .T.

/*
±±ºPrograma  fa050CalcImp ºAutor  ³	Paulo Leme		  º Data ³  02/04/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Calculo do Imposto                                    	  º±±
*/
Function fa050CalcImp(cImposto, cSequencia, cCarteira, cNatur, nValor)
Local aAreaFRN  := FRN->(GetArea())
Local aAreaFRM  := FRM->(GetArea())
Local nValImp 	:= 0

FRN->( DbSetOrder(2) )
If 	FRN->( DbSeek(xFilial("FRN") + cNatur + cImposto + cSequencia ) )
	FRM->( DbSetOrder(2) )
	If FRM->( dbSeek(xFilial("FRM") + FRN->FRN_IMPOST + FRN->FRN_SEQ + cCarteira ) )
		// Cálculo do Valor do Imposto qdo regra de aplicação definida como Retenção
		If 	FRM->FRM_CARTEI	$ 	"1|3"
			If	!Empty(FRN->FRN_CONCEP)
				CCR->( dbSetOrder(1) )
				If CCR->( dbSeek(xFilial("CCR")+AvKey(FRN->FRN_CONCEP,"CCR_CONCEP")) ) .And. CCR->CCR_ALIQ 	<> 	0
					nValImp 		:= 	(CCR->CCR_ALIQ 	* nValor )   / 100
					If	CCR->CCR_REDUC 	<> 	0
						nValImp 		:= 	nValImp - (CCR->CCR_REDUC * nValImp ) / 100
					EndIf
				ElseIf FRM->FRM_ALIQ <> 0
					nValImp 		:= 	(FRM->FRM_ALIQ 	* nValor ) 	/ 100
					If FRN->FRN_REDUC <> 0
						nValImp 		:= 	nValImp - (FRN->FRN_REDUC * nValImp ) / 100
					EndIf
				EndIf
			EndIf
			If  Empty(FRN->FRN_CONCEP)
				If 	FRM->FRM_ALIQ 		<> 	0
					nValImp 			:= 	(FRM->FRM_ALIQ 	* nValor) 	/ 100
				EndIf
				If 	FRN->FRN_REDUC 		<> 	0
					nValImp 			:= 	nValImp - (FRN->FRN_REDUC * nValImp ) / 100
				EndIf
			EndIf
		EndIf
	EndIf
EndIf
RestArea(aAreaFRN)
RestArea(aAreaFRM)

Return nValImp

/*
±±ºPrograma  fa050DelRet ºAutor  ³	Paulo Leme		  º Data ³  02/03/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Deleção do Calculo das Retenções de Impostos de Um Titulo	  º±±
*/
Function fa050DelRet()
//Republica Dominicana
Local aAreaSE2   := SE2->(GetArea())
Local cSE2Fil    :=	xFilial("SE2")
Local cFornec    :=	SE2->E2_FORNECE
Local cLoja      := SE2->E2_LOJA
Local cPrefixo   := SE2->E2_PREFIXO
Local cNum       := SE2->E2_NUM

//Excluir registros na Tabela de Contas a Pagar dos Titulos de Retenções de Impostos
SE2->(dbSetOrder(6)) //E2_FILIAL+E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO
If SE2->(dbSeek(cSE2Fil+cFornec+cLoja+cPrefixo+cNum))
	While !Eof( ) .And. SE2->E2_FILIAL+SE2->E2_FORNECE+SE2->E2_LOJA+SE2->E2_PREFIXO+SE2->E2_NUM == ;
	cSE2Fil+cFornec+cLoja+cPrefixo+cNum
		If SE2->E2_TIPO $ MVABATIM

			FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
			RecLock("SE2",.F.)
			dbDelete()
			MsUnLock()
		EndIf
		SE2->(dbSkip())
	EndDo
EndIf
//Excluir registros na Tabela de Contas a Pagar dos Titulos de Retenções de Impostos
SFE->(dbSetOrder(4)) //FE_FILIAL+FE_FORNECE+FE_LOJA+FE_NFISCAL+FE_SERIE+FE_TIPO
If SFE->(dbSeek(cSE2Fil+cFornec+cLoja+cNum+cPrefixo))
	While !Eof( ) .And. SFE->FE_FILIAL+SFE->FE_FORNECE+SFE->FE_LOJA+SFE->FE_NUM+SFE->FE_PREFIXO == ;
	cSE2Fil+cFornec+cLoja+cNum+cPrefixo
		RecLock("SFE",.F.)
		dbDelete()
		MsUnLock()
		SFE->(dbSkip())
	EndDo
EndIf
RestArea(aAreaSE2)

Return .T.

/*
±±ºPrograma  ³F050VldAprºAutor  ³ Danilo Dias        º Data ³ 02/05/2011  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Valida o campo de código do aprovador EU_CODAPRO caso o    º±±
±±º          ³ controle de alçadas esteja ativado. (MV_FINCTAL = 2)       º±±
*/
Function F050VldApr()

Local aArea := GetArea()
Local lRet  := .T.
Local cCtAl := SuperGetMV( "MV_FINCTAL", .T., "1" )

If cCtAl == "2"
	dbSelectArea("SE2")
	If Empty(M->E2_CODAPRO)
		Help( " ", 1, "F050VldApr", , STR0202, 1, 0 )	//"O campo 'Cod. Aprov.' é obrigatório quando controle de alçadas está ativo."
		lRet := .F.
	EndIf
EndIf

RestArea(aArea)

Return lRet

/*	Modelo de Dados
@author  	Jefferson Tomaz
@version 	P10 R1.4
@build		7.00.101202A
@since 		06/04/2011
@return 		oModel Objeto do Modelo*/
Static Function ModelDef()
Local oModel
Local oStruSE2  	:= FWFormStruct(1,"SE2")
Local oStruCTJ  	:= FWFormStruct(1,"CTJ")
Local oStrPrvSE2  	:= FWFormStruct(1,"SE2")
Local lIntGFE   	:= SuperGetMv('MV_INTGFE',,.F.)
Local aParRot   	:= {'aRotAuto1','','nOpcx','','','','','aRotAuto2','aRotAuto3'}
Local aIDStruct 	:= {}
Local aNewField 	:= {}
Local aMsgRet   	:= {}
Local bPost     	:= Nil
Local bCommit   	:= Nil
Local bOption 		:= Nil
Local aPK_SE2   	:= { "E2_FILIAL","E2_PREFIXO","E2_NUM","E2_PARCELA","E2_TIPO","E2_FORNECE","E2_LOJA" }
Local aAux      	:= {}

If lIntGFE

	oStruSE2  	:= FWFormStruct(1,"SE2",{|cCampo|  AllTrim(cCampo) $ "|E2_PREFIXO|E2_NUM|E2_PARCELA|E2_TIPO|E2_NATUREZ|E2_FORNECE|E2_LOJA|E2_NOMFOR|E2_EMISSAO|E2_VENCTO|E2_VENCREA|E2_VALOR|E2_RATEIO|E2_VLCRUZ|E2_ACRESC|E2_DECRESC|E2_ORIGEM|E2_ISS|E2_IRRF|E2_INSS|E2_SEST|"})
	oStrPrvSE2  := FWFormStruct(1,"SE2",{|cCampo| AllTrim(cCampo) $ "|E2_PREFIXO|E2_NUM|E2_PARCELA|E2_TIPO|E2_FORNECE|E2_LOJA|"})
	oStruCTJ  	:= FWFormStruct(1,"CTJ",{|cCampo| !(AllTrim(cCampo) $ "CTJ_FILIAL|CTJ_RATEIO|CTJ_DESC|CTJ_MOEDLC|CTJ_TPSALD|CTJ_SEQUEN|CTJ_QTDTOT") })

	oStruSE2:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )
	oStruSE2:SetProperty( '*', MODEL_FIELD_WHEN ,  NIL )
	oStruSE2:SetProperty( '*' , MODEL_FIELD_OBRIGAT, .F.)

	oStrPrvSE2:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )
	oStrPrvSE2:SetProperty( '*', MODEL_FIELD_WHEN ,  NIL )
	oStrPrvSE2:SetProperty( '*', MODEL_FIELD_OBRIGAT, .F.)

	oStruCTJ:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )
	oStruCTJ:SetProperty( '*', MODEL_FIELD_WHEN ,  NIL )
	oStruCTJ:SetProperty( '*', MODEL_FIELD_OBRIGAT, .F.)


	oStruSE2:AddField( ;                      // Ord. Tipo Desc.
	"CGC Fornec."                    , ;      // [01]  C   Titulo do campo
	"CGC Fornec."                    , ;      // [02]  C   ToolTip do campo
	"E2_CGCFOR"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	14                               , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'Posicione("SA2",1,xFilial("SA2")+SE2->(E2_FORNECE+E2_LOJA),"A2_CGC")' ), ; // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual

	//--------------------GATILHO NO E2_CGCFOR------------------------------------------------------
	aAux := FwStruTrigger(;
	"E2_FORNECE", ;                                                  // [01] Id do campo de origem
	"E2_CGCFOR", ;                                                  // [02] Id do campo de destino
	'Posicione("SA2",1,xFilial("SA2")+M->E2_FORNECE,"A2_CGC")')

	oStruSE2:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho

	aAux := FwStruTrigger(;
	"E2_LOJA", ;                                                     // [01] Id do campo de origem
	"E2_CGCFOR" , ;                                                   // [02] Id do campo de destino
	'Posicione("SA2",1,xFilial("SA2")+M->E2_FORNECE+M->E2_LOJA,"A2_CGC")')

	oStruSE2:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho


	oStruSE2:AddField( ;                      // Ord. Tipo Desc.
	"Msg Retorno"                    , ;      // [01]  C   Titulo do campo
	"Msg Retorno"                    , ;      // [02]  C   ToolTip do campo
	"E2_MSGRET"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	250                              , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	{||"Processado"}						, ;      // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual

	aAdd(aNewField, {"E2_NATUREZ",,,{{"E2_NATUREZ",{||SuperGetMv("MV_NTFGFE",,"")}}}})
	aAdd(aIDStruct, "FINA050_SE2")
	aAdd(aIDStruct, "FINA050_CTJ")
	aAdd(aIDStruct, "FINA050_PRVSE2")

	aAdd(aMsgRet, {"FINA050_SE2","E2_MSGRET"})
	bOption := {|| IIf(Len(aRotAuto3) > 0,6,nOpcx) }

	bPost  := {|oModel,b,c,d,e,f| MaRecEAI(oModel,"FINA050",aIDStruct,aParRot,aNewField,aMsgRet,bOption) }

	bCommit := {|| NIL }

EndIf

oModel:= MPFormModel():New("FINA050",/*bPre*/, bPost, bCommit,/*bCancel*/)
oModel:bPost := bPost
oModel:AddFields("FINA050_SE2", ,oStruSE2,/*bPre*/,/*bPost*/,/*bLoad*/)
oModel:SetPrimaryKey(aPK_SE2)

oModel:AddGrid("FINA050_CTJ","FINA050_SE2",oStruCTJ,/*bLinePre*/, ,/*bPre*/,/*bPost*/,/*bLoad*/)
oModel:SetRelation("FINA050_CTJ",{},"")
oModel:GetModel("FINA050_CTJ"):SetDelAllLine(.T.)
oModel:SetOptional("FINA050_CTJ", .T. )

oModel:AddGrid("FINA050_PRVSE2","FINA050_SE2",oStrPrvSE2,/*bLinePre*/, ,/*bPre*/,/*bPost*/,/*bLoad*/)
oModel:GetModel("FINA050_PRVSE2"):SetDelAllLine(.T.)
oModel:SetOptional("FINA050_PRVSE2", .T. )

oModel:SetDescription(OemToAnsi(STR0007)) // "Contas a Pagar" --  Metodo XML
oModel:GetModel("FINA050_SE2"):SETDESCRIPTION(OemToAnsi(STR0007)) // "Contas a Pagar"

Return oModel

/*
±±³Fun‡…o	 ³ FClcIRPJ³ Autor ³ Marylly A. Silva    ³ Data ³ 25/04/11   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cálculo do IRRF de Pessoa Juridica						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ FClcIRPJ									              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Base Irrf          								  ³±±
±±³			 ³ ExpL1 = Ambiente do Módulo do Financeiro					  ³±±
±±³			 ³ ExpL2 = Utiliza o alias do SE2, senão utiliza a memória	  ³±±
±±³			 ³ ExpL2 = Utiliza o alias do SE2, senão utiliza a memória	  ³±±
±±³			 ³ ExpA1 = Títulos já processados no borderô (Processamento)  ³±±
±±³			 ³ ExpC1 = Número de identificação do Borderô (FINA241)		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA050/FINA080/FINA241/FINA590							  ³±±
±±³			 ³ Tratamento de acumulatividade na baixa e no borderô		  ³±±
*/
Function FClcIRPJ(nBaseIRRF,lFinanceiro,lSRefSE2,aTitBord,cBordero)
Local aArea			:= GetArea()
Local aAreaSED  	:= SED->(GetArea())
Local aAreaSE2  	:= SE2->(GetArea())
Local aAreaSE5  	:= SE5->(GetArea())
Local nTotTit		:= 0
Local nTotInss		:= 0
Local nTotIrrf		:= 0
Local nValor		:= 0
Local lSest			:= cPaisLoc == 'BRA'  //Verifica campo de SEST
Local lAplMinIR 	:= .F. // Carrega variavel de verificacao de consideracao de valor minimo de retencao de IR.
Local nVenctoPJ 	:= SuperGetMv("MV_ACMIRPJ",.T.,"3")  //1 = Emissao    2= Vencimento Real	3=Data Contabilizacao
Local lCalcIr		:= .F.
Local lNatIr		:= .F.
Local lContrRet 	:= .T.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa		:= 	SuperGetMv("MV_BX10925",.T.,"2") == "1"

// Bandeira de cálculo de Imposto de Renda na Baixa
Local lIRPFBaixa 	:=	IIf(cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)

Local lCalcIssBx :=  IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

Local lVretIrf		:= .T.
Local nTotRtIr		:= 0
Local nRecAtual		:= SE2->(RECNO())
Local lNumDep  		:= .T.
Local nBaseDep 		:= GetMV("MV_TMSVDEP",,0)
Local cAglImPJ 		:= SuperGetMv("MV_AGLIMPJ",.T.,"1")
Local aFilial  		:= {}
Local aCliFor  		:= {}
Local cQuery   		:= ""
Local nLoop    		:= 0
Local nBaseSED		:= 1
Local cArqTmp 		:= ""
Local nVlTitBor		:= 0
Local lRotBorder	:= FwIsInCallStack("FINA241") .OR. FwIsInCallStack("FINA590")
Local nNotRet		:= 0
Local nValAcum		:= 0
Local lBaseDif 		:= cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN"

//identifico que a funcao foi chamada na inclusao de titulos
Local lFina050		:= FwIsInCallStack("FINA050")

Local lGestao       := Iif( lFWCodFil, FWSizeFilial() > 2, .F. )	// Indica se usa Gestao Corporativa
Local cFilFwSA2     := IIF( lGestao , FwFilial("SA2") , xFilial("SA2") )
Local cFilFwSED     := IIF( lGestao , FwFilial("SED") , xFilial("SED") )
Local cFilFwSA1     := IIF( lGestao , FwFilial("SA1") , xFilial("SA1") )
Local lDelTrbIR	:= .T.
Local aStru		:= SE2->(dbStruct())
Local cSepNeg	:= If("|"$MV_CPNEG,"|",",")
Local cSepProv	:= If("|"$MVPROVIS,"|",",")
Local cSepRec	:= If("|"$MVPAGANT,"|",",")
Local nX 		:= 0
Local cDbMs		:= UPPER(TcGetDb())
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
Local cAcmIrrf 	:= SuperGetMv("MV_ACMIRRF",.T.,"1")  //1 = Acumula    2= Não acumula
Local nNroFil := 0
Local lE2FilComp := FwModeAccess("SE2",3) == "C"

DEFAULT nBaseIRRF		:= 0
DEFAULT lFinanceiro		:= .F.//Indica que o calculo foi chamado pelo modulo Financeiro
DEFAULT lSRefSE2		:= .F.//Define se a pesquisa deve acontecer sem a referencia de um titulo na SE2 (Variável de Memória)
DEFAULT aTitBord		:= {}
DEFAULT cBordero		:= ""

INCLUI:= IIF(Type("INCLUI") == "U", .T., INCLUI)
ALTERA:= IIF(Type("ALTERA") == "U", .F., ALTERA)

If !lIRPFBaixa
	Help("Ambiente necessita atualização.",1,"")
EndIf

//Ponto de entrada para verificar se Acumula ou não os valores de IR no calculo
//Alteracao efetuada para atender a Pinheiro Neto Advogados (Replicado da Função FcalcIR)
If lAcumIr
	lCalcIr := ExecBlock("F050CALIR",.F.,.F.)
EndIf

// Verifica se o fornecedor trata o valor minimo de retencao.
// 1 - Não considera  2 - Considera o parâmetro MV_VLRETIR
If cPaisLoc == "BRA" .and. SA2->A2_MINIRF == "2"
	lAplMinIR := .T.
EndIf

If !lFinanceiro .AND. !lSRefSE2
	RegToMemory("SE2",.F.,.F.)
EndIf

If lFinanceiro
	If IsBlind()
		RegToMemory("SE2",.F.,.F.)
	Else
		RegToMemory("SE2",.F.,.F.,,Funname())
	EndIf

	nLastDay := Day(LastDay(M->E2_EMISSAO))
	nTamData := Iif(Len(Dtoc(M->E2_EMISSAO)) == 10, 7, 5)
	dDataImp := M->E2_EMISSAO
EndIf

//Valida se a natureza corrente calcula IR
//Se não, desconsidera retenção de pendências (Caso não seja do Financeiro)
If !lFinanceiro
	dbSelectArea("SED")
	aAreaSED := SED->(GetArea())
	SED->(dbSetOrder(1))
	If SED->(dbSeek(xFilial("SED")+M->E2_NATUREZ))
		If SED->ED_CALCIRF == "S"
			lNatIr := .T.
		EndIf
	EndIf
	RestArea(aAreaSED)
Else
	//natureza do Financeiro é validada antes da chamada desta função
	lNatIr := .T.
EndIf

//No caso de novo calculo de IRRF Baixa, efetuo o calculo apenas do imposto do titulo
If lNewIrBx
	lCalcIr := If (lIrpfBaixa, .T., lCalcIr )
Endif

If lNatIr
	//Verifico a combinacao de filiais (SM0) e lojas de fornecedores a serem considerados
	//na montagem da base do IRRF
	If cAglImPJ != "1"
		aRet 	:= FLOJASIRRF("2")
		aFilial := aClone(aRet[1])
		aCliFor := aClone(aRet[2])
		cArqTMP := aRet[3]
	EndIf

	If cAcmIrrf	==	"1" .And. (!lAcumIr .Or.  (lAcumIr .And. lCalcIr))

		cQuery := "SELECT "
		cQuery += "DISTINCT SE2.E2_FILIAL,SE2.E2_PREFIXO,SE2.E2_NUM,SE2.E2_PARCELA,SE2.E2_TIPO,SE2.E2_FORNECE,SE2.E2_LOJA, "
		cQuery += "SE2.E2_EMIS1,SE2.E2_VENCREA,SE2.E2_EMISSAO,SE2.E2_NATUREZ,SE2.E2_VALOR,SE2.E2_IRRF,SE2.E2_INSS,SE2.E2_ISS "
		cQuery += ",SE2.E2_MOEDA, SED.ED_PERCIRF, SE2.E2_BAIXA, SE2.E2_NUMBOR, SE2.E2_SALDO, SE2.R_E_C_N_O_ SE2_RECNO "
		cQuery += ", SE2.E2_NUMLIQ, SE2.E2_FATURA "

		If lSest
			cQuery += ",E2_SEST"
		EndIf

		If lContrRet
			cQuery += ",E2_PRETPIS,E2_PRETCOF,E2_PRETCSL,E2_VRETPIS,E2_VRETCOF,E2_VRETCSL "
		EndIf

		IF lVRetIrf
			cQuery += ",E2_VRETIRF "
		EndIf

		cQuery += " FROM " + RetSQLname("SE2") + " SE2 "
		cQuery += " INNER JOIN " + RetSQLname("SED") + " SED ON SE2.E2_NATUREZ = SED.ED_CODIGO"
		cQuery += " WHERE "

		If lVretIrf
			nNroFil := Len(aFilial)

			//Se verifica base apenas na filial corrente e fornecedor corrente
			If cAglImPJ == "1"
				If lE2FilComp
					cQuery += "SE2.E2_FILORIG = '" + cFilAnt + "' AND "
				Else
					cQuery += "SE2.E2_FILIAL = '" + xFilial("SE2") + "' AND "
				EndIf

				cQuery += "SE2.E2_FORNECE = '" + SA2->A2_COD + "' AND "
				cQuery += "SE2.E2_LOJA = '" + SA2->A2_LOJA + "' AND "
			ElseIf nNroFil > 0
				If Empty( cFilFwSA2 )
					cQuery += If(lE2FilComp, "SE2.E2_FILORIG IN( ", "SE2.E2_FILIAL IN ( ")

					For nLoop := 1 to nNroFil
						cQuery += "'" + aFilial[nLoop] + "',"
					Next nLoop

					//Retiro a ultima virgula
					cQuery := Left(cQuery, Len(cQuery) - 1)
					cQuery += ") AND "

					//Verificar determinados fornecedores (raiz do CNPJ)
					If "MSSQL" $ cDbMs
						cQuery += " (E2_FORNECE+E2_LOJA IN (SELECT CODIGO+LOJA FROM " + cArqTMP + ")) AND "
					Else
						cQuery += " (E2_FORNECE||E2_LOJA IN (SELECT CODIGO||LOJA FROM " + cArqTMP + ")) AND "
					Endif
				Else//Se cadastro de Clientes EXCLUSIVO
					If "MSSQL" $ cDbMs
						cQuery += " (E2_FILIAL+E2_FORNECE+E2_LOJA IN (SELECT FILIALX+CODIGO+LOJA FROM "+ cArqTMP + ")) AND "
					Else
						cQuery += " (E2_FILIAL||E2_FORNECE||E2_LOJA IN (SELECT FILIALX||CODIGO||LOJA FROM " + cArqTMP + ")) AND "
					Endif
				Endif
			Endif
		Else
			cQuery += "SE2.E2_FILIAL = '" + xFilial("SE2") + "' AND "
			cQuery += "SE2.E2_FORNECE = '"+ SA2->A2_COD + "' AND "
			cQuery += "SE2.E2_LOJA = '" + SA2->A2_LOJA + "' AND "
		Endif

		// Para Pessoa juridica totaliza os titulos emitidos no dia
		If nVenctoPJ == "2"
			If Type("M->E2_VENCREA")=="U"
				cQuery += " SE2.E2_VENCREA  = '" + Dtos(SE2->E2_VENCREA)+ "' AND "	//Totaliza pelo vencimento real
			Else
				cQuery += " SE2.E2_VENCREA  = '" + Dtos(M->E2_VENCREA) 	+ "' AND "	//Totaliza pelo vencimento real
			EndIf
		ElseIf nVenctoPJ == "1"
			If Type("M->E2_EMISSAO")=="U"
				cQuery += " SE2.E2_EMISSAO  = '" + Dtos(SE2->E2_EMISSAO)	+ "' AND "
			Else
				cQuery += " SE2.E2_EMISSAO  = '" + Dtos(M->E2_EMISSAO)		+ "' AND "
			EndIf
		ElseIf nVenctoPJ == "3" .OR. EMPTY(nVenctoPJ)
			cQuery += "SE2.E2_EMIS1  = '" + Dtos(dDataBase) + "' AND "
		EndIf

		cQuery += " E2_DESDOBR <> 'S' AND "
		cQuery += " SE2.E2_TIPO NOT IN " + FormatIn(MVABATIM,"|") 		+ " AND "
		cQuery += " SE2.E2_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)	+ " AND "
		cQuery += " SE2.E2_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv)	+ " AND "
		cQuery += " SE2.E2_TIPO NOT IN " + FormatIn(MVPAGANT,cSepRec)	+ " AND "
		cQuery += " SE2.D_E_L_E_T_ = ' ' AND "

		//Verifico a filial do SED
		If cAglImPJ == "1" .OR. Empty( cFilFwSED )
			cQuery += " SED.ED_FILIAL = '"+ xFilial("SED") + "' AND "
		ElseIf Len(aFilial) > 0
			cQuery += " SED.ED_FILIAL IN ( "
			For nLoop := 1 to Len(aFilial)
				If nLoop == 1
					cQuery += "'"  + aFilial[nLoop] + "' "
				Else
					cQuery += ",'" + aFilial[nLoop] + "'"
				EndIf
			Next
			cQuery += ") AND "
		EndIf

		cQuery += " SE2.E2_NATUREZ = SED.ED_CODIGO AND "
		cQuery += " SED.ED_CALCIRF = 'S' AND "
		cQuery += " SED.D_E_L_E_T_ = ' ' "
		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBIRF", .F., .T.)

		For nX := 1 to Len(aStru)
			If aStru[nX,2] != 'C' .And. FieldPos(aStru[nX,1]) > 0 // Se existir o campo na Query
				TCSetField('TRBIRF', aStru[nX,1], aStru[nX,2],aStru[nX,3],aStru[nX,4])
			Endif
		Next

		dbSelectArea("TRBIRF")
		While !(TRBIRF->(Eof()))
			//Se for inclusao, somo todos os titulos
			//Se for alteração, somo todos os titulos exceto o que esta sendo alterado.
			If (INCLUI .AND. lFinanceiro) .OR.;
			((ALTERA .OR. !lFinanceiro) .AND.;
			SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) != TRBIRF->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) .AND.;
			EMPTY(TRBIRF->E2_FATURA) .AND. EMPTY(TRBIRF->E2_NUMLIQ))
				If (Len(aTitBord) > 0 .AND. aScan(aTitBord,{|aArrBor| aArrBor[1] == TRBIRF->SE2_RECNO}) > 0) .OR.;
				((!EMPTY(cBordero) .AND. TRBIRF->E2_NUMBOR != cBordero .AND.  !EMPTY(TRBIRF->E2_BAIXA)) .OR.;
				(!EMPTY(TRBIRF->E2_BAIXA) .AND. TRBIRF->E2_SALDO < TRBIRF->E2_VALOR))

					nTotTit := TRBIRF->E2_VALOR + If(!lInssBx,TRBIRF->E2_INSS,0)

					If !lCalcIssBx
						nTotTit += TRBIRF->E2_ISS
					EndIf

					If lSest
						nTotTit += TRBIRF->E2_SEST
					EndIf

					If lContrRet .AND. !lPccBaixa .AND. TRBIRF->(E2_PRETPIS == " " .AND. E2_PRETCOF == " " .AND. E2_PRETCSL == " ")
						nTotTit	+= TRBIRF->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL)
					EndIf

					nVlTitBor	:= NoRound(((nTotTit * Iif(AllTrim(Str(TRBIRF->E2_MOEDA,2)) $ "01",1,RecMoeda(TRBIRF->E2_EMISSAO,TRBIRF->E2_MOEDA))) * IIF(TRBIRF->ED_PERCIRF>0,TRBIRF->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100),2)
					nTotIRRF	+= nVlTitBor
					nTotInss	+= If(!lInssBx,TRBIRF->E2_INSS,0)

					//Soma os valores que deveriam ter sido retidos
					//Retidos e os pendentes (menor que valor minimo)
					If lVRetIrf
						nTotRtIr += TRBIRF->E2_VRETIRF
					Endif
					If (lAcumIr .and. !lCalcIr) .Or. cAcmIrrf	==	"2"
						nTotRtIr := 0
					Endif
				EndIf
			EndIf
			TRBIRF->(dbSkip())
		EndDo
	EndIf

	If Select("TRBIRF") > 0
		dbSelectArea("TRBIRF")
		dbCloseArea()
	Endif

	//Quando a rotina for utilizada pelo Financeiro, tenho a necessidade de calcular o IRRF do titulo presente
	//Nao ocorre com o Compras pois o mesmo já efetuou calculos
	If lFinanceiro
		If nBaseIRRF == 0
			If Type("M->E2_VALOR")=="U"
				nTotTit += SE2->E2_VALOR
			Else
				nTotTit += M->E2_VALOR
			EndIf
		Else
			If !lSRefSE2
				nTotTit := nBaseIRRF
			EndIf
		EndIf

		If !lInssBx
			If Type("M->E2_INSS")=="U"
				nTotInss += SE2->E2_INSS
			Else
				nTotInss += M->E2_INSS
			EndIf
		Endif

		If lBaseDif.and. SED->ED_BASEIRF > 0
			nBaseSED := SED->ED_BASEIRF/100
		EndIf

		If lVRetIrf .and. nBaseIRRF == 0
			If !lSRefSE2
				If Type("M->E2_VALOR")=="U"
					nBaseIRRF := SE2->E2_VALOR * nBaseSED
				Else
					nBaseIRRF := M->E2_VALOR * nBaseSED
				EndIf
			Else
				nBaseIRRF := nTotTit * nBaseSED
			EndIf
		Else
			nBaseIRRF := nBaseIRRF * nBaseSED
		EndIf
	EndIf

	//Fecha arquivo temporario
	If cAglImPJ != "1" .and. lDelTrbIR .and. (UPPER(Alltrim(TCGetDb()))!="POSTGRES")
		If InTransact()
			StartJob( "DELTRBIR" , GetEnvServer() , .T. , SM0->M0_CODIGO, IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL ),.T.,ThreadID(),cArqTmp,TCGetDb())
		Else
			DELTRBIR(SM0->M0_CODIGO, IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL ),.F.,0,cArqTmp,TCGetDb())
		EndIf
	EndIf
	dbSelectArea("SE2")
Else
	If lFinanceiro
		If nBaseIRRF == 0
			nTotTit := If( Type("M->E2_VALOR")=="U" , SE2->E2_VALOR , M->E2_VALOR )
		Else
			If !lSRefSE2
				nTotTit := nBaseIRRF
			Else
				nTotTit += nBaseIRRF
			EndIf
		EndIf

		nTotInss  := If( Type("M->E2_INSS")=="U" , If(!lInssBx,SE2->E2_INSS,0) , If(!lInssBx,M->E2_INSS,0) )

		If lBaseDif .and. SED->ED_BASEIRF > 0
			nBaseSED := SED->ED_BASEIRF / 100
		EndIf
		nBaseIRRF := nBaseIRRF * nBaseSED
	EndIf
EndIf

If lFinanceiro
	//Ponto de entrada para manipulacao da base de calculo.
	//Deve ser utilizado para tratamento de reducao da base por numero de dependentes
	//Retornar Base de Calculo
	IF lF50CIRFF
		nBaseIRRF := ExecBlock("F50CIRFF",.f.,.f.,nBaseIRRF)
	EndIf

	If !GetNewPar("MV_RNDIRF",.F.)
		If !lSRefSE2
			If Type("M->E2_MOEDA")=="U"
				nValor := NoRound(((nBaseIRRF * Iif(AllTrim(Str(SE2->E2_MOEDA,2)) $ "01",1,RecMoeda(SE2->E2_EMISSAO,SE2->E2_MOEDA))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100),2)
			Else
				nValor := NoRound(((nBaseIRRF * Iif(AllTrim(Str(M->E2_MOEDA,2)) $ "01",1,RecMoeda(M->E2_EMISSAO,M->E2_MOEDA))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100),2)
			EndIf
		Else
			nValor := NoRound((nBaseIRRF  * IIF(SED->ED_PERCIRF > 0, SED->ED_PERCIRF, GetMV("MV_ALIQIRF")) / 100),2)
		EndIf
	Else
		If !lSRefSE2
			If Type("M->E2_MOEDA")=="U"
				nValor := Round(((nBaseIRRF * Iif(AllTrim(Str(SE2->E2_MOEDA,2)) $ "01",1,RecMoeda(SE2->E2_EMISSAO,SE2->E2_MOEDA))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100),2)
			Else
				nValor := Round(((nBaseIRRF * Iif(AllTrim(Str(M->E2_MOEDA,2)) $ "01",1,RecMoeda(M->E2_EMISSAO,M->E2_MOEDA))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100),2)
			EndIf
		Else
			nValor := Round((nBaseIRRF * IIF(SED->ED_PERCIRF > 0, SED->ED_PERCIRF, GetMV("MV_ALIQIRF")) / 100),2)
		EndIf
	EndIf
Else
	dbSelectArea("SE2")
	SE2->(dbGoto(nRecAtual))
	nValor := SE2->E2_IRRF
Endif

If nTotIRRF < GetMv("MV_VLRETIR")
	nValAcum	:= nTotIrrf
	nNotRet		:= nValor
EndIf

//Se verifico a retencao atraves de campo
//Guardo o valor que deveria ser retido
//Atualizo o valor pendente de retencao mais o IRRF do titulo
If lVRetIrf
	If nTotIRRF < GetMv("MV_VLRETIR")
		If nTotIrrf > nValor
			nTotIrrf -= nValor
		EndIf
		nValor += nTotIrrf
	EndIf
	nTotIrrf += nValor
Else
	nValor -= nTotIrrf  //Diminuo do valor calculado, o IRRF já retido
EndIf

//Controle de retencao anterior no mesmo periodo
lIrfRetAnt := IIF(nTotIrrf > 0, .T., .F.)

//No novo calculo de IR pela baixa, nao se aplica valor minimo de retencao quando IR
If lNewIrBx
	lAplMinIr := IIF(lIRPFBaixa, .F., lAplMinIr)
Endif

// Verifica se o fornecedor trata o valor minimo de retencao.- FINANCEIRO
If (lFinanceiro .and. lAplMinIR .And. (nValor <= GetMv("MV_VLRETIR") .and. !lIrfRetAnt)) .OR. nValor < 0
	nValor := 0
EndIf

If lRotBorder
	aAdd(aTitBord,{SE2->(Recno()),nBaseIRRF,nValor,nNotRet,nValAcum,cBordero})
EndIf

RestArea(aArea)
RestArea(aAreaSED)
RestArea(aAreaSE2)
RestArea(aAreaSE5)

Return(nValor)

/*
±±ºPrograma  |FA50SfeExiºAutor  ³Rodrigo Gimenes     º Data ³  29/07/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³  Verifica se já foi gerado o registro de imposto para a    º±±
±±º          ³     ordem de pago.                                         º±±
*/
Function FA50SfeExi(cChave,cTipo)
Local aAreaAtu  := {}

aAreaAtu 	:= GetArea()
lRetorno 	:= .F.

dbSelectArea("SFE")

SFE->(DbSetOrder(4))

If (SFE->(DbSeek(cChave)))
	While !SFE->(Eof())
		If SFE->FE_TPTIMP == cTipo
			lRetorno := .T.
			Exit
		EndIf
		SFE->(dbSkip())
		Loop
	EndDo
Endif
//RestArea(aAreaSfe)
RestArea(aAreaAtu)
Return(lRetorno)

/*
±±ºPrograma  ³FINA050   ºAutor  ³Marcos R. Pires     º Data ³  04/10/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Retorna o código do aprovador para o campo E2_CODAPRO      º±±
*/
Function FA050Aprov(nMoeda)
Local aSaveArea	:= GetArea()
Local aSaveFRP	:= {}
Local cRet		:= CriaVar("E2_CODAPRO",.F.)
Local cMoedaTit	:= ""

Default nMoeda	:= CriaVar("E2_MOEDA",.F.)

//Verifica a existencia da tabela

aSaveFRP := FRP->(GetArea())

If nMoeda > 0

	cMoedaTit := StrZero(nMoeda,TamSx3("E2_MOEDA")[1])

	//Verifica se o parametro contem o codigo do aprovador ou comando a ser executado
	cRet := &(SuperGetMv(("MV_FINAP"+cMoedaTit),.F.,""))

	If Empty(cRet) .Or. ValType(cRet) != "C" .Or. Len(AllTrim(cRet)) > TAMSX3("E2_CODAPRO")[1]
		cRet := SuperGetMv(("MV_FINAP"+cMoedaTit),.F.,"")
	EndIf

	//Verifica se o registro existe na tabela FRP
	If !Empty(cRet) .And. Len(AllTrim(cRet)) <= TAMSX3("E2_CODAPRO")[1]
		dbSelectArea("FRP")
		dbSetOrder(1) //FRP_FILIAL+FRP_COD+FRP_MOEDA
		If !(dbSeek(xFilial("FRP")+cRet+cMoedaTit))
			cRet := CriaVar("E2_CODAPRO",.F.)
			Help(" ",1,"MV_FINAP"+cMoedaTit)
		EndIf
	Else
		cRet := CriaVar("E2_CODAPRO",.F.)
	EndIf

EndIf

RestArea(aSaveFRP)

RestArea(aSaveArea)

Return(cRet)

/*
±±ºPrograma  ³FA050VldApºAutor  ³Marcos R. Pires     º Data ³  04/10/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Valida se o aprovador informado no campo E2_CODAPROD condizº±±
±±º          ³ com a moeda do titulo. (X3_VALID)                          º±±
*/
Function FA050VldAp(cAprov, nMoeda)
Local aSaveArea	:= GetArea()
Local aSaveFRP	:= {}
Local lRet		:= .T.
Local cCtAl 	:= SuperGetMV( "MV_FINCTAL", .T., "1" )

aSaveFRP := FRP->(GetArea())

dbSelectArea("FRP")
dbSetOrder(1)
If !(dbSeek(xFilial("FRP")+cAprov+StrZero(nMoeda,TamSX3("E2_MOEDA")[1])))
	lRet := .F.
	Help(" ",1,"CODAPRO")
ElseIf cCtAl = '2' .And. FRP->FRP_MSBLQL = '1'
	Help(" ",1,"APROBLQ" ,, STR0227, 1, 0 )
EndIf

RestArea(aSaveFRP)

RestArea(aSaveArea)

Return lRet

/*
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FA050CpXmlºAutor  ³Jefferson Lima      º Data ³  25/11/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Complementa o Xml recebido pelo EAI para preenchimento das º±±
±±º          ³ chaves primaria do protheus										  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Integracao OMS x GFE                                       º±±
*/
Function F050CpXml(  )

Local cRet    	:= PARAMIXB[1]
Local aArea		:= GetArea()
Local oXml	 	:= Nil
Local lRet      := .F.
Local cCGC		:= ""
Local nTotReg 	:= 0
Local nRegAtu 	:= 1
Local lIntGFE   := SuperGetMv('MV_INTGFE',,.F.)

If lIntGFE
	oXml := tXmlManager():New()

	lRet := oXml:Parse(cRet)

	If lRet
		lRet := oXml:XPathHasNode("//FINA050/FINA050_SE2/E2_CGCFOR/value")
		If lRet
			cCgc := AllTrim( oXml:XPathGetNodeValue("//FINA050/FINA050_SE2/E2_CGCFOR", "value") )
			SA2->(DbSetOrder(3))
			If SA2->(MsSeek(xFilial("SA2") + cCgc))
				While SA2->(!Eof()) .And. AllTrim( SA2->A2_CGC ) == cCgc
					If SA2->A2_MSBLQL <> '1'
						If oXml:XPathAddNode("//FINA050/FINA050_SE2","E2_FORNECE", '')
							If oXml:XPathAddAtt("//FINA050/FINA050_SE2/E2_FORNECE","order","98")
								If oXml:XPathAddNode("//FINA050/FINA050_SE2","E2_LOJA"   , '')
									If oXml:XPathAddAtt("//FINA050/FINA050_SE2/E2_LOJA","order","99")
										If oXml:XPathAddNode("//FINA050/FINA050_SE2/E2_FORNECE","value", SA2->A2_COD)
											If oXml:XPathAddNode("//FINA050/FINA050_SE2/E2_LOJA"   ,"value", SA2->A2_LOJA)
												cRet := oXml:Save2String()
												If oXml:xPathHasNode("//FINA050/FINA050_SE2/FINA050_PRVSE2/items")
													nTotReg := oXml:XPathChildCount("//FINA050/FINA050_SE2/FINA050_PRVSE2/items")
													nRegAtu := 1
													While nRegAtu <= nTotReg
														If oXml:XPathAddNode("//FINA050/FINA050_SE2/FINA050_PRVSE2/items/item["+(AllTrim(Str(nRegAtu)))+"]","E2_FORNECE",SA2->A2_COD)
															If oXml:XPathAddNode("//FINA050/FINA050_SE2/FINA050_PRVSE2/items/item["+(AllTrim(Str(nRegAtu)))+"]","E2_LOJA",SA2->A2_LOJA)
															EndIf
														EndIf
														nRegAtu++
													EndDo
													cRet := oXml:Save2String()
												EndIf
											EndIf
										EndIf
									EndIf
								EndIf
							EndIf
						EndIf
						Exit
					EndIf
					SA2->(dbSkip())
				EndDo
			EndIf
		EndIf
	EndIf
EndIf

RestArea(aArea)

Return cRet

/*/
±±³Fun‡„o    ³FCriaFII   ³ Autor ³Mauricio Pequim Jr    ³ Data ³27.06.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Funcao que cria os registros de relacionamento de titulos    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1 : Alias do registro  do titulo origem                  ³±±
±±³          ³ExpC2 : Prefixo Origem                                       ³±±
±±³          ³ExpC3 : Numero Origem                                        ³±±
±±³          ³ExpC4 : Parcela Origem                                       ³±±
±±³          ³ExpC5 : Tipo Origem                                          ³±±
±±³          ³ExpC6 : Fornecedor Origem                                    ³±±
±±³          ³ExpC7 : Loja Origem                                          ³±±
±±³          ³ExpC8 : Alias do registro  do titulo destino                 ³±±
±±³          ³ExpC9 : Prefixo Destino                                      ³±±
±±³          ³ExpC10: Numero Destino                                       ³±±
±±³          ³ExpC11: Parcela Destino                                      ³±±
±±³          ³ExpC12: Tipo Destino                                         ³±±
±±³          ³ExpC13: Fornecedor Destino                                   ³±±
±±³          ³ExpC14: Loja Destino                                         ³±±
±±³          ³ExpC15: Loja Destino                                         ³±±
±±³          ³ExpC16: Filial destino                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo criar o registro relacionado ao³±±
±±³          ³titulo aglutinador                                           ³±±
/*/
Function FCriaFII(cEntOri, cPrefOri, cNumOri, cParcOri, cTipoOri, cCfOri, cLojaOri,;
cEntDes, cPrefDes, cNumDes, cParcDes, cTipoDes, cCfDes, cLojaDes,;
cFilDes, cFIISeq )

Local aArea			:= GetArea()

RecLock("FII",.T.)
FII->FII_FILIAL := xFilial("FII")
FII->FII_ENTORI := cEntOri
FII->FII_PREFOR := cPrefOri
FII->FII_NUMORI := cNumOri
FII->FII_PARCOR := cParcOri
FII->FII_TIPOOR := cTipoOri
FII->FII_CFORI  := cCfOri
FII->FII_LOJAOR := cLojaOri

FII->FII_ENTDES := cEntDes
FII->FII_PREFDE := cPrefDes
FII->FII_NUMDES := cNumDes
FII->FII_PARCDE := cParcDes
FII->FII_TIPODE := cTipoDes
FII->FII_CFDES  := cCfDes
FII->FII_LOJADE := cLojaDes
FII->FII_FILDES := cFilDes
FII->FII_SEQ    := cFIISeq
FII->FII_ROTINA := FUNNAME()
FII->FII_OPERAC := "  "
FII->(MsUnlock())

RestArea(aArea)

Return Nil


/*
±±ºPrograma  ³F050RetPR ºAutor  ³ Carlos A. Queiroz  º Data ³  06/27/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Efetua o estorno de titulos provisorios.                   º±±
*/
Function F050RetPR(nRecnoSE2)
Local cWhileFII := (xFilial("SE2")+"SE2"+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA)
Local aAreaSE2	:= SE2->(GetArea())
Local aAreaSA2	:= SA2->(GetArea())
Local cChaveTit := ""
PRIVATE lMsErroAuto := .F.
Default nRecnoSE2  := 0
If nRecnoSE2 > 0 // Passou a ser chamado após a contabilizaão da Exclusão do PA.
	SE2->(dbGoTo(nRecnoSE2))
	cWhileFII := (xFilial("SE2")+"SE2"+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA)
Endif

dbselectarea("FII")
dbsetorder(2)
If dbseek(xFilial("FII")+"SE2"+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA)
	While cWhileFII == (FII->FII_FILDES+"SE2"+FII->FII_PREFDE+FII->FII_NUMDES+FII->FII_PARCDE+FII->FII_TIPODE+FII->FII_CFDES+FII->FII_LOJADE)

		cChaveTit := FII->(FII_PREFOR + FII_NUMORI + FII_PARCOR + FII_TIPOOR + FII_CFORI + FII_LOJAOR)

		lMsErroAuto := .F.
		dbselectarea("SE5")
		dbsetorder(7)
		If dbseek(xFilial("SE5")+cChaveTit)

			aVetor 	:= {{"E2_PREFIXO"	, SE5->E5_PREFIXO 		,Nil},;
			{"E2_NUM"		, SE5->E5_NUMERO       	,Nil},;
			{"E2_PARCELA"	, SE5->E5_PARCELA  		,Nil},;
			{"E2_TIPO"	    , SE5->E5_TIPO     		,Nil},;
			{"E2_FORNECE"   , SE5->E5_CLIFOR   		,Nil},;
			{"E2_LOJA"	    , SE5->E5_LOJA     		,Nil},;
			{"AUTMOTBX"	    , SE5->E5_MOTBX      	,Nil},;
			{"AUTDTBAIXA"	, SE5->E5_DATA			,Nil},;
			{"AUTDTCREDITO" , SE5->E5_DTDISPO		,Nil},;
			{"AUTHIST"	    , STR0209+alltrim(SE5->E5_PREFIXO)+STR0210+alltrim(SE5->E5_NUMERO)+STR0211+alltrim(SE5->E5_PARCELA)+STR0212+alltrim(SE5->E5_TIPO)+"."	,Nil},; //"Estorno de Baixa referente a substituicao de titulo tipo Provisorio para Efetivo. Prefixo: "#", Numero: "#", Prc: "#", Tp: "
			{"AUTVALREC"	, SE5->E5_VALOR		    ,Nil}}


			MSExecAuto({|x,y| Fina080(x,y)},aVetor,5)

			// Recupera MV_PAR (F12) da rotina FINA050
			Pergunte("FIN050",.F.)

			If lMsErroAuto
				DisarmTransaction()
				MostraErro()
			ElseIf Empty(SE2->E2_BAIXA)
				Reclock("FII" ,.F.,.T.)
				FII->(dbDelete())
				FII->(MsUnlock())
			EndIf

			SE2->(DbSetOrder(1))
			If SE2->(MsSeek( xFilial("SE2") + cChaveTit)) .And. SE2->E2_FLUXO == "S"
				AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, If(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"3","2"), "P", SE2->E2_VALOR, SE2->E2_VLCRUZ,If(SE2->E2_TIPO $ MVABATIM, "-", "+"),,FunName(),"SE2",SE2->(Recno()))
			EndIf

		EndIf
		FII->(DbSkip())
	EndDo

EndIf

RestArea(aAreaSE2)
RestArea(aAreaSA2)

Return .T.

/*
±±ºPrograma  ³PlsInssAcm   ºAutor  ³Microsiga           º Data ³  03/09/12   º±±
*/
Function PlsInssAcm(cCodOpe,cCodRDA,cAno,cMes)
Local cCod170 := GetNewPar("MV_PLSCIOE","")
Local lNroPgt
Local lRoundIns	:= GetNewPar("MV_RNDINS",.F.)
Local nValInss := 0
Local nTotCre := 0
Local lCposVld	:= .T.

If !Empty(cCod170)
	cOriLan := "BGQ"
	cSQL := "SELECT BGQ_CC AS CC, BGQ_VERBA, BGQ_TIPOCT AS TIPOCT, BGQ_CODLAN AS CODLAN, BGQ_VALOR AS VALOR,BGQ_INCIR AS INCIR,BGQ_INCINS AS INCINS, "
	cSQL += "BGQ_INCPIS AS INCPIS,BGQ_INCCOF AS INCCOF, BGQ_INCCSL AS INCCSL "
	cSQL += " FROM "+RetSQLName("BGQ")+" WHERE "
	cSQL += " ( BGQ_FILIAL = '"+xFilial("BGQ")+"' ) AND "
	cSQL += " ( BGQ_CODIGO = '"+cCodRDA+"' ) AND "
	cSQL += " ( BGQ_ANO = '" + cAno + "' AND BGQ_MES = '"+ cMes +"' ) AND "
	cSQL += " ( BGQ_ATIVO  <> '0' ) AND "
	cSQL += " ( BGQ_CODLAN = '" + AllTrim(cCod170) + "' ) AND ( BGQ_TIPO = '3' ) AND "
	cSQL += " ( BGQ_CODOPE = '"+cCodOpe+"' ) AND "
	cSQL += " ( BGQ_OPELOT = '    ' ) AND "
	cSQL += " ( BGQ_NUMLOT = '          ' ) AND "
	cSQL += " ( D_E_L_E_T_ = ' ' ) "


	cSQL := ChangeQuery(cSQL)

	//--Processa a query e adequa os campos
	DbUseArea(.T.,"TOPCONN",TcGenQry(,,cSQL),"TrbMPG",.T.,.T.)
	TcSetField("TrbMPG","VALOR","N",TamSX3("BGQ_VALOR")[1],TamSX3("BGQ_VALOR")[2])

	//³ Se nao encontrou em debitos/creditos variaveis o lancamento ref a   ³
	//³ "Sal Contrib INSS Outras Empresas" busca em debitos/creditos fixos. ³
	If TrbMPG->(Eof())
		TrbMPG->(DbCloseArea())
		cOriLan := "BBC"
		cSQL := "SELECT BBC_CODSER AS CODLAN, BBC_CC AS CC, BBC_VALOR AS VALOR "
		cSQL += ", BBC_NROPGT "
		lNroPgt := .T.
		cSQL += " FROM "+RetSQLName("BBC")+" WHERE "
		cSQL += " ( BBC_FILIAL = '"+xFilial("BBC")+"' ) AND "
		cSQL += " ( BBC_CODIGO = '"+cCodRDA+"' ) AND "
		cSQL += " ( BBC_PROMED = '1' ) AND "
		cSQL += " ( BBC_STATUS = '1' ) AND "
		// BOPS 98697
		cSQL += " ( BBC_CODSER = '" + AllTrim(cCod170) + "' ) AND  ( BBC_DEBCRE = '3' ) AND "
		If lCposVld
			cSQL += " ( '" + cAno + cMes + "01' >= BBC_VLDINI ) AND "
			cSQL += " ( ( '" + DtoS(LastDay(CtoD("01/"+cMes+"/"+cAno))) + "' <= BBC_VLDFIM ) OR ( BBC_VLDFIM = '        ' ) ) AND "
		EndIf
		cSQL += " ( D_E_L_E_T_ = ' ' ) "

		cSQL := ChangeQuery(cSQL)

		//--Processa a query e adequa os campos
		DbUseArea(.T.,"TOPCONN",TcGenQry(,,cSQL),"TrbMPG",.T.,.T.)
		TcSetField("TrbMPG","VALOR","N",TamSX3("BGQ_VALOR")[1],TamSX3("BGQ_VALOR")[2])

	EndIf

	nTotCre := 0
	BBB->(DbSetOrder(1))
	While ! TrbMPG->(Eof())

		If cOriLan == "BBC" .And. ;
		! PLMOVCRE(cCodRDA,cAno,cMes,,IIf(lNroPgt,IIf(Empty(TrbMPG->BBC_NROPGT),"1",TrbMPG->BBC_NROPGT),"1"),cCod170)
			TrbMPG->(DbSkip())
			Loop
		EndIf

		nTotCre += TrbMPG->VALOR


		TrbMPG->(DbSkip())
	Enddo
	TrbMPG->(DbCloseArea())


EndIf
If nTotCre == 0

	//³ Monta query                                                         ³
	cSQL := " SELECT BMR_ANOLOT ANOLOT, BMR_MESLOT MESLOT, BMR_CODLAN CODLAN, BMR_VLRPAG VALOR, BMR.R_E_C_N_O_  BMR_RECNO  "
	cSQL += "  FROM " + RetSQLName("BMR") + " BMR "
	cSQL += "  WHERE BMR_FILIAL = '" + xFilial("BMR") + "' "
	cSQL += "    AND BMR_CODRDA = '" + cCodRda + "' "
	cSQL += "    AND BMR_OPELOT = '" + cCodOpe + "' "
	cSQL += "    AND BMR_ANOLOT = '" + cAno + "' "
	cSQL += "    AND BMR_MESLOT = '" + cMes + "' "
	cSQL += "    AND BMR_CODLAN = '170' "

	cSQL += "    AND BMR.D_E_L_E_T_ = ' ' "
	cSQL += " ORDER BY BMR_FILIAL, BMR_OPERDA, BMR_CODRDA, BMR_OPELOT, BMR_ANOLOT, BMR_MESLOT, BMR_NUMLOT "

	cSQL := ChangeQuery(cSQL)

	//--Processa a query e adequa os campos
	DbUseArea(.T.,"TOPCONN",TcGenQry(,,cSQL),"TrbBMR",.T.,.T.)
	TcSetField("TrbBMR","VALOR","N",TamSX3("BMR_VLRPAG")[1],TamSX3("BMR_VLRPAG")[2])

	While ! TrbBMR->(Eof())


		nTotCre += TrbBMR->VALOR


		TrbBMR->(DbSkip())
	Enddo
	TrbBMR->(DbCloseArea())
Endif

If lRoundIns
	nValInss := Round((nTotCre * (SED->ED_PERCINS/100)),2)
Else
	nValInss := NoRound((nTotCre * (SED->ED_PERCINS/100)),2)
EndIf

Return(nValInss)

/*/{Protheus.doc} IntegDef
Função para integração via Mensagem Única Totvs.

@author  Felipe Raposo
@version P12.1.17
@since   07/05/2018
/*/
Static Function IntegDef(cXml, cTypeTrans, cTypeMsg, cVersion, cTransac)
Return FINI050(cXml, cTypeTrans, cTypeMsg, cVersion, cTransac)

/*
±±ºPrograma  ³PMSProjPmsºAutor  ³Clovis Magenta      º Data ³  04/06/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao para atualizar campo E2_PROJPMS na substitucao		  º±±
*/
Function PMSProjPms(aNtit)
Local aArea		:= GetArea()
Local aAreaSE2	:= SE2->(GetArea())
Local nX			:= 0
Default aNtit	:= {}

dbSelectArea("SE2")

For nX:= 1 to Len(aNtit)

	If aNtit[nX][14]
		SE2->(dbGoTo(aNtit[nX][13]))
		Reclock("SE2", .F.)
		SE2->E2_PROJPMS := "1"
		MsUnlock()
	Endif

Next nX

RestArea(aAreaSE2)
RestArea(aArea)

Return

/*
±±ºPrograma  ³fa050DelRatºAutor  ³Karen Honda        º Data ³  21/01/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Deleta os registros de rateio ao clicar em Fechar, para nãoº±±
±±º          ³ ser gravada indevidamente                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Rateio                                                     º±±
*/
Static Function fa050DelRat()
dbSelectArea("TMP")
dbGotop()
While TMP->(!Eof())
	If !TMP->CTJ_FLAG
		TMP->CTJ_FLAG := .T.		//Deleto as linhas
	EndIf
	TMP->(DBskip())
EndDo
Return

/*{Protheus.doc} F050AUTAFR (nOpc)
Rotina para gravação automatica de rateio de projetos
@param nOpc - Opção da rotina (3 inclusao, 4 alteração)
@return lRet - Retorna se foi possível ou não incluir o rateio
@since 	15/02/2013
@version 	P11
*/
Function F050AutAFR(nOpc)

Local lRet:=.T.

If FwIsInCallStack("EnchAuto")
	PmsDlgFI(nOpc,M->E2_PREFIXO,M->E2_NUM,M->E2_PARCELA,M->E2_TIPO,M->E2_FORNECE,M->E2_LOJA,.F.)
	IF Empty(aRatAFR)
		lRet:=.F.
	Endif
Endif

Return lRet

/*
±±³Fun‡„o    ³ BuscaSE5  ³ Autor ³ Karen Honda            ³ Data ³ 15/04/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Busca a baixa do titulo pai do desdobramento                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ BusaSE5(TIPODOC,PREFIXO,NUMERO,PARCELA,TIPO,MotBx           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA050                                                     ³±±
*/
Static Function BuscaSE5(cTipoDoc, cPrefixo, cNumero, cParcela, cTipo, cMotBx)
Local lRet := .F.
Local cQuery := ""

cQuery := "SELECT E5_FILIAL,E5_TIPODOC,E5_PREFIXO,E5_NUMERO,E5_PARCELA,E5_TIPO "
cQuery += "FROM " + RetSqlName("SE5")
cQuery += " WHERE E5_FILIAL = '" + xFilial("SE5") + "' AND"
cQuery += "	E5_TIPODOC = '" + cTipoDoc + "' AND"
cQuery += "	E5_PREFIXO = '" + cPrefixo + "' AND"
cQuery += "	E5_NUMERO = '"  + cNumero  + "' AND"
cQuery += "	E5_PARCELA = '" + cParcela + "' AND"
cQuery += "	E5_TIPO = '"    + cTipo    + "' AND"
cQuery += "	E5_MOTBX = 'DSD' AND D_E_L_E_T_ = ' '"

DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"QRY",.T.,.T.)
If QRY->(!Eof())
	lRet := .T.
EndIf
QRY->(DBCloseArea())

Return lRet


/*/{Protheus.doc}FA050VLMV
Verifica se na inclusão de titulos, tipo PA.
A Natureza permite movimentação bancaria.

@author Thiago Malaquias
@since  27/05/2014
@version 12
/*/

Function FA050VLMV()

Local lRet := .T.
Local aArea := GetArea()

If 	M->E2_TIPO $ MVPAGANT .And. Posicione("SED",1,xfilial("SED") + M->E2_NATUREZ,"ED_MOVBCO") == "2"
	Help(" ",1,"FA050VLMV", , STR0234,1,0) //"A natureza não permite movimento bancário"
	lRet:=.F.
EndIf

RestArea(aArea)

Return lRet

/*/{Protheus.doc} F50VldBCOF
Função de validação dos dados bancários do fornecedor do título a pagar
@author Marylly Araújo Silva
@since 09/06/2014
@version P1180
@return Retorno Booleano da validação dos dados da conta bancária do fornecedor no título a pagar
/*/
Function F50VldBCOF()
Local lRet			:= .T.
Local aArea		:= GetArea()
Local aFILArea	:= {}
Local aSA2Area	:= {}
Local cFilFIL		:= FWXFilial("FIL")
Local lClosed		:= .F.

If !EMPTY( M->E2_FORBCO + M->E2_FORAGE + M->E2_FORCTA )
	DbSelectArea( "FIL" ) //Contas Bancárias de Fornecedores
	aFILArea := FIL->( GetArea() )
	FIL->( DbSetOrder(1) ) //Filial + Fornecedor + Loja  + Tipo + Banco + Agencia + Conta

	DbSelectArea( "SA2" )
	aSA2Area := SA2->( GetArea() ) //Cadastro de Fornecedores
	SA2->( DbSetOrder(1) ) //Filial + Fornecedor + Loja

	/*
	* Se o fornecedor estiver preenchido.
	*/
	If SA2->( msSeek( FWXFilial("SA2") + M->E2_FORNECE + M->E2_LOJA ) )
		If AllTrim(SA2->A2_BANCO) <> AllTrim(M->E2_FORBCO) .OR. AllTrim(SA2->A2_AGENCIA) <> AllTrim(M->E2_FORAGE) .OR. AllTrim(SA2->A2_NUMCON) <> AllTrim(M->E2_FORCTA)
			If FIL->( msSeek( cFilFIL + M->E2_FORNECE + M->E2_LOJA ) )
				While FIL->( !Eof() .AND. cFilFIL + AllTrim(M->E2_FORNECE) + AllTrim(M->E2_LOJA) == FIL->FIL_FILIAL + AllTrim(FIL->FIL_FORNEC) + AllTrim(FIL->FIL_LOJA) )
					If AllTrim(M->E2_FORBCO) + AllTrim(M->E2_FORAGE) + AllTrim(M->E2_FORCTA) == AllTrim(FIL->FIL_BANCO) + AllTrim(FIL->FIL_AGENCI) + AllTrim(FIL->FIL_CONTA)
						If cPaisLoc == "RUS" .And. FIL->FIL_CLOSED == "1"
							Help("",1,"FA050BANKCLOSED") //This bank is closed and cannot be used.
							lRet := .F.
							lClosed := .T.
						Else
							lRet := .T.
						Endif
						EXIT
					Else
						lRet := .F.
					EndIf
					FIL->( DbSkip() )
				EndDo
			ElseIf !EMPTY( M->E2_FORBCO + M->E2_FORAGE + M->E2_FORCTA )
				lRet := .F.
			EndIf

			If !lRet .And. !lClosed
				Help( ,, 'F50VldBCOF',,STR0236 + CRLF + STR0237, 1, 0) //'Dados bancários do fornecedor inexistente no cadastro.' // 'Por favor, regularize as contas bancárias no cadastro de Fornecedores.'
			EndIf
		EndIf
	EndIf

	RestArea(aFILArea)
	RestArea(aSA2Area)
EndIf
RestArea(aArea)
Return lRet

/*/{Protheus.doc} F050VlCpos
Função de validação dos campos digitados em memoria em busca de caracteres especiais
@author TOTVS S/A
@since 13/06/2014
@version P1180
@return Retorno Booleano da validação dos dados
/*/
Function F050VlCpos()
Local nX := 1
Local aStruct := SE2->( dbStruct() )
Local lOk := .T.
Local cCposVld := "|E2_FILIAL|E2_PREFIXO|E2_NUM|E2_PARCELA|E2_TIPO|E2_FORNECE|E2_LOJA|" //Campos Considerados na validacao (Campos Chave da tabela)
Do While nX <= Len(aStruct) .And. lOk
	If Upper(aStruct[nX][2]) == "C" .And. Upper(Alltrim(aStruct[nX][1])) $ cCposVld
		If CHR(39) $ M->&(Alltrim(aStruct[nX][1]))	 .Or. ;
		CHR(34) $ M->&(Alltrim(aStruct[nX][1]))
			lOk := .F.
		Endif
	Endif
	nX++
Enddo
If !lOk
	Help("",1,"INVCAR",,STR0235,1,0) //"Informe caracteres válidos no preenchimento dos campos"
Endif
Return lOk

/*/{Protheus.doc} F050VldVlr
Verifica se o valor do título está negativo.
@author Daniel Mendes
@since 18/11/2014
@version P12
/*/
Function F050VldVlr()
Local lRet       := .T.
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

// Controla IRPF na Baixa
Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)

Local lCalcIssBx :=  IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

If  !(M->E2_TIPO $ MVPROVIS) .and. ( M->E2_VALOR + M->E2_ACRESC ) - ( Iif( lCalcIssBx , M->E2_ISS , 0 ) +;
Iif( lIRPFBaixa , M->E2_IRRF , 0 ) +;
Iif( lPCCBaixa , M->E2_CSLL + M->E2_COFINS + M->E2_PIS , 0 ) +;
M->E2_DECRESC ) <= 0
	MsgAlert( STR0243 , STR0115 )
	lRet := .F.
EndIf

If lRet
	IF IIF(Type("ALTERA") == "U", .F., ALTERA)
		If nOldSaldo !=  SE2->E2_SALDO
			nOldSaldo :=  SE2->E2_SALDO
		EndIf
	EndIf
EndIf
Return lRet

/*/{Protheus.doc} F050TitRet
Verifica se o título retentor de impostos foi gerado em outro módulo.
@author TOTVS S/A
@since 05/01/2015
@version P12
@return Retorno Booleano da validação dos dados
/*/
Function F050TitRet()
Local aArea		:= {}
Local aSE2		:= {}
Local lRet		:= .F.
Local lSFQ		:= .F.
Local cQuery	:= ""
Local cAliasSE2	:= ""
Local lPCCBaixa	:= SuperGetMv("MV_BX10925",.T.,"2") == "1"

If !lPCCBaixa
	aArea := GetArea()
	aSe2 := SE2->(GetArea())
	//Busco a informacao de qual o titulo retentor do PCC do titulo em alteracao
	SFQ->(DbSetOrder(2)) //-- FQ_FILIAL+FQ_ENTDES+FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES
	If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
		lSFQ := .T.
		//Posiciono no cadastro de C.Pagar para verificar se o titulo retentor
		//foi contabilizado ou veio de outro modulo
		SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
		If SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI)))
			//Titulos contabilizados
			//os titulos vindos de outros modulos sempre tem E2_LA = 'S' ja que a contabilizacao ocorre na origem
			If !(AllTrim(SE2->E2_ORIGEM) == "FINA050") .Or. SE2->E2_LA == "S"
				lRet := .T.
			Endif
		Endif
	Else
		//Verifico se o titulo eh retentor do PCC de outros titulos
		SFQ->(DbSetOrder(1)) //-- FQ_FILIAL+FQ_ENTORI+FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI
		If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
			lSFQ := .T.
			//Titulos contabilizados
			//os titulos vindos de outros modulos sempre tem E2_LA = 'S' ja que a contabilizacao ocorre na origem
			If !(AllTrim(SE2->E2_ORIGEM) == "FINA050") .Or. SE2->E2_LA == "S"
				lRet := .T.
			Endif
		Endif
	Endif
	If !lSFQ
		If !(AllTrim(SE2->E2_ORIGEM) == "FINA050") .Or. SE2->E2_LA == "S"
			cQuery := "select R_E_C_N_O_ from " + RetSQLName("SE2")
			cQuery += " where E2_FILIAL = '" + xFilial("SE2") + "'"
			cQuery += " and E2_NUM = '" + SE2->E2_NUM + "'"
			cQuery += " and E2_PREFIXO = '" + SE2->E2_PREFIXO + "'"
			cQuery += " and E2_TIPO in " + FormatIn(MVTAXA+"/"+MVTXA,"/")
			cQuery += " and ("
			cQuery += " E2_NATUREZ = '" + AllTrim(GetMv("MV_PISNAT")) + "' or"
			cQuery += " E2_NATUREZ = '" + AllTrim(GetMv("MV_COFINS")) + "' or"
			cQuery += " E2_NATUREZ = '" + AllTrim(GetMv("MV_CSLL")) + "'"
			cQuery += ")"
			cQuery += " and D_E_L_E_T_=' '"

			cQuery := ChangeQuery(cQuery)
			cAliasSE2 := GetNextAlias()
			DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSE2,.F.,.T.)
			lRet := !((cAliasSE2)->(Eof()))
			DbSelectArea(cAliasSE2)
			DbCloseArea()
		Endif
	Endif

	RestArea(aSE2)
	RestArea(aArea)
Endif
Return(lRet)


/*/{Protheus.doc} F050VERRAT
Validação do campo E2_RATEIO
@author TOTVS S/A
@since 24/02/2015
@version P12.1.4
@return Retorno Booleano da validação dos dados
/*/
FUNCTION F050VERRAT()

Local lRet := .T.

//E2_RATEIO
If GetMv("MV_RATDESD",,"2") != "1" // Se nao rateia desdobramento
	lRet := (M->E2_DESDOBR == "N")
Else
	lRet := (M->E2_MULTNAT != "1")
Endif


RETURN lRet
/*/{Protheus.doc} F050VERDES
Validação do campo E2_DESDOBR
@author TOTVS S/A
@since 24/02/2015
@version P12.1.4
@return Retorno Booleano da validação dos dados
/*/

FUNCTION F050VERDES()

Local lRet := .T.
//E2_DESDOBR

If GetMv("MV_RATDESD",,"2") != "1" // Se nao rateia desdobramento
	lRet := (M->E2_RATEIO == "N")
Endif


RETURN lRet

/*/{Protheus.doc} F050VERMUL
Validação do campo E2_MULTNAT
@author TOTVS S/A
@since 24/02/2015
@version P12.1.4
@return Retorno Booleano da validação dos dados
/*/

FUNCTION F050VERMUL()

Local lRet := .T.
//E2_MULTNAT

If GetMv("MV_RATDESD",,"2") == "1" // Se nao rateia desdobramento
	lRet := (MV_MULNATP .And. M->E2_RATEIO == "N")
Endif


RETURN lRet

/*/{Protheus.doc} FIN050RET
Função chamada do gatilho do fornecedor
para gatilhar o campo de retenão do inss (E2_RETINS)
@author TOTVS S/A
@since 25/06/2015
@version P12.1.6
@return Retorno Caracter com o conteudo que ira ser gatilhado
/*/
Function FIN050RET
Local cRet := ""
Local aArea:= GetArea()
Local cTpFor 	:= GetAdvFval("SA2","A2_TIPO",xFilial("SA2")+M->E2_FORNECE+M->E2_LOJA,1,"")

//Tipo do fornecedor

IF ( cTpFor == "J" )
	cRet := SuperGetmv("MV_RETINPJ")
else
	cRet:= SuperGetmv("MV_RETINPF")
EndIF

RestArea(aArea)
Return cRet

/*/{Protheus.doc} FInsDif
Verifica se o título de Inss teve sua natureza padrão alterada
@author TOTVS S/A
@since 04/06/2015
@version P11
@return Retorno Booleano da validação dos dados
/*/
Static Function FInsDif(cTitPai)
Local aArea 	:= GetArea()
Local lInssBx := SuperGetMv("MV_INSBXCP",.F.,"2") == "1" // Controla INSS na Baixa
Local lRet		:= .F.
Local cQuery	:= ""
Local cForInss	 := GetMv("MV_FORINSS")
Local nTamFornc	:= TAMSX3("E2_FORNECE")[1]
Local nTamLj		:= TAMSX3("E2_LOJA")[1]

If !lInssBx

	cQuery	:= "SELECT E2_NUM "
	cQuery	+= " FROM " + RetSqlName("SE2") + " SE2 "
	cQuery	+= " WHERE E2_NUM = '" + SE2->E2_NUM + "' "
	cQuery	+= " AND E2_TIPO = '" + MVINSS + "' "
	cQuery += " AND E2_PARCELA = '" + SE2->E2_PARCELA + "' "
	If Len(AllTrim(cForInss)) <= nTamFornc
		cQuery	+= " AND E2_FORNECE = '" + cForInss + "' "
	Else
		cQuery	+= " AND E2_FORNECE = '" + Substr(cForInss, 1, nTamFornc) + "' "
		cQuery	+= " AND E2_LOJA = '" + Substr(cForInss, nTamFornc + 1, nTamLj) + "' "
	EndIf
	cQuery	+= " AND RTRIM(LTRIM(E2_TITPAI)) = '" + cTitPai + "' "
	cQuery	+= " AND D_E_L_E_T_ = '' "

	cQuery := ChangeQuery(cQuery)

	DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"cAlias",.F.,.T.)
	lRet := !Empty(cAlias->E2_NUM)

EndIf

DbSelectArea("cAlias")
DbCloseArea()
RestArea(aArea)

Return lRet

/*/{Protheus.doc} FN50Log
Consulta log de atualizações
@author Rodolfo Novaes
@since  28/10/2015
@version 12
/*/
Function FN50Log()
Local cIdDoc 	:= ""
Local cChaveTit := ""


cChaveTit := xFilial("SE2") + "|" + SE2->E2_PREFIXO + "|" + SE2->E2_NUM + "|" + SE2->E2_PARCELA + "|" +;
					 SE2->E2_TIPO + "|" + SE2->E2_FORNECE + "|" + SE2->E2_LOJA

cIdDoc    := FINGRVFK7("SE2", cChaveTit)

ProcLogView( cFilAnt, cIdDoc)

Return .T.

/*
±±ºPrograma  ³F050AvFlags ºAutor ³Laercio G Souza Jr º Data ³  18/05/16     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Função para executar a chamado da função AvFlags na alteraçãoº±±
±±ºDesc.     ³ do titulo no financeiro                                      º±±
*/
Function F050EasyOrig(cOrigem)
return EasyOrigem(cOrigem)


/*/{Protheus.doc} F050ExcTmp
Cria arquivo temporario para GetDb
@author Fabio Casagrande Lima
@since 02.01.17
@version 12.1.14
/*/
Static Function F050ExcTmp(cExclLP,lExclDsd)

Local     aCpos     := {}
Local     aAltera   := {}
Private   cPrograma	:= "FINA050"
Default   cExclLP   := "512"

//Determina LP, já que é parametro para a função F050HeadCT
IF !E2_TIPO $ MVPROVIS .or. mv_par02 == 1
	IF SE2->E2_TIPO $ MVPAGANT
		cExclLP := "514"
	Endif
	If lExclDsd //Desdobramento
		cExclLP:="578"
	Endif
Endif

aCpos := F050HeadCT(cExclLP,"FINA050",@aAltera,3) //Monta array com os campos a serem criados na tabela temporária

F050Cria(aCpos) //Função responsavel por inserir a tabela temporária no banco de dados

Return

/*/{Protheus.doc} F050RatDes
Tratamento para When de dicionário
@author Totvs
@since 02.01.17
/*/
Function F050RatDes(nOpcCpo)

Local lRet := .F.

DEFAULT nOpcCpo := 0

//Verifico se permite rateios de desdobramento no mesmo titulo
If lRatDsd == NIL
	lRatDsd := IIF(GetMv("MV_RATDESD",,"2") == "1", .T., .F.)
Endif

lRet := lRatDsd

If nOpcCpo == 0
	lRet := .F.
ElseIf !lRet
	If nOpcCpo == 1         //E2_MULTNAT
		lRet := (MV_MULNATP .AND. M->E2_DESDOBR == "N")
	ElseIf nOpcCpo == 2     //E2_RATEIO
		lRet := (M->E2_DESDOBR == "N" .AND. M->E2_MULTNAT == "2")
	ElseIf nOpcCpo == 3     //E2_DESDOBR
		lRet := (M->E2_RATEIO == "N" .AND. M->E2_MULTNAT == "2" )
	Endif
Endif

Return lRet

/*/{Protheus.doc}VldConcDda
//Função valida se o título a ser excluído possui conciliação DDA.
@author Sivaldo Oliveira
@since  20/02/2017
@version 12
/*/
Function VldConcDda(cFil, cForn, cLoja, cCodBar, cChaveDda)
Local aAreaAt := GetArea()
Local lRet := .F.

cQry := "SELECT COUNT(FIG_DDASE2) NUMREG FROM " + RetSqlName("FIG")
cQry += " WHERE FIG_FILIAL = '" + cFil + "' AND "
cQry += "FIG_FORNEC = '" + cForn + "' AND "
cQry += "FIG_LOJA = '" + cLoja + "' AND "
cQry += "FIG_CODBAR = '" + cCodBar + "' AND "
cQry += "FIG_CONCIL = '1' AND "
cQry += "FIG_DDASE2 = '" + cChaveDda + "' AND "
cQry += "D_E_L_E_T_ = ' ' "

cQry := ChangeQuery(cQry)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQry),"TMPFIG",.T.,.T.)
TcSetField("TMPFIG","NUMREG"  ,"N", 17,2)

lRet := TMPFIG->NUMREG > 0
RestArea(aAreaAt)
TMPFIG->(dbCloseArea())

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} F050BlkSA6

Validation for closed banks

@author Flavio Lopes

@since 29/03/2017
@version 12/MA3
/*/
//-------------------------------------------------------------------
Function F050BlkSA6()
Local lRet := .T.

If !Empty(M->E2_PORTADO)
	SA6->(DbSetOrder(1))
	If SA6->(DbSeek(xFilial("SE2") + M->E2_PORTADO))
		If SA6->A6_BLOCKED == "1"
			Help("",1,"FA050BANKBLOCK") //This account is blocked and cannot be used.
			lRet := .F.
		Endif
	Endif
Endif

Return lRet

/*/{Protheus.doc} F050VTitEmp
Ver se o titulo foi gerado por Emprestimo (metodo antigo antes da grava‡?o da Origem)
@author Pequim
@since 04/06/2015
@version P11
@return Retorno Booleano da validação dos dados
/*/
Static Function F050VTitEmp()

Local lRet := .F.

IF nTamFor == NIL
	nTamFor	:= TamSX3("E2_FORNECE")[1]
Endif
If cForPar == NIL
	cForPar	:= PadR(SuperGetMV("MV_FOREMPR",.F.,"000001"),nTamFor)
Endif
If nTamEHNum == NIL
	nTamEHNum 	:= TAMSX3("EH_NUMERO")[1]
EndIf

If SE2->E2_PREFIXO == "EMP" .and. SE2->E2_TIPO == "PR "
	SEH->(dbSetOrder(1))
	If SEH->(MsSeek(xFilial("SEH")+PADR(SE2->E2_NUM,nTamEHNum))) .and. SEH->EH_NATUREZ == SE2->E2_NATUREZ .and. SEH->EH_APLEMP == "EMP" .and. cForPar == SE2->E2_FORNECE
		lRet := (SEH->EH_GERPARC == '1')
	EndIf
EndIf

Return lRet

//-------------------------------------------------------
/*/ FA050PenC
Verifica se existem baixas pendentes de contabilizacao

@author Rodrigo Oliveira

@since 19/03/2015
@version P12
*/
//-------------------------------------------------------
Static Function FA050PenC(aChave As Array) As Array

Local aPenCont		As Array
Local cQuery		As Character
Local lRet			As Logical
Local aArea			As Array
Local cLAP			As Character
Local cLAR			As Character

If ValType(aChave) == "U"
	aChave := Array(7)
	aFill(aChave,"")
Endif

aPenCont := {}
lRet := .F.
cLAP := cLAR := 'S'
aArea := SE5->(GetArea())

cQuery := " SELECT P.LAP,P.RECNOP,R.LAR,R.RECNOR "
cQuery += " FROM "
cQuery += " (SELECT  E5_LA LAP, R_E_C_N_O_ RECNOP "
cQuery += " FROM "+ RetSqlName( "SE5" ) + " SE5 "
cQuery += " WHERE D_E_L_E_T_ = ' '  AND "
cQuery += " E5_FILIAL = '" +aChave[1]+ "' AND "
cQuery += " E5_PREFIXO = '" +aChave[2]+ "' AND "
cQuery += " E5_NUMERO = '" +aChave[3]+ "' AND "
cQuery += " E5_PARCELA = '" +aChave[4]+ "' AND "
cQuery += " E5_TIPO = '" +aChave[5]+ "' AND "
cQuery += " E5_CLIFOR = '" +aChave[6]+ "' AND "
cQuery += " E5_LOJA = '" +aChave[7]+ "' AND "
cQuery += " E5_SITUACA <> 'C' AND "
cQuery += " E5_RECPAG = 'P')P,  "
cQuery += " (SELECT  E5_LA LAR, R_E_C_N_O_ RECNOR "
cQuery += " FROM "+ RetSqlName( "SE5" ) + " SE5 "
cQuery += " WHERE D_E_L_E_T_ = ' '  AND "
cQuery += " E5_FILIAL = '" +aChave[1]+ "' AND "
cQuery += " E5_PREFIXO = '" +aChave[2]+ "' AND "
cQuery += " E5_NUMERO = '" +aChave[3]+ "' AND "
cQuery += " E5_PARCELA = '" +aChave[4]+ "' AND "
cQuery += " E5_TIPO = '" +aChave[5]+ "' AND "
cQuery += " E5_CLIFOR = '" +aChave[6]+ "' AND "
cQuery += " E5_LOJA = '" +aChave[7]+ "' AND "
cQuery += " E5_SITUACA <> 'C' AND "
cQuery += " E5_RECPAG = 'R')R  "

If Select("TSQL") > 0
	dbSelectArea("TSQL")
	DbCloseArea()
EndIf

dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TSQL",.F.,.T.)

dbSelectArea("TSQL")
TSQL->(dbGotop())
Do While TSQL->(!Eof())
	TCSetField("TSQL", "RECNOP" ,"N",16,0)
	TCSetField("TSQL", "RECNOR" ,"N",16,0)
	cLAP	:= If(alltrim(TSQL->LAP) <> 'S','N','S')
	cLAR	:= If(alltrim(TSQL->LAR) <> 'S','N','S')

	If alltrim(cLAP) <> alltrim(cLAR)
		If alltrim(cLAP) <> 'S'
			aAdd(aPenCont,TSQL->RECNOP)
		Else
			aAdd(aPenCont,TSQL->RECNOR)
		Endif
	Endif
	TSQL->(DbSkip())
EndDo

DbCloseArea()
RestArea(aArea)

Return aPenCont

//-------------------------------------------------------
/*/ FA050PenC
Lista baixas pendentes de contabilizacao validando se
o processo tera continuidade via retorno logico.

@author Rodrigo Oliveira

@since 19/03/2015
@version P12
*/
//-------------------------------------------------------
Static Function FA050MonP(aPenCont As Array) As Logical

Local lRet		As Logical
Local nX 		As Numeric
Local aReg		As Array
Local aArea		As Array
Local oDlg		As Object
Local cTit		As Character
Local cReg		As Character
Local cTxtRotAut	As Character

lRet	:= .T.
nX		:= 0
aReg	:= {}
aArea	:= SE5->(GetArea())
cReg	:= " { "
cTit := cTxtRotAut := ""

DbSelectArea("SE5")
For nX := 1 to Len(aPenCont)
	If nX > 1
		cReg += " , "
	EndIf
	DbGoTo(aPenCont[nX])
	cReg += " { '" + Alltrim(E5_TIPODOC)+ "','"+ VerTpDoc(E5_TIPODOC)+ "',Val('" + Str(Round(E5_VALOR,2))+ "') ,'" + Alltrim(E5_SEQ)+ "','" +AllTrim(Str(aPenCont[nX])) + "' }	"
Next nX
cReg		+= " } "
aReg		:= &(cReg)

cTit := SE5->(E5_FILIAL + E5_PREFIXO + E5_NUMERO + E5_PARCELA + E5_TIPO  + E5_CLIFOR + E5_LOJA )
If !FwIsInCallStack("FaAvalSE2") .And. !lF050Auto

	DEFINE MSDIALOG oDlg TITLE STR0026 FROM 180,180  TO 500,700 PIXEL
	@ 10, 10 TO 130,255 of oDlg PIXEL
	@ 20, 030 SAY STR0285 SIZE 170,10 of oDlg PIXEL
	@ 35, 030 SAY STR0286 SIZE 30,10 of oDlg PIXEL
	@ 35, 070 SAY cTit SIZE 100,10 of oDlg PIXEL
	@ 50, 030 SAY STR0287 SIZE 170,10 of oDlg PIXEL
	@ 25, 220 BUTTON STR0014 SIZE 030, 015 PIXEL OF oDlg ACTION (lRet := .T., oDlg:End())
	@ 45, 220 BUTTON STR0288 SIZE 030, 015 PIXEL OF oDlg ACTION (lRet := .F., oDlg:End())

	oBrowse := TWBrowse():New( 70 , 15, 235,50,,{STR0289,STR0290,STR0291,STR0292,'Recno'},{30,100,30,50,30},;
	oDlg,,,,,{||},,,,,,,.F.,,.T.,,.F.,,, )

	oBrowse:SetArray(aReg)
	oBrowse:bLine := &("{ || {aReg[oBrowse:nAt,01], aReg[oBrowse:nAt,02], aReg[oBrowse:nAt,03], aReg[oBrowse:nAt,04], aReg[oBrowse:nAt,05] } } ")
	oBrowse:lColDrag	:= .T.

	ACTIVATE MSDIALOG oDlg
Else
	lRet := .F.
	If lF050DELC
		lRet := Execblock("F050DELC",.F.,.F.,aReg)
	EndIf
	If !lRet
		cTxtRotAut := STR0293 + cTit + STR0294
		cTxtRotAut += STR0295 + CRLF + CRLF
		lMsErroAuto := .F.
		Help(" ",1,"PENCONT","FINA050 - " + STR0007,cTxtRotAut,1,0)
	EndIf
EndIF

RestArea(aArea)

Return lRet

//-------------------------------------------------------
/*/ F050AtuPFS
Atualiza informações referentes a integração SIGAPFS x SIGAFIN.

@author Jorge Martins

@since 09/03/2018
@version P12
*/
//-------------------------------------------------------
Function F050AtuPFS(nOpc, nRecSE2, nRecSE5)
Local lRet := .T.

Default nRecSE2 := SE2->(Recno())
Default nRecSE5 := SE5->(Recno())

Do Case
	Case nOpc == 3 .And. FindFunction("JIncTitCP")
	lRet := JIncTitCP(nRecSE2, nRecSE5)

	Case nOpc == 4 .And. FindFunction("JAltTitCP")
	lRet := JAltTitCP(nRecSE2)

	Case nOpc == 5 .And. FindFunction("JDelTitCP")
	lRet := JDelTitCP(nRecSE2)
EndCase

If lRet .And. FindFunction("JDesdFilho")
	lRet := JDesdFilho(nOpc, nRecSE2)
EndIf

Return lRet

//-------------------------------------------------------
/*/ R604Is48

@author TOTVS S/A

@since 01/01/2018
@version P12
*/
//-------------------------------------------------------
Function R604Is48(cFilOrig,cPrefix,cNUm,cParcel,cTipo,cForn,cLoj)
	Local lRet As Logical // if bill included in Payment Request
	Local cQuery As Character
	Local nStatus As Numeric
	Local aArea As Array

	aArea := GetArea()

	cQuery	:= "SELECT F48.F48_FLORIG, F48.F48_PREFIX, F48.F48_NUM, F48.F48_PARCEL, F48.F48_TYPE, F47.F47_SUPP, F47.F47_UNIT, F47.F47_CODREQ "
	cQuery	+= "FROM " + RetSQLName("F48") +" F48 INNER JOIN " +  RetSQLName("F47") + " F47 "
	cQuery	+= " ON F48.F48_IDF48 = F47.F47_IDF47 "
	cQuery	+= " WHERE F48.F48_FILIAL = '" + xFilial("F48") + "' AND F48.F48_FLORIG = '" + cFilOrig + "'"
	cQuery	+= " AND F48.F48_PREFIX = '" + cPrefix + "'"
	cQuery	+= " AND F48.F48_NUM = '" + cNUm + "'"
	cQuery	+= " AND F48.F48_PARCEL = '" + cParcel + "'"
	cQuery	+= " AND F48.F48_TYPE = '" + cTipo + "'"
	cQuery	+= " AND F47.F47_SUPP = '" + cForn + "'"
	cQuery	+= " AND F47.F47_UNIT = '" + cLoj + "'"
	cQuery	+= " AND F47.D_E_L_E_T_ = ' '  AND F48.D_E_L_E_T_ = ' ' "

	nStatus := TCSqlExec(cQuery)
	cQuery := ChangeQuery(cQuery)
	If select("TMPFIL") > 0
		TMPFIL->(DbCloseArea())
	Endif
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery), "TMPFIL", .T., .F.)
	If !(TMPFIL->(Eof()))
		lRet:=.T.
	Else
		lRet:=.F.
	EndIf
	RestArea(aArea)
Return (lRet)

//-------------------------------------------------------
/*/ FIN50PQBrw

@author TOTVS S/A

@since 01/01/2018
@version P12
*/
//-------------------------------------------------------
Function FIN50PQBrw()
	Local aSize     As Array
	Local aStr      As Array // Structure to show
	Local aColumns  As Array
	Local nX        As Numeric
	Local cTitle    As Character

	Private oPQDlg    As object
	Private oBrowsePut  As object
	Private oTmpPQs  As Object
	Private cTmpPQs    As character
	Private cMark   As character

	aSize	:= MsAdvSize()
	nX:=0
	cTmpPQs	:= CriaTrab(,.F.)
	aStr	:= {}
	aColumns 	:= {}
	cTitle:=""

	// Create temporary table
	MsgRun(STR0304,STR0305,{|| PQCreaTRB()}) //"Please wait"//"Creating temporary table"

	iF ((cTmpPQs)->(Eof()))
		Help("",1,STR0306,,STR0307,1,0) // STR0056 - FINA 050 -- Can not find any Payment Requests for this bill
	Else
		aAdd( aStr, {"F47_FILIAL"	,RetTitle("F47_FILIAL"), PesqPict("F47","F47_FILIAL")})
		aAdd( aStr, {"F47_CODREQ"  	,RetTitle("F47_CODREQ"), PesqPict("F47","F47_CODREQ")})
		aAdd( aStr, {"F47_DTREQ"	,RetTitle("F47_DTREQ"), PesqPict("F47","F47_DTREQ")})
		aAdd( aStr, {"F47_SUPP"	    ,RetTitle("F47_SUPP"), PesqPict("F47","F47_SUPP")})
		aAdd( aStr, {"F47_UNIT"	    ,RetTitle("F47_UNIT"), PesqPict("F47","F47_UNIT")})
		aAdd( aStr, {"F47_VALUE"	,RetTitle("F47_VALUE"), PesqPict("F47","F47_VALUE")})
		aAdd( aStr, {"F47_PRIORI"  	,RetTitle("F47_PRIORI"), PesqPict("F47","F47_PRIORI")})
		aAdd( aStr, {"CTO_DESC"  	,RetTitle("CTO_DESC"), PesqPict("CTO","CTO_DESC")})

		For nX := 1 TO  8
			AAdd(aColumns,FWBrwColumn():New())
			aColumns[Len(aColumns)]:SetData( &("{||"+aStr[nX][1]+"}") )
			aColumns[Len(aColumns)]:SetTitle(aStr[nX][2])
			aColumns[Len(aColumns)]:SetSize(TamSx3(aStr[nX][1])[1])
			aColumns[Len(aColumns)]:SetDecimal(TamSx3(aStr[nX][1])[2])
			aColumns[Len(aColumns)]:SetPicture(aStr[nX][3])
		Next nX

		oPQDlg := MsDialog():New( aSize[7], aSize[2], aSize[6], aSize[5], STR0308, , , , , CLR_BLACK, CLR_WHITE, , , .T., , , , .T.) // PQs

		oBrowsePut := FWMBrowse():New()
		//oBrowsePut:SetAlias("SRA")
		oBrowsePut:SetAlias(cTmpPQs)
		oBrowsePut:SetOwner(oPQDlg)
		oBrowsePut:SetColumns(aColumns)
		aRotina	 := FIN50BrMen() //Reset global aRotina
		oBrowsePut:SetMenuDef("FIN50BrMen")

		oBrowsePut:Activate()
		oPQDlg:Activate(,,,.T.,,,)

		If !Empty (cTmpPQs)
			dbSelectArea(cTmpPQs)
			dbCloseArea()
			cTmpPQs := ""
			dbSelectArea("SE2")
			dbSetOrder(1)
		EndIf

		If oTmpPQs <> Nil
			oTmpPQs:Delete()
			oTmpPQs := Nil
		Endif
	eNDIF

	aRotina	 := MenuDef() //Return aRotina
return (.T.)

Return NIL

//-------------------------------------------------------
/*/ FIN50PQBrw

@author TOTVS S/A

@since 01/01/2018
@version P12
*/
//-------------------------------------------------------
Static Function PQCreaTRB()
	Local aFields   As Array
	local cQuery    As Character
	Local cSupp     As Character
	Local cUnit     As Character
	Local aArea		As Array
	Local cPrefix	As Character
	Local cNum		As Character
	Local cParcel	As Character
	Local cType		As Character

	aArea:=GetArea("SE2")
	cPrefix:=SE2->E2_PREFIXO
	cNum:=SE2->E2_NUM
	cParcel:=SE2->E2_PARCELA
	cType:=SE2->E2_TIPO
	cSupp:=SE2->E2_FORNECE
	cUnit:=SE2->E2_LOJA

	/* Object creation*/
	oTmpPQs := FWTemporaryTable():New(cTmpPQs)

	// Table fields - structure
	aFields := {}
	//aadd(aFields,{"PQ_OK"		, "C", 1,   00})
	aadd(aFields,{"F47_FILIAL"	, "C", TamSX3("F47_FILIAL")[1], 00})
	aadd(aFields,{"F47_CODREQ"	, "C", TamSX3("F47_CODREQ")[1], 00})
	aadd(aFields,{"F47_DTREQ"	, "D", TamSX3("F47_DTREQ")[1],  00})
	aadd(aFields,{"F47_SUPP"	, "C", TamSX3("F47_SUPP")[1],   00})
	aadd(aFields,{"F47_UNIT"	, "C", TamSX3("F47_UNIT")[1],   00})
	aadd(aFields,{"F47_VALUE"	, "N", TamSX3("F47_VALUE")[1],  00})
	aadd(aFields,{"F47_PRIORI"	, "C", TamSX3("F47_PRIORI")[1], 00})
	aadd(aFields,{"CTO_DESC"  	, "C", TamSX3("CTO_DESC")[1], 00})

	oTmpPQs:SetFields(aFields)
	oTmpPQs:AddIndex("Indice2", {"F47_FILIAL", "F47_CODREQ"} )

	// Table creation - data
	oTmpPQs:Create()
	cQuery := "INSERT INTO " + oTmpPQs:GetRealName()
	cQuery += " SELECT F47_FILIAL, F47_CODREQ , F47_DTREQ , F47_SUPP , F47_UNIT, "
	cQuery += " F47_VALUE , F47_PRIORI, CTO_DESC"
	cQuery += " FROM " + RetSQLName("F47") + " F47 "
	cQuery += " INNER JOIN " + RetSQLName("CTO") + " CTO ON (F47_CURREN=CTO_MOEDA and CTO_FILIAL = '" + xFILIAL("F47",CTO->CTO_FILIAL) + "') "
	cQuery += " INNER JOIN " + RetSQLName("F48") + " F48 ON (F47_IDF47=F48_IDF48 and F48_FILIAL = '" + xFILIAL("F48") + "') "
	cQuery += " WHERE F47.D_E_L_E_T_ =' ' AND F48.D_E_L_E_T_=' '"
	cQuery += " AND F48_PREFIX = '" + cPrefix + "'"
	cQuery += " AND F48_NUM  = '" +  cNum  + "'"
	cQuery += " AND F48_PARCEL = '" + cParcel +"'"
	cQuery += " AND F48_TYPE = '" + cType +"'"
	cQuery += " AND F47_SUPP = '" + cSupp +"'"
	cQuery += " AND F47_UNIT = '" + cUnit +"'"

	nStatus := TCSqlExec(cQuery)

	DbSelectArea(cTmpPQs)
	DbGotop()
Return (NIL)

Static Function FIN50BrMen()
	Local aRet As Array
	aRet := {{STR0309,  "FIN50OkBr()", 0, 2, 0, Nil},;	//Ok
			{STR0310, "FIN50ClBr()", 0, 1, 0, Nil}}		//Cancel

Return (aRet)

//-------------------------------------------------------
/*/ FIN50ClBr

@author TOTVS S/A

@since 01/01/2018
@version P12
*/
//-------------------------------------------------------
Function FIN50ClBr()
	oPQDlg:End()
Return .F.

//-------------------------------------------------------
/*/ FIN50OkBr

@author TOTVS S/A

@since 01/01/2018
@version P12
*/
//-------------------------------------------------------
Function FIN50OkBr()
	Local aEnableButtons As Array
	Local aArea As Array
	Local cKey As Character

	aEnableButtons := {{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.T.,STR0310},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil}} //Hide the standart options of the Form
	aArea := (cTmpPQs)->(GetArea())
	cKey:=(cTmpPQs)->F47_FILIAL+(cTmpPQs)->F47_CODREQ
	RestArea(aArea)

	dbSelectArea("F47")
	F47->(DbSetOrder(1))
	If F47->(DbSeek(cKey))
	FWExecView( STR0309, "RU06D04", MODEL_OPERATION_VIEW, /*oDlg*/,/*/ {|| .T. }/*/ ,/*bOk*/ , /*nPercReducao*/, aEnableButtons, /*bCancel*/ , /*cOperatId*/, /*cToolBar*/,/* oModel*/ ) // Payment Request - View
	EndIf
	DbCloseArea()

Return .F.


//-------------------------------------------------------
/*/ FA050Va
Função de inclusão de valores acessórios para titulos CP

@author Marcos Gomes
@since  19/03/2015
@version P12

@return lRet	se o processo foi concluido com sucesso
*/
//-------------------------------------------------------
Function Fa050VA(lVAAuto)

Local oModelVA		:= NIL
Local oSubFKD		:= NIL
Local cChave		:= ""
Local cIdDoc		:= ""
Local cLog			:= ""
Local lRet			:= .T.
Local nX			:= 0
Local nTamCod		:= 0
Local aLinhasAlt    := {}

DEFAULT lVAAuto	:= .F.

If __lExisFKD
	nTamCod	:=	TamSx3("FKD_CODIGO")[1]

	If lVAAuto
		//Rotina Automática para VA
		oModelVA := FWLoadModel('FINA050VA')
		oModelVA:SetOperation( 4 ) //Alteração
		oModelVA:Activate()

		oSubFKD := oModelVA:GetModel('FKDDETAIL')

		cChave := xFilial("SE2",SE2->E2_FILORIG) + "|" + SE2->E2_PREFIXO + "|" + SE2->E2_NUM + "|" + SE2->E2_PARCELA + "|" + SE2->E2_TIPO + "|" + SE2->E2_FORNECE + "|" + SE2->E2_LOJA
		cIdDoc := FINGRVFK7( 'SE2', cChave )
		oModelVA:LoadValue( "FK7DETAIL", "FK7_IDDOC", cIdDoc )

		If ALTERA
			// Controle para saber se haverá linhas no FKD que não foram passadas no msExecAuto.
			aLinhasAlt := array(oSubFKD:Length())
			aFill(aLinhasAlt, .F.)

			// Adiciona as linhas passadas no msExecAuto.
			For nX := 1 to Len(aVAAuto)
				If oSubFKD:SeekLine({{"FKD_CODIGO", Padr(aVAAuto[nX, 1], nTamCod)}})
					aLinhasAlt[oSubFKD:GetLine()] := .T.  // Marca a linha como atualizada.
				Else
					oSubFKD:AddLine()
					oSubFKD:SetValue("FKD_CODIGO", Padr(aVAAuto[nX, 1], nTamCod))
				EndIf
				oSubFKD:SetValue("FKD_VALOR", aVAAuto[nX, 2])
			Next nX

			// Apaga as linhas não passadas no msExecAuto.
			For nX := 1 to len(aLinhasAlt)
				If !aLinhasAlt[nX]
					oSubFKD:GoLine(nX)
					oSubFKD:DeleteLine()
				Endif
			Next nX
		Else
			For nX := 1 to Len(aVAAuto)
				If !oSubFKD:IsEmpty()
					oSubFKD:AddLine()
				EndIf
				oSubFKD:SetValue("FKD_CODIGO", Padr(aVAAuto[nX,1],nTamCod) )
				oSubFKD:SetValue("FKD_VALOR",  aVAAuto[nX,2] )
			Next
		Endif

		If oModelVA:VldData()
			FWFormCommit( oModelVA )
		Else
			lRet	 := .F.
			cLog := cValToChar(oModelVA:GetErrorMessage()[4]) + ' - '
			cLog += cValToChar(oModelVA:GetErrorMessage()[5]) + ' - '
			cLog += cValToChar(oModelVA:GetErrorMessage()[6])
			Help( ,,"F050VALAC",,cLog, 1, 0 )
		Endif
		oModelVA:Deactivate()
		oModelVA:Destroy()
		oModelVA := NIL
	Else
		// Chamada com tela para cadastro de VA do títulos CR
		If __lFINA050VA .And. MsgYesNo( STR0314,STR0026)		//###STR0314 "Deseja cadastrar os valores acessórios deste título agora?"###STR0026 "Atençäo"
			FINA050VA()
		Endif
	Endif
Endif

Return lRet
//-------------------------------------------------------------------
/*/{Protheus.doc} F050VldImp()

@author  Sivaldo Oliveira
@since 07/11/2017
@version 12
/*/
//-------------------------------------------------------------------
Function F050VldImp(lTelaRet)
Local nZ As Numeric
Local nPosPcc As Numeric
Local nPosIrf As Numeric
Local nPosIns As Numeric
Local nPosIss As Numeric
Local nPosCid As Numeric
Local nPosSes As Numeric
Local nImpos As Numeric
Local aImpos As Array
Local cChaveFK7 As Character
Local lAlter As Logical
Local cIdOriFKA As Character
Local cFKM As Character
Local lCalcImp As Logical
Local cField As Character
Local nBaseMR As Numeric
Local nCasDec As Numeric
Local nY As Numeric
Local aOutImp As Array
Local aImpConf As Array
Local cLista As Character
Local lCalcIssBx As Logical
Local lIRPFBaixa As Logical
Local lPCCBaixa As Logical
Local lIsPA As Logical
Local lRefazVlr As Logical
Local nValorAux As Numeric

Default lTelaRet := .F.
Default aVetImp := {}

//Inicializa as variáveis
nZ := 0
nPosPcc := 0
nPosIrf := 0
nPosIns := 0
nPosIss := 0
nPosCid := 0
nPosSes := 0
aImpos := {}
nImpos := 0
cChaveFK7 := ""
lAlter := FwIsInCallStack("AxAltera")
cFKM := ""
cField := AllTrim(ReadVar())
nBaseMR := 0
nCasDec := MsDecimais(1)
nY := 0
aOutImp := {}
aImpConf := {}
cLista := ""
lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
lIRPFBaixa := IIf(cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)
lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
lPccBxMR := .F.
lIrfBxMR := .F.
_nImpMR := 0
lIsPA := (M->E2_TIPO $ MVPAGANT)
lRefazVlr := .F.
nValorAux := 0

//Valida se o tipo cálcula impostos
lCalcImp := !M->E2_TIPO $ (MVABATIM+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA +"/"+"SES"+"/"+MV_CPNEG+"/"+"INA") .Or.;
							(AllTrim(M->E2_ORIGEM) $ "FINA290#FINA290M"  .And. Alltrim(M->E2_FATURA) == "NOTFAT")

//Limpa as variáveis de memória.
If lTelaRet		//Consulta tipo de retenção
	If lPccMR
		M->E2_PIS		:= 0
		M->E2_COFINS	:= 0
		M->E2_CSLL		:= 0
	Endif
	If lIrfMR
		M->E2_IRRF		:= 0
	Endif
	If lInsMR
		M->E2_INSS		:= 0
	Endif
	If lIssMR
		M->E2_ISS		:= 0
	Endif
	If lCidMR
		M->E2_CIDE		:= 0
	Endif
	If lSestMR
		M->E2_SEST		:= 0
	Endif

	M->E2_VALOR := nVlrMR
	aImpos := Aclone(aVetImp)
Else


	lPccMR := .F.
	lIrfMR := .F.
	lInsMR := .F.
	lIssMR := .F.
	lCidMR := .F.
	lSestMR := .F.
	lOutImpMR := .F.

	If lAlter .And. cField == "M->E2_NATUREZ"
		cChaveFK7 := xFilial("SE2") + "|" + SE2->E2_PREFIXO + "|" + SE2->E2_NUM + "|" + SE2->E2_PARCELA + "|" + SE2->E2_TIPO + "|" + SE2->E2_FORNECE + "|" + SE2->E2_LOJA
		cIdOriFKA := FINGRVFK7("SE2", cChaveFK7)
		FKA->(DbSetOrder(3))

		If FKA->(MsSeek(xFilial("FKA") + "SE2" + cIdOriFKA))
			aImpConf := FinImpConf("1", cFilAnt, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_NATUREZ)

			For nZ := 1 To Len(aImpConf)
				Do Case
					Case aImpConf[nZ,1] $ "PIS|COF|CSL"
						lPccMR := .T.
					Case aImpConf[nZ,1] == "IRF"
						lIrfMR := .T.
					Case aImpConf[nZ,1] == "INSS"
						lInsMR := .T.
					Case aImpConf[nZ,1] == "ISS"
						lIssMR := .T.
					Case aImpConf[nZ,1] == "CIDE"
						lCidMR := .T.
					Case aImpConf[nZ,1] == "SEST"
						lSestMR := .T.
				EndCase
			Next nZ

			//Refaz a valor de inclusão
			M->E2_VALOR := FinBaseMR(M->E2_VALOR, .T., SE2->E2_FILIAL, M->E2_PREFIXO, M->E2_NUM, M->E2_PARCELA, M->E2_TIPO, M->E2_FORNECE,;
										M->E2_LOJA, lPccMR, lIrfMR, lInsMR, lIssMR, lCidMR, lSestMR, SE2->E2_MOEDA, SE2->E2_TXMOEDA, SE2->E2_EMISSAO)[1]

			M->E2_BASEPIS := M->E2_VALOR
			M->E2_BASECOF := M->E2_VALOR
			M->E2_BASECSL := M->E2_VALOR
			M->E2_BASEIRF := M->E2_VALOR
			M->E2_BASEINS := M->E2_VALOR
			M->E2_BASEISS := M->E2_VALOR
			nVlrMR := M->E2_VALOR

			lPccMR := .F.
			lIrfMR := .F.
			lInsMR := .F.
			lIssMR := .F.
			lCidMR := .F.
			lSestMR := .F.
		EndIf
	ElseIf cField != "M->E2_VALOR" .And. nVlrMR > 0
		M->E2_VALOR := nVlrMR
		lRefazVlr := .T.
	EndIf

	//Cálculo dos impostos
	If lCalcImp .And. !Empty(M->E2_VALOR)
		nBaseMR := M->E2_VALOR

		If M->E2_MOEDA > 1
			nBaseMR := NoRound(xMoeda(M->E2_VALOR, M->E2_MOEDA, 1, M->E2_EMISSAO, (nCasDec + 1), M->E2_TXMOEDA), nCasDec)
		EndIf

		aImpos := FinCalImp("1", M->E2_NATUREZ, M->E2_FORNECE, M->E2_LOJA, cFilAnt, nBaseMR, dDataBase, .F., {}, M->E2_TIPO, cChaveFK7, Nil, {})
	EndIf

	If Len(aImpos) > 0
		
		M->E2_PIS		:= 0
		M->E2_COFINS	:= 0
		M->E2_CSLL		:= 0
		M->E2_IRRF		:= 0
		M->E2_INSS		:= 0
		M->E2_ISS		:= 0
		M->E2_CIDE		:= 0
		M->E2_SEST		:= 0	
	
		M->E2_BASEPIS := M->E2_VALOR
		M->E2_BASECOF := M->E2_VALOR
		M->E2_BASECSL := M->E2_VALOR
		M->E2_BASEIRF := M->E2_VALOR
		M->E2_BASEINS := M->E2_VALOR
		M->E2_BASEISS := M->E2_VALOR
	EndIf

	//Salva o valor de inclusão.
	nVlrMR := M->E2_VALOR

	//controla grv imp MR na alteração
	_lGrvMR := .T.
EndIf

nImpos := Len(aImpos)

For nZ := 1 To nImpos
	Do Case
		Case aImpos[nZ,8] $ "PIS"
			M->E2_PIS += aImpos[nZ,5]
			lPccMR := .T.
			nPosPcc := nZ
			M->E2_BASEPIS := aImpos[nZ,2]
			lPccBxMR := aImpos[nZ,9] == "2"
		Case aImpos[nZ,8] $ "COF"
			M->E2_COFINS += aImpos[nZ,5]
			lPccMR := .T.
			nPosPcc := nZ
			M->E2_BASECOF := aImpos[nZ,2]
			lPccBxMR := aImpos[nZ,9] == "2"
		Case aImpos[nZ,8] $ "CSL"
			M->E2_CSLL += aImpos[nZ,5]
			lPccMR := .T.
			nPosPcc := nZ
			M->E2_BASECSL := aImpos[nZ,2]
			lPccBxMR := aImpos[nZ,9] == "2"
		Case aImpos[nZ,8] == "IRF"
			M->E2_IRRF += aImpos[nZ,5]
			lIrfMR := .T.
			nPosIrf := nZ
			M->E2_BASEIRF := aImpos[nZ,2]
			lIrfBxMR := aImpos[nZ,9] == "2"
		Case aImpos[nZ,8] == "INSS"
			M->E2_INSS += aImpos[nZ,5]
			lInsMR := .T.
			nPosIns := nZ
			M->E2_BASEINS := aImpos[nZ,2]
		Case aImpos[nZ,8] == "ISS"
			M->E2_ISS += aImpos[nZ,5]
			lIssMR := .T.
			nPosIss := nZ
			M->E2_BASEISS := aImpos[nZ,2]
		Case aImpos[nZ,8] == "CIDE"
			M->E2_CIDE += aImpos[nZ,5]
			lCidMR := .T.
			nPosCid := nZ
		Case aImpos[nZ,8] == "SEST"
			M->E2_SEST += aImpos[nZ,5]
			lSestMR := .T.
			nPosSes := nZ
		OtherWise
			Aadd(aOutImp, nZ)
			lOutImpMR := .T.
	EndCase
	
Next nZ

/*
aImpos[z,9] = fator gerador competência ou caixa (PA)
aImpos[z,13] = ação aplicadasobre o vlr da nf (1 = subtrair as retenções)
aImpos[z,14] = carteira de movimento (1 = pagar)
aImpos[z,15] = Tipo de mov na emissão (1 = Abtimento, 2 = Impostos)
*/
//===Verifica quais impostos terão a retenção abatida do vlr da nota===//
//PCC
If lIsPA	//Titulos de adiantamento (PA)
	If lPccMR
		If aImpos[nPosPcc,14] == "1"
			If M->E2_MOEDA > 1
				nValorAux	:= Round(xMoeda(M->E2_PIS, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
				M->E2_VALOR -= nValorAux 
				_nImpMR += nValorAux
				
				nValorAux	:= Round(xMoeda(M->E2_COFINS, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
				M->E2_VALOR -= nValorAux
				_nImpMR += nValorAux
				
				nValorAux 	:= Round(xMoeda(M->E2_CSLL, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
				M->E2_VALOR -= nValorAux
				_nImpMR += nValorAux
			Else
				nValorAux	:= (M->E2_PIS+M->E2_COFINS+M->E2_CSLL)
				M->E2_VALOR -= nValorAux
				_nImpMR += nValorAux				
			EndIf
			
		EndIf
	EndIf

	//IRF
	If lIrfMR
		If aImpos[nPosIrf,14] == "1"
			If M->E2_MOEDA > 1
				nValorAux 	:= Round(xMoeda(M->E2_IRRF, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
			Else
				nValorAux	:= M->E2_IRRF
			EndIf
			M->E2_VALOR -= nValorAux
			_nImpMR += nValorAux
		EndIf
	EndIf

	//INSS
	If lInsMR
		If aImpos[nPosIns,14] == "1"
			If M->E2_MOEDA > 1
				nValorAux	:= Round(xMoeda(M->E2_INSS, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
			Else
				nValorAux	:= M->E2_INSS
			EndIf
			M->E2_VALOR -= nValorAux
			_nImpMR += nValorAux
		EndIf
	EndIf

	//ISS
	If lIssMR
		If aImpos[nPosIss,14] == "1"
			If M->E2_MOEDA > 1
				nValorAux	:= Round(xMoeda(M->E2_ISS, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
			Else
				nValorAux	:= M->E2_ISS
			EndIf
			M->E2_VALOR -= nValorAux
			_nImpMR += nValorAux
		EndIf
	EndIf

	//Cide
	If lCidMR
		If aImpos[nPosCid,14] == "1"
			If M->E2_MOEDA > 1
				nValorAux 	:= Round(xMoeda(M->E2_CIDE, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
			Else
				nValorAux	:= M->E2_CIDE
			EndIf
			M->E2_VALOR -= nValorAux
			_nImpMR += nValorAux
		EndIf
	EndIf

	//SEST
	If lSestMR
		If aImpos[nPosSes,14] == "1"
			If M->E2_MOEDA > 1
				nValorAux	:= Round(xMoeda(M->E2_SEST, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
			Else
				nValorAux	:= M->E2_SEST
			EndIf
			M->E2_VALOR -= nValorAux
			_nImpMR += nValorAux
		EndIf
	EndIf

	//Outros impostos
	If lOutImpMR
		nImpos := Len(aOutImp)
		_nImpMR := 0

		For nZ := 1 To nImpos
			nY := aOutImp[nZ]

			If aImpos[nY,14] != "1"
				Loop
			EndIf

			If M->E2_MOEDA > 1
				M->E2_VALOR -= Round(xMoeda(aImpos[nY,5], 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
				_nImpMR += Round(xMoeda(aImpos[nY,5], 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
			Else
				M->E2_VALOR -= aImpos[nY,5]
				_nImpMR += aImpos[nY,5]
			EndIf
		Next nZ
	EndIf

Else		//Titulos normais
	If lPccMR .And. aImpos[nPosPcc,9] == "1" .And. aImpos[nPosPcc,15] == "2"
		If aImpos[nPosPcc,13] == "1" .And. aImpos[nPosPcc,14] == "1"
			If M->E2_MOEDA > 1
				nValorAux 	:= Round(xMoeda(M->E2_PIS, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
				M->E2_VALOR -= nValorAux
				_nImpMR += nValorAux
				
				nValorAux	:= Round(xMoeda(M->E2_COFINS, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
				M->E2_VALOR -= nValorAux
				_nImpMR += nValorAux
				
				nValorAux	:= Round(xMoeda(M->E2_CSLL, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
				M->E2_VALOR -= nValorAux
				_nImpMR += nValorAux
			Else
				nValorAux	:= (M->E2_PIS+M->E2_COFINS+M->E2_CSLL)
				M->E2_VALOR -= nValorAux
				_nImpMR += nValorAux
			EndIf
		EndIf
	EndIf

	//IRF
	If lIrfMR .And. aImpos[nPosIrf,9] == "1" .And. aImpos[nPosIrf,15] == "2"
		If aImpos[nPosIrf,13] == "1" .And. aImpos[nPosIrf,14] == "1"
			If M->E2_MOEDA > 1
				nValorAux 	:= Round(xMoeda(M->E2_IRRF, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
			Else
				nValorAux	:= M->E2_IRRF
			EndIf
			M->E2_VALOR -= nValorAux
			_nImpMR += nValorAux
		EndIf
	EndIf

	//INSS
	If lInsMR .And. aImpos[nPosIns,9] == "1" .And. aImpos[nPosIns,15] == "2"
		If aImpos[nPosIns,13] == "1" .And. aImpos[nPosIns,14] == "1"
			If M->E2_MOEDA > 1
				nValorAux	:= Round(xMoeda(M->E2_INSS, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
			Else
				nValorAux 	:= M->E2_INSS
			EndIf
			M->E2_VALOR -= nValorAux
			_nImpMR += nValorAux
		EndIf
	EndIf

	//ISS
	If lIssMR .And. aImpos[nPosIss,9] == "1" .And. aImpos[nPosIss,15] == "2"
		If aImpos[nPosIss,13] == "1" .And. aImpos[nPosIss,14] == "1"
			If M->E2_MOEDA > 1
				nValorAux	:= Round(xMoeda(M->E2_ISS, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
			Else
				nValorAux	:= M->E2_ISS
			EndIf
			M->E2_VALOR -= nValorAux
			_nImpMR += nValorAux
		EndIf
	EndIf

	//Cide
	If lCidMR .And. aImpos[nPosCid,9] == "1" .And. aImpos[nPosCid,15] == "2"
		If aImpos[nPosCid,13] == "1" .And. aImpos[nPosCid,14] == "1"
			If M->E2_MOEDA > 1
				nValorAux	:= Round(xMoeda(M->E2_CIDE, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
			Else
				nValorAux	:= M->E2_CIDE
			EndIf
			M->E2_VALOR -= nValorAux
			_nImpMR += nValorAux
		EndIf
	EndIf

	//SEST
	If lSestMR .And. aImpos[nPosSes,9] == "1" .And. aImpos[nPosSes,15] == "2"
		If aImpos[nPosSes,13] == "1" .And. aImpos[nPosSes,14] == "1"
			If M->E2_MOEDA > 1
				nValorAux	:= Round(xMoeda(M->E2_SEST, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
			Else
				nValorAux	:= M->E2_SEST
			EndIf
			M->E2_VALOR -= nValorAux
			_nImpMR += nValorAux
		EndIf
	EndIf

	//Outros impostos
	If lOutImpMR
		nImpos := Len(aOutImp)
		_nImpMR := 0

		For nZ := 1 To nImpos
			nY := aOutImp[nZ]

			If aImpos[nY,9] != "1" .Or. aImpos[nY,15] != "2" .Or. aImpos[nY,13] != "1" .Or. aImpos[nY,14] != "1"
				Loop
			EndIf

			If M->E2_MOEDA > 1
				M->E2_VALOR -= Round(xMoeda(aImpos[nY,5], 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
				_nImpMR += Round(xMoeda(aImpos[nY,5], 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
			Else
				M->E2_VALOR -= aImpos[nY,5]
				_nImpMR += aImpos[nY,5]
			EndIf
		Next nZ
	EndIf
EndIf

aVetImp := Aclone(aImpos)

//Retira os impostos do legado do E2_VALOR
If lTelaRet .or. lRefazVlr
	//PCC
	If !lPccMR .and. (!lPCCBaixa .or. (lPccBaixa .and. lIsPa ))
		If M->E2_MOEDA > 1
			M->E2_VALOR -= Round(xMoeda(M->E2_PIS, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
			M->E2_VALOR -= Round(xMoeda(M->E2_COFINS, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
			M->E2_VALOR -= Round(xMoeda(M->E2_CSLL, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
		Else
			M->E2_VALOR -= (M->E2_PIS+M->E2_COFINS+M->E2_CSLL)
		EndIf
	EndIf

	//IRF
	If !lIrfMR .and. (!lIRPFBaixa .or. (lIRPFBaixa .and. lIsPa ))
		If M->E2_MOEDA > 1
			M->E2_VALOR -= Round(xMoeda(M->E2_IRRF, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
		Else
			M->E2_VALOR -= M->E2_IRRF
		EndIf
	EndIf

	//INSS
	If !lInsMR
		If M->E2_MOEDA > 1
			M->E2_VALOR -= Round(xMoeda(M->E2_INSS, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
		Else
			M->E2_VALOR -= M->E2_INSS
		EndIf
	EndIf

	//ISS
	If !lIssMR .and. (!lCalcIssBx .or. (lCalcIssBx .and. lIsPa ))
		If M->E2_MOEDA > 1
			M->E2_VALOR -= Round(xMoeda(M->E2_ISS, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
		Else
			M->E2_VALOR -= M->E2_ISS
		EndIf
	EndIf

	//Cide
	If !lCidMR
		If M->E2_MOEDA > 1
			M->E2_VALOR -= Round(xMoeda(M->E2_CIDE, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
		Else
			M->E2_VALOR -= M->E2_CIDE
		EndIf
	EndIf

	//SEST
	If !lSestMR
		If M->E2_MOEDA > 1
			M->E2_VALOR -= Round(xMoeda(M->E2_SEST, 1, M->E2_MOEDA, M->E2_EMISSAO, (nCasDec + 1),, M->E2_TXMOEDA), 2)
		Else
			M->E2_VALOR -= M->E2_SEST
		EndIf
	EndIf
Endif

M->E2_VLCRUZ := Round(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA),MsDecimais(1))
M->E2_SALDO  := M->E2_VALOR

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} F050ImpCon()

@author  Sivaldo Oliveira
@since 07/11/2017
@version 12
/*/
//-------------------------------------------------------------------
Static Function F050ImpCon(nOper As Numeric)
Local nY As Numeric
Local nImpConf As Numeric
Local aImpConf As Array

Default lPccMR := .F.
Default lIrfMR := .F.
Default lInsMR := .F.
Default lIssMR := .F.
Default lCidMR := .F.
Default lSestMR := .F.
Default nOper := 0

//Inicializa a variável
nY := 0
nImpConf := 0
aImpConf := {}

//Verifica quais os impostos configurados
If nOper == 3 //Inclusao
	aImpConf := FinImpConf("1", cFilAnt, M->E2_FORNECE, M->E2_LOJA, M->E2_NATUREZ)
Else
	aImpConf := FinImpConf("1", cFilAnt, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_NATUREZ)
EndIf

nImpConf := Len(aImpConf)

For nY := 1 To nImpConf
	Do Case
		Case aImpConf[nY,1] $ "PIS|COF|CSL"
			lPccMR := .T.
		Case aImpConf[nY,1] == "IRF"
			lIrfMR := .T.
		Case aImpConf[nY,1] == "INSS"
			lInsMR := .T.
		Case aImpConf[nY,1] == "ISS"
			lIssMR := .T.
		Case aImpConf[nY,1] == "CIDE"
			lCidMR := .T.
		Case aImpConf[nY,1] == "SEST"
			lSestMR := .T.
		OtherWise
			lOutImpMR := .T.
	EndCase
Next nY

Return Nil


//-------------------------------------------------------
/*/{Protheus.doc} F050MRET
Chamada da tela de manutenção das retenções do motor

@author Mauricio Pequim Jr

@since 07/12/2017
@version P12
*/
//-------------------------------------------------------
Function F050MRET()
	FINMRET(aVetImp, 'SE2', .F., /*@nRetMotor*/)
	F050VldImp(.T.)
Return

Return .F.

//-------------------------------------------------------
/*/ F050BtrISS
	Valida se o codigo do servico foi preenchido,
	caso houver ISS

@author Igor Sousa do Nascimento

@since 23/10/2018
@version P12
*/
//-------------------------------------------------------
Function F050BtrISS()

	Local aArea  := GetArea()
	Local lRet	 := .T.
	Local lBlind := IsBlind()

	If lBtrISS
		If Type("M->E2_CODSERV") <> "U"
			dbSelectArea("SED")
			dbSetOrder(1)
			dbSeek(xFilial("SED")+M->E2_NATUREZ)
			If SED->ED_CALCISS == "S"
				If Empty(AllTrim(M->E2_CODSERV))
					dbSelectArea("SA2")
					dbSetOrder(1)
					dbSeek(xFilial("SA2")+M->E2_FORNECE+M->E2_LOJA)
					If Upper(AllTrim(SA2->A2_MUN)) <> Upper(AllTrim(SM0->M0_CIDENT))
						dbSelectArea("CC2")
						dbSetOrder(2)
						If dbSeek(xFilial("CC2")+Pad(Upper(SM0->M0_CIDENT),TamSX3("CC2_MUN")[1]))
							If !lBlind .and. MsgYesNo(STR0319)
								lRet := .F.
								Help("", 1, "F050CODSER")
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

	RestArea(aArea)

Return lRet
